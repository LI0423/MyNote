一、全局网络层次
1.七层网络模型（OSI）
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
（1）物理层：数据的单位是bit。
（2）数据链路层：在物理层提供比特流服务的基础上建立相邻节点之间的数据链路，该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
    数据的单位称为帧。
（3）网络层：选择合适的网间路由和交换节点，确保数据及时传送。单位称为数据包。
（4）传输层：为上层提供端到端的透明的、可靠的数据传输服务。TCP的数据单元称为段，而UDP的数据单元称为数据报。
（5）会话层：提供包括访问验证和会话管理在哪的建和和维护应用之间通信的机制。
（6）表示层：解决用户信息的语法表示问题，提供格式化的表示和转换数据服务，数据的压缩和解压缩，加密和解密等。
（7）应用层：为操作系统或网络应用程序提供访问网络服务的接口。Telnet、FTP、HTTP等。

2.TCP/IP网络模型
    网络接口层、网际层、传输层（TCP、UDP）、应用层。
（1）链接层（网络接口层）：负责在以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来标记网络上的设备。
（2）网际层：IP协议就在这一层，可以在链接层的基础上，用IP地址取代MAC地址，把许多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时，
只要把IP地址“翻译”成MAC地址就可以了。
（3）传输层：这个层次协议的职责是保证数据在IP地址标记的两点之间“可靠”地传输。
（4）应用层：面向具体应用的协议，例如Telnet、SSH、FTP、MTP、HTTP等。

3.五层网络模型
    物理层、数据链路层、网络层、传输层、应用层。

二、TCP协议详解
1、为什么要三次握手
    主要是初始化Sequence Number的初始值。通信的双方要互相通知自己的初始化的Sequence Number。

2、断开连接为什么要四次挥手

3、建立连接SYN超时
    连接会处于一个中间状态，既没成功也没失败。server端如果在一定时间内没有收到TCP的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试
    时间间隔为1s,2s,4s,8s,16s，总共31s。第五次发出后还需要等32s才知道超时了，因此断开连接需要31+32s，也就是63s。

4、SYN Flood攻击
    给服务器发送一个连接请求然后就下线了，于是服务器需要等待63s才能断开，攻击者就可以把服务器的syn队列耗尽，让正常的请求无法连接。Linux下给了一个叫tcp_syncookies的参数来应对。
    当tcp的syn队列满了以后，tcp会通过源地址端口，目标地址端口和时间戳来打造一个特殊的Sequence Number返回去，如果是攻击者就不会有反应，如果是正常的连接就会把这个Syn cookie给
    返回来，然后服务端可以根据syn cookie建立连接。正常的请求可以调整tcp_synack_retries来减少重试次数，调整tcp_max_syn_backlog增大连接数，调整tcp_abort_on_overflow处理
    不过来就直接拒绝。

5、为什么要有TIME_WAIT
（1）TIME_WAIT确保有足够的时间让对端收到ACK，如果被动关闭的那方没有收到ACK，就会触发被动端重发FIN，一来一去刚好两个MSL（Maximum Segment Lifetime）；
（2）有足够的时间让这个连接不会跟后面的连接混在一起。（有些路由器会缓存IP数据包，如果连接被重用那么延迟收到的包就可能会跟新连接混在一起）

6、TCP重传机制
（1）超时重传机制
    一种是不回ACK，死等丢掉的包，当发送方发现收不到丢包的ACK时，会重传丢掉的包，一旦接收方收到丢的包时，会回ACK。会有比较严重的问题，因为要死等丢掉的包，即使后面的包已经收到了，
    发送方也完全不知道发生了什么事，因为没有收到ACK，发送方可能会悲观地认为后面的包也丢了，可能导致后面的包重传。
（2）快速重传机制
    TCP引入了一种叫快速重传的算法，不以时间驱动，而是以数据驱动重传。也就是说如果包没有连续到达，就ACK最后那个可能被丢了的包，如果发送方连续收到3次相同的ACK就重传。
（3）SACK方法
    在TCP头里加一个SACK的东西，发送端根据回传的SACk判断哪些包到了哪些包没到。发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK
    的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。

7.TCP滑动窗口
    TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端可以根据这个接收端的处理能力来发送数据，而不会导致
    接收端处理不过来。
    接收端LastByteRead指向TCP缓冲区读到的位置，NextByteExpected指向的是收到的连续包的最后一个位置，LastByteReved指向的是收到的包的最后一个位置。
    发送端LastByteAcked指向了被接收端ACK过的位置（表示成功发送确认），LastByteSent表示发出去了但还没有收到成功确认的ACK，LastByteWritten指向的是上层应用正在写入的位置。

8.TCP如何保证可靠传输
（1）确认应答和序列号
    TCP传输时将每个字节的数据都进行了编号，这就是序列号。tcp按序号发送报文，接收端收到报文后，会给发送端一个ACK确认报文，用来表示已经成功接收到报文，报文中还带有ACK，表示下一次
    发送端应该从哪里开始发送报文。
（2）超时重传
    如果发送端发送的数据没有收到ACK确认，可能是（1）发送给接收端的报文丢失（2）接收端发送的ACK确认报文丢失了。不管是哪种原因，超过一定时间后，没有收到ACK确认，TCP启动超时重传
    机制，发送端重新发送数据，如果接收端已经有了该数据，只是由于ACK确认丢失导致超时重传，会将刚刚发送过来的数据包丢弃。超时重传保证报文即使丢失能再传输，直到传输成功为止。
（3）流量控制
    发送端如果发送数据过快，导致接收端的缓冲区很快就满了，如果持续下去，数据溢出缓冲区，就会出现数据丢失。这时需要在发送端有一个窗口，窗口的作用为：在发送缓冲区，只有在窗口里面
    的数据，才能被发送，在接收缓冲区，只有在窗口里的数据才能被接收，接收端收到数据之后，会回复ack，发送端会根据ack的值来判断接收能力，从而动态调整窗口大小，实现流量控制。
（4）拥塞控制
    如果网络出现拥塞，TCP会根据不同情况，采用不同算法：慢开始，拥塞避免，快重传，快恢复来对窗口大小cwnd和慢开始门限值ssthresh进行调整，从而降低网络拥塞的可能性。

9.TCP拥塞控制算法
（1）慢开始
    拥塞窗口初始值cwnd=1，慢开始门限值初始值为ssthresh=16。慢开始过程为：拥塞窗口初始值为1，发送端先发送一个数据包，如果该数据包没有出现超时重传，拥塞窗口就翻倍，
    变为2，再发送数据包，如果还没有超时重传，那么继续翻倍，直到拥塞窗口的大小变为16，如果再继续翻倍的话，就会超过慢开始门，所以此时慢开始结束，进入拥塞避免阶段。
（2）拥塞阶段
    当发送的包出现了超时重传，那么就是出现了网络拥塞。当cwnd>ssthresh时，采用拥塞避免算法控制。拥塞避免的过程为：cwnd=16，发送一个数据包，没有超时重传，拥塞窗口cwnd+1变为17，
    依次类推，直到出现了超时重传，说明网络出现了拥塞。拥塞避免算法为：把cwnd设为1，ssthresh设为出现拥塞时的cwnd/2，这样又开始慢传输，当超过ssthresh时又采用拥塞避免控制。
（3）快重传
    如果接收方收不到数据包是因为数据包丢失，而不是网络拥塞，但是把cwnd设为1，ssthresh设为原来cwnd的一半，那网络的传输效率就会很低。所以采用快重传算法，其核心是：如果接收方连续
    三次发送相同的确认包，发送方收到三次确认包后就认为该包丢失，于是重新发送丢失的包。
（4）快恢复
    当发送方连续收到三个重复确认时，把慢开始门限设置为cwnd/2，拥塞窗口的值设为慢开始门减半后的值，然后开始执行拥塞避免算法。

三、UDP协议
1、UDP特点
    UDP无连接，时间上不存在连接需要的延迟，空间上TCP需要在端系统中维护连接状态。
    分组首部开销小，TCP首部20字节，UDP首部8字节。
    UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。
    UDP提供最大努力交付，不保证可靠交付。
    UDP面向报文，对应用层交下来的报文，添加首部后直接向下交付给IP层，既不合并也不拆分。
    UDP常用一次性传输比较少量数据的网络应用。
    UDP支持一对一、一对多、多对一和多对多的交互通信。

四、HTTP协议
1、HTTP特点
    灵活可扩展：可以任意添加头字段实现任意功能。
    可靠传输：因为HTTP协议是基于TCP/IP的，TCP本身就是可靠的传输协议。
    应用层协议：比FTP、SSH等更通用功能更多，能够传输任意数据。
    请求-应答：客户端主动发起请求，服务器被动回复请求。
    无状态：每个请求互相独立、毫无关联，协议不要求客户端或服务器记录请求相关的信息。

2、cookie
    cookie是服务器发送到用户浏览器并保存在本地的一小块数据，会在浏览器之后向同一服务器再次发起请求时被鞋带上，用于告知服务器两个请求是否来自同一浏览器。

3、Session
    Session可以将用户信息存储在服务器端。
    Session维护用户登陆状态的过程：
        用户进行登录时，用户提交包含用户名和密码的表单，放入HTTP请求报文中。
        服务器验证该用户名和密码。
        如果正确则把用户信息保存到Redis中，在Redis中的key称为SessionID。
        服务器返回的响应报文的Set-Cookie首部字段包含了这个这个SessionID，客户端收到响应报文之后将该Cookie值存到浏览器中。
        客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到之后提取出SessionID，从Redis中取出用户信息继续之前的业务操作。

4、报文结构
（1）起始行（start line）：描述请求或响应的基本信息；
（2）头部字段集合（header）：使用key-value形式更详细地说明报文；
（3）消息正文（entity）：实际传输的数据，不一定是纯文本，可以是图片、视频等二进制数据。
    起始行和头部字段合称为请求头或响应头，消息正文又称为实体，但与header对应，称为body。

5、请求行
    请求报文里的起始行也就是请求行，简要描述了客户端想要如何操作服务器端的资源。
    构成：
        请求方法：是一个动词，如GET/POST，表示对资源的操作。
        请求目标：通常是一个URI，标记了请求方法要操作的资源。
        版本号：表示报文使用的HTTP协议版本。
6、状态行
    响应报文里的起始行，叫做状态行，服务器的响应状态。
    构成：
        版本号：表示报文使用的HTTP协议版本。
        状态码：一个三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器错误。
        原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

7、八种请求方法
    GET：获取资源，可以理解为读取或者下载数据。
    HEAD：获取资源的元信息。
    POST：向资源提交数据，相当于写入或上传数据。
    PUT：类似POST。
    DELETE：删除资源。
    CONNECT：建立特殊的连接隧道。
    OPTIONS：列出可对资源实行的方法。
    TRACE：追踪请求-响应的传输路径。

8、响应状态码
    1xx：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
    2xx：成功，报文已经收到并被正确处理；
        200 OK 表示一切正常。
        204 Not Content 与200基本相同，但响应头后没有body数据。
        206 Partial Content 是HTTP分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现。通常还伴随着头字段“Content-Range”，
        表示响应报文里body数据的具体范围，供客户端确认。
    3xx：重定向，资源位置发生变动，需要客户端重新发送请求；
        301 Moved Permanently 永久重定向，此次请求的资源已经不存在，需要改用新的URI再次访问。
        302 Found 曾经的描述短语是 Moved Temporarily 临时重定向，请求的资源还在，但需要暂时用另一个URI来访问。
        304 Not Modified 缓存重定向，表示资源未修改，用于缓存控制，不具有通常的跳转含义。
    4xx：客户端错误，请求报文有误，服务器无法处理；
        400 Bad Request 表示请求报文有错误，但具体是数据格式错误还是URI超长没有明确说。
        403 Forbidden 表示服务器禁止访问资源。
        404 Not Found 资源在本服务器上未找到，所以无法提供给客户端。
        405 Method Not Allowed 不允许使用某些方法操作资源。
        406 Not Acceptable 资源无法满足客户端请求的条件，例如请求中文但只有英文。
        408 Request Timeout 请求超时，服务器等待了过长的时间。
        409 Conflict 多个请求发生了冲突，可以理解为多线程并发时的竞态。
        413 Request Entity Too Large 请求报文里body太大。
        414 Request-URI Too Long 请求行里的URI太大。
        429 Too Many Requests 客户端发送了太多的请求，通常是由于服务器的限连策略。
        431 Request Header Fields Too Large 请求头某个字段或总体太大。
    5xx：服务器错误，服务器在处理请求时内部发生了错误。
        500 Internal Server Error 通用错误码。
        501 Not Implemented 表示客户端请求的功能还不支持。
        502 Bad Gateway 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误。
        503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务。

9、CDN 内容分发网络
    CDN 最核心原则“就近访问”，CDN使用缓存代理技术，把源站的内容逐级缓存到网络的每一个节点上。用户在上网的时候就不直接访问源站，而是访问离他“最近的”一个CDN节点，
    术语叫“边缘节点”，其实就是缓存了源站内容的代理服务器。
    CDN有两个关键组成部分，全局负载均衡和缓存系统：
        全局负载均衡：简称为GSLB，主要职责是当用户接入网络的时候在CDN专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，
            对整个CDN网络进行负载均衡。智能调度的依据：看用户的IP地址，查表得知地理位置，找相对最近的边缘节点；看用户所在的运营商网络，找相同网络的边缘节点；
            检查边缘节点的负载情况，找负载较轻的节点；其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。
        缓存系统：“命中”就是指用户访问的资源恰好放在缓存系统里可以直接返还给用户；“回源”则相反，缓存里没有，必须用代理回源站取。“命中率”就是命中次数与所有访问
            次数之比，回源率是回源次数与所有访问次数之比。

10、HTTP服务器优化
    衡量服务器性能的主要指标：吞吐量（requests per second）、并发数（concurrency）、响应时间（time per request）。
    

五、HTTPS协议
    HTTPS是让HTTP先和SSL（Secure Sockets Layer）通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。通过使用SSL，HTTPS具有了加密（防窃听）、
    认证（防伪装）和完整行保护。
    
1、过程
    服务器把自己的公钥登录至数字认证机构。
    数字证书机构把自己的私有密钥向服务器的公开密钥部署数字签名并颁发公钥证书。
    客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器公钥的真实性。
    使用服务器的公开密钥对报文加密后发送。
    服务器私有密钥对报文解密。

六、DNS
1、浏览器通过域名去查询URL对应的IP
    浏览器缓存：浏览器会按照一定的频率缓存DNS记录
    操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就去操作系统中找。
    路由缓存：路由器也有DNS缓存。
    ISP的DNS服务器：ISP是互联网提供商的简称，ISP有专门的DNS服务器应对DNS查询请求。
    根服务器：ISP的DNS服务器还找不到的话，就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器依此类推）
    