# WebSocket

## 什么是WebSocket

WebSocket是基于TCP连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。WebSocket协议本质上是应用层的协议，用于弥补HTTP协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者就直接可以创建持久性的连接，并进行双向数据传输。

## WegSocket和HTTP有什么区别

1. WebSocket是一种双向实时通信协议，而HTTP是一种单向通信协议。并且HTTP协议下的通信只能由客户端发起，服务器无法主动通知客户端。
2. WebSocket使用ws://或wss://（使用SSL/TLS加密后的协议，类似于HTTP和HTTPS的关系）作为协议前缀，HTTP使用http://或https://作为协议前缀。
3. WebSocket支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。
4. WebSocket通信数据格式比较清凉，用于协议控制的数据包头部相对较小，网络开销小，而HTTP通信每次都要携带完整的头部，网络开销较大。（HTTP/2.0使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）

## WebSocket的工作过程是什么样的

1. 客户端向服务器发送一个HTTP请求，请求头中包含Upgrade: websocket 和 Sec-WebSocket-Key等字段，表示要求升级协议为WebSocket。
2. 服务器收到这个请求后，会进行升级协议的操作，如果支持WebSocket，将回复一个HTTP 101状态码，响应头中包含Connection: Upgrade 和 Sec-WebSocket-Accept: xxx 等字段，表示成功升级到WebSocket协议。
3. 客户端和服务器之间建立了一个WebSocket连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。
4. 客户端或服务器主动发送一个关闭帧，表示要断开连。另一方收到后，也会回复一个关闭帧，然后双方关闭TCP连接。

## WebSocket消息帧结构

结束标志位+操作码+帧长度+掩码

1. 第一个字节的第一位“FIN”是消息结束的标志位，表示数据发送完毕。一个消息可以拆成多个帧，接收方看到“FIN”后，可以把前面的帧拼起来，组成完整的消息。
2. “FIN”后面的三个位是保留位，目前没有任何意义，但必须是0。
3. 第一个字节的后4位很重要，叫“Opcode”，操作码，就是帧类型，比如1表示帧内容是纯文本，2表示帧内容是二进制数据，8是关闭连接，9和10是连接保活的PING和PONG。
4. 第二个字节第一位是掩码标志位“MASK”，表示帧内容是否使用异或操作做简单的加密。目前的WebSocket标准规定，客户端发送数据必须使用掩码，而服务器发送则不使用掩码。
5. 第二个字节后7位是“Payload len”，表示帧内容的长度。是另一种变长编码，最少7位，最多是7+64位，也就是额外增加了8个字节，所以一个WebSocket帧最大是2^64。
6. 长度字段后面是“Masking-key”，掩码密钥，是由上面的标志位“MASK”决定的，如果使用掩码就是4个字节的随机数，否则就不存在。

## WebSocket与短轮询、长轮询的区别

### 短轮询

- 原理：客户端每隔固定时间（如5秒）发起一次HTTP请求，询问服务器是否有新数据。服务器收到请求后立即响应。
- 优点：实现简单，兼容性好，直接用常规HTTP请求即可。
- 缺点：
  - 实时性一般：消息可能在两次轮询到达，用户需等到下次请求才知晓。
  - 资源浪费大：反复建立/关闭连接，且大多数请求收到的都是“无新消息”，极大增加服务器和网络压力。

### 长轮询

- 原理：客户端发起请求后，若服务器暂时无新数据，则会保持连接，直到有新数据或超时才响应。客户端收到响应后立即发起下一次请求，实现“伪实时”。
- 优点：
  - 实时性较好：一旦有新数据可立即推送，无需等待下次定时请求。
  - 空响应减少：减少了无效的空响应，提升了效率。
- 缺点：
  - 服务器资源占用高：需长时间维护大量连接，消耗服务器线程/连接数。
  - 资源浪费大：每次响应后仍需重新建立连接，且依然基于HTTP单向请求-响应机制。

### WebSocket

- 原理：客户端与服务器通过一次HTTPUpgrade握手后，建立一条持久的TCP连接。之后，双方可以随时、主动地发送数据，实现真正的全双工、低延迟通信。
- 优点：
  - 实时性强：数据可即使双向收发，延迟极低。
  - 资源效率高：连接持续，无需反复建立/关闭，减少资源消耗。
  - 功能强大：支持服务端主动推送消息、客户端主动发起通信。
- 缺点：
  - 使用限制：需要服务器和客户端都支持WebSocket协议。对连接管理有一定要求（如心跳保活、短线重连等）。
  - 实现麻烦：实现起来比短轮询和长轮询要更麻烦些。

## SSE与WebSocket有什么区别

1. 通信方式：
   - SSE：单向通信。只有服务器能向客户端（浏览器）发送数据。客户端不能通过同一个连接向服务器发送数据（需要发起新的HTTP请求）。
   - WebSocket：双向通信（全双工）。客户端和服务器可以随时互相发送消息，实现真正的实时交互。
2. 底层协议：
   - SSE：基于标准的HTTP/HTTPS协议。它本质上是一个“长连接”的HTTP请求，服务器保持连接打开并持续发送事件流。不需要特殊的服务器或协议支持。现有的HTTP基础设施就能用。
   - WebSocket：稍微复杂一些。需要服务器端支持专门处理WebSocket连接和协议，客户端也需要使用WebSocket API。如果需要考虑兼容性、心跳、重连等，开发成本会更高。
3. 实现复杂度和成本：
   - SSE：实现相对简单，主要在服务器端处理。浏览器端有标准的EventSource API，使用方便。开发和维护成本较低。
   - WebSocketAPI。如果需要考虑兼容性、心跳、重连等，开发成本会更高。
4. 断线重连：
   - SSE：浏览器原生支持。EventSourceAPI提供了自动断线重连的机制。
   - WebSocketAPI：稍微复杂一些。需要服务器端专门处理WebSocket连接和协议，客户端也需要使用WebSocketAPI。如果需要兼容性、心跳、重连等，开发成本会更高。
5. 数据类型：
   - SSE：主要设计用来传输文本（UTF-8编码）。如果需要处理传输二进制数据，需要先进行Base64等编码转换成文本。
   - WebSocket：原生支持传输文本和二进制数据，无需额外编码。
