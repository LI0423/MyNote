# TCP

## TCP/IP网络模型

网络接口层、网际层、传输层（TCP、UDP）、应用层。

1. 链接层（网络接口层）：负责在以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来标记网络上的设备。
2. 网际层：IP协议就在这一层，可以在链接层的基础上，用IP地址取代MAC地址，把许多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时，只要把IP地址“翻译”成MAC地址就可以了。
3. 传输层：这个层次协议的职责是保证数据在IP地址标记的两点之间“可靠”地传输。
4. 应用层：面向具体应用的协议，例如Telnet、SSH、FTP、MTP、HTTP等。

## 五层网络模型

物理层、数据链路层、网络层、传输层、应用层。

## TCP协议详解

### 为什么要三次握手

主要是初始化Sequence Number的初始值。通信的双方要互相通知自己的初始化的Sequence Number。

### 断开连接为什么要四次挥手

为了确保数据能够完成传输。

关闭连接时，当收到对方的FIN报文通知时，仅仅表示对方没有数据发送了，但未必所有数据都发送给了对方。

### 建立连接SYN超时

连接会处于一个中间状态，既没成功也没失败。server端如果在一定时间内没有收到TCP的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s,2s,4s,8s,16s，总共31s。第五次发出后还需要等32s才知道超时了，因此断开连接需要31+32s，也就是63s。

### SYN Flood攻击

客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户端的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，那些伪造的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

给服务器发送一个连接请求然后就下线了，于是服务器需要等待63s才能断开，攻击者就可以把服务器的syn队列耗尽，让正常的请求无法连接。Linux下给了一个叫tcp_syncookies的参数来应对。当tcp的syn队列满了以后，tcp会通过源地址端口，目标地址端口和时间戳来打造一个特殊的Sequence Number返回去，如果是攻击者就不会有反应，如果是正常的连接就会把这个Syn cookie给返回来，然后服务端可以根据syn cookie建立连接。正常的请求可以调整tcp_synack_retries来减少重试次数，调整tcp_max_syn_backlog增大连接数，调整tcp_abort_on_overflow处理不过来就直接绝。

### 为什么要有TIME_WAIT

1. TIME_WAIT确保有足够的时间让对端收到ACK，如果被动关闭的那方没有收到ACK，就会触发被动端重发FIN，一来一去刚好两个MSL（Maximum Segment Lifetime）；
2. 有足够的时间让这个连接不会跟后面的连接混在一起。（有些路由器会缓存IP数据包，如果连接被重用那么延迟收到的包就可能会跟新连接混在一起）

### TCP重传机制

1. 超时重传机制

    一种是不回ACK，死等丢掉的包，当发送方发现收不到丢包的ACK时，会重传丢掉的包，一旦接收方收到丢的包时，会回ACK。会有比较严重的问题，因为要死等丢掉的包，即使后面的包已经收到了，发送方也完全不知道发生了什么事，因为没有收到ACK，发送方可能会悲观地认为后面的包也丢了，可能导致后面的包重传。

2. 快速重传机制

    TCP引入了一种叫快速重传的算法，不以时间驱动，而是以数据驱动重传。也就是说如果包没有连续到达，就ACK最后那个可能被丢了的包，如果发送方连续收到3次相同的ACK就重传。

3. SACK方法

    在TCP头里加一个SACK的东西，发送端根据回传的SACk判断哪些包到了哪些包没到。发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。

### TCP滑动窗口

- TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。
- 接收端LastByteRead指向TCP缓冲区读到的位置，NextByteExpected指向的是收到的连续包的最后一个位置，LastByteReved指向的是收到的包的最后一个位置。
- 发送端LastByteAcked指向了被接收端ACK过的位置（表示成功发送确认），LastByteSent表示发出去了但还没有收到成功确认的ACK，LastByteWritten指向的是上层应用正在写入的位置。

### TCP如何保证可靠传输

1. 确认应答和序列号

    TCP传输时将每个字节的数据都进行了编号，这就是序列号。tcp按序号发送报文，接收端收到报文后，会给发送端一个ACK确认报文，用来表示已经成功接收到报文，报文中还带有ACK，表示下一次发送端应该从哪里开始发送报文。

2. 超时重传

    如果发送端发送的数据没有收到ACK确认，可能是（1）发送给接收端的报文丢失（2）接收端发送的ACK确认报文丢失了。不管是哪种原因，超过一定时间后，没有收到ACK确认，TCP启动超时重传机制，发送端重新发送数据，如果接收端已经有了该数据，只是由于ACK确认丢失导致超时重传，会将刚刚发送过来的数据包丢弃。超时重传保证报文即使丢失能再传输，直到传输成功为止。

3. 流量控制

    发送端如果发送数据过快，导致接收端的缓冲区很快就满了，如果持续下去，数据溢出缓冲区，就会出现数据丢失。这时需要在发送端有一个窗口，窗口的作用为：在发送缓冲区，只有在窗口里面的数据，才能被发送，在接收缓冲区，只有在窗口里的数据才能被接收，接收端收到数据之后，会回复ack，发送端会根据ack的值来判断接收能力，从而动态调整窗口大小，实现流量控制。

4. 拥塞控制

    如果网络出现拥塞，TCP会根据不同情况，采用不同算法：慢开始，拥塞避免，快重传，快恢复来对窗口大小cwnd和慢开始门限值ssthresh进行调整，从而降低网络拥塞的可能性。

### TCP拥塞控制算法

1. 慢开始

    拥塞窗口初始值cwnd=1，慢开始门限值初始值为ssthresh=16。慢开始过程为：拥塞窗口初始值为1，发送端先发送一个数据包，如果该数据包没有出现超时重传，拥塞窗口就翻倍，变为2，再发送数据包，如果还没有超时重传，那么继续翻倍，直到拥塞窗口的大小变为16，如果再继续翻倍的话，就会超过慢开始门，所以此时慢开始结束，进入拥塞避免阶段。

2. 拥塞阶段

    当发送的包出现了超时重传，那么就是出现了网络拥塞。当cwnd>ssthresh时，采用拥塞避免算法控制。拥塞避免的过程为：cwnd=16，发送一个数据包，没有超时重传，拥塞窗口cwnd+1变为17，依次类推，直到出现了超时重传，说明网络出现了拥塞。拥塞避免算法为：把cwnd设为1，ssthresh设为出现拥塞时的cwnd/2，这样又开始慢传输，当超过ssthresh时又采用拥塞避免控制。

3. 快重传

    如果接收方收不到数据包是因为数据包丢失，而不是网络拥塞，但是把cwnd设为1，ssthresh设为原来cwnd的一半，那网络的传输效率就会很低。所以采用快重传算法，其核心是：如果接收方连续
    三次发送相同的确认包，发送方收到三次确认包后就认为该包丢失，于是重新发送丢失的包。

4. 快恢复

    当发送方连续收到三个重复确认时，把慢开始门限设置为cwnd/2，拥塞窗口的值设为慢开始门减半后的值，然后开始执行拥塞避免算法。
