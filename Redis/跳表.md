# Redis跳表实现有序集合

## Redis中跳表的运用

ZSet有两种不同的实现，分别是ziplist和skiplist，具体使用哪种结构进行存储，有如下规则：

- 当有序集合对象同时满足以下两个条件时，使用ziplist：
  - ZSet保存的键值对数量少于128个；
  - 每个元素的长度小于64个字节。
- 如果不满足上述两个条件，使用skiplist。

## 跳表实现

## 跳表和其他数据结构的比较

### 平衡树vs跳表

平衡树的插入、删除和查询的时间复杂度和跳表一样都是O(logn)。对于范围查询来说，平衡树也可以通过中序遍历的方式达到和跳表一样的效果。但是每一次插入和删除都需要保证整棵树左右节点的绝对平衡，只要不平衡就通过旋转操作来保持平衡，这个过程是比较耗时的。跳表使用概率平衡而不是严格强制的平衡，因此跳表中的插入和删除算法比平衡树的等效查询算法简单得多，速度也快得多。

### 红黑树vs跳表

相比较于红黑树来说，跳表的实现也更简单，不需要通过旋转和染色（红黑变换）来保证黑平衡。并且按照区间来查找数据这个操作，红黑树的效率没有跳表高。

### B+树vs跳表

B+树更适合作为数据库和文件系统中常用的索引结构之一。核心思想是通过尽可能少的IO定位到尽可能多的索引来获得查询数据。对于Redis这种内存数据库来说，不可能存储大量的数据，所以对于索引不需要通过B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。使用跳表实现zset时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中何时的位置再随机维护一定高度的索引即可，也不需要像B+树那样插入时发现失衡时还需要对节点分裂与合并。
