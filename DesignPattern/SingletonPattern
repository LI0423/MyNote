单例模式
    1.定义
        指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
    2.特点
        单例类只有一个实例对象；该单例对象必须由单例类自行创建；单例类对外提供一个访问该单例的全局访问点。
    3.优缺点
    （1）优点：
        单例模式可以保证内存里只有一个实例，减少内存开销。
        可以避免对资源的多重占用。
        设置全局访问点，可以优化和共享访问资源。
    （2）缺点：
        单例模式一般没有接口，扩展困难。如果要扩展，除了修改原来的代码没有第二种途径。
    3.实现
    （1）懒汉式单例
        类加载时没有生成单例，只有当第一次调用getInstance方法时才去创建这个单例。

        public class Singleton{
            private Singleton(){}
            private volatile static Singleton instance;
            public Singleton getInstance(){
                if (instance == null){
                    synchronized(Singleton.class){
                        if (instance == null){
                            instance = new Singleton();
                        }
                    }
                }
                return instance;
            } 
        }

        public class LazySingleton{
            private static volatile LazySingleton instance = null;
            private LazySingleton(){
                //private 避免类在外部被实例化
            }

            public static synchronized LazySingleton getInstance(){
                if (instance == null){
                    instance = new LazySingleton();
                }
                return instance;
            }
        }
    
    （2）饿汉式单例
        类一旦加载就创建一个单例，在调用getInstance之前单例就存在。

        public class HungrySingleton{
            private static volatile HungrySingleton instance = new HungrySingleton ();
            private HungrySingleton(){

            }

            public static HungrySingleton getInstance(){
                return instance
            }
        }

//Python
    class Singleton(object):
        def __new__(cls, *args, **kw):
            if not hasattr(cls, '_instance'):
                orig = super(Singleton, cls)
                cls._instance = orig.__new__(cls, *args, **kw)
            return cls._instance

    class Bus(Singleton):
        lock = threading.RLock()
        def sendData(self, data):
            self.lock.acquire()
            time.sleep(3)
            print 'Sending Singal Data...', data
            self.lock.release()
    
    class VisitEntity(threading.Thread):
        my_bus = ''
        name = ''
        def getName(self):
            return self.name
        def setName(self):
            self.name = name
        def run(self):
            self.my_bus = Bus()
            self.my_bus.sendData(self.name)
        
    if __name__ == '__main__':
        for i in range(3):
            print 'Entity %d begin to run ...' %i
            my_entity = VisitEntity()
            my_entity.setName('Entity_' + str(i))
            my_entity.start()


    class Lazy_property:
        def __init__(self, function):
            self.function = function
            functools.update_wrapper(self, function)
            
        def __get__(self, obj, type_):
            if obj is None:
                return self
            val = self.function(obj)
            obj.__dict__[self.function.__name__] = val
            return val
        
    def lazy_property2(fn):
        attr = '__lazy__' + fn.__name__

        @property
        def _lazy_property(self):
            if not hasattr(self, attr):
                setattr(self, attr, fn(self))
            return getattr(self, attr)
        return _lazy_property

    class Person:
        def __init__(self, name, occupation):
            self.name = name
            self.occupation = occupation
            self.call_count2 = 0

        @lazy_property
        def relatives(self):
            relatives = 'Many relatives.'
            return relatives

        @lazy_property2
        def parents(self):
            self.call_count2 += 1
            return 'father and mother'
        
