# 设计模式

## 设计原则

### SOLID原则

1. 单一职责原则（SRP）

   一个类只完成一个职责或者功能，单一职责原则通过避免设计大而全的类，避免将不相关的类耦合在一起，来提高类的内聚性。不满足类的单一职责原则：
   - 类中的代码行数过多，函数或者属性过多。
   - 类依赖的其他类过多或者依赖类的其他类过多。
   - 私有方法过多。
   - 比较难给类起一个合适的名字。
   - 类中的操作都是集中操作类的几个属性。

2. 开闭原则（OCP）
   - 如何理解“对扩展开放，修改关闭”

        添加一个新的功能，应该是通过在已有代码的基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发；同样的代码改动，在粗代码粒度下，可能被认定为“修改”，在细代码粒度下，可能被认定为“扩展”。
   - 如何做到“对扩展开放，修改关闭”

        花时间思考这段代码未来有哪些需求变更，如何设计代码结构，事先留好扩展点，在未来需求变更的时候，以最小代码改动的情况下，将新代码扩展插入到扩展点上。

3. 里氏替换原则（LSP）
   - 子类对象可以替换成父类对象，并且保证原来程序的逻辑不变及正确性不被破坏。
   - 父类定义了函数的约定，子类可以改变函数的内部实现逻辑，但不能改变函数原有的约定。这里的约定包括，函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中罗列的各种特殊说明。
   - 里氏替换原则和多态的区别：
        - 多态是面向对象编程语言的一种语法，也是面向对象编程的一种语法，是一种代码实现的思路。
        - 里氏替换是一种设计原则，用来指导继承关系中子类如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

4. 接口隔离原则（ISP）
   - 接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。
   - 如果把接口理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分接口使用，而不是强迫其他调用者也依赖这部分接口。
   - 如果把接口理解为单个api接口或函数，部分调用者只需要函数中的部分功能，那就需要将函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度的函数。
   - 如果把接口理解为OOP中的几口，也可以理解为面向对象编程语言中的接口语法，那接口的设计要尽量单一，不要让接口的实现和调用者依赖不需要的接口函数。

5. 依赖倒置原则（DIP）
   - 控制反转：控制指的是对程序流程的控制，而反转指的是在没有使用框架之前，程序流程的执行由程序员控制，使用框架之后，整个程序的执行由框架来控制，程序的控制权由程序员反转给了框架。
   - 依赖注入：不通过new的方式在类内部创建依赖类的对象，而是将依赖的类的对象在外部创建好后，通过构造函数、参数等方式传递（或注入）给类来使用。
   - 依赖注入框架：通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。
   - 依赖反转原则：依赖反转原则也叫作依赖倒置原则。高层模块不依赖低层模块，共同依赖一个抽象类。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。

6. KISS、YAGNI原则
   1. KISS原则：尽量保持简单。

        KISS原则是保持代码可读性和可维护的重要手段。简单不是以代码行数来考量的，代码行数越少并不代表代码越简单，还要考虑逻辑复杂度、实现难度、可读性等。本就复杂的问题用复杂的方法解决也并不违反KISS原则。
   2. YAGNI原则：不要去设计当前用不到的功能，不要去编写当前用不到的代码。核心思想就是，不要过度设计。

7. DRY原则
   - 不要写重复的代码。实现逻辑重复、功能语义重复、代码执行重复。
   - 在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不明确，并且开发可复用代码的成本较高，那就不需要考虑代码的复用性。在之后开发新功能的时候，发现可以复用这段代码那就重构这段代码使其变得可复用。

8. 迪米特法则（Law of Demeter，缩写是 LOD）

    Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.
    不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）
   1. 高内聚、松耦合
      - 高内聚：用来指导类本身的设计，指相近的功能要放到同一个类中，不相近的功能不要放到一个类中。相近的功能往往会被同时修改，放到一个类中，修改会比较集中。
      - 松耦合：用来指导类与类之间依赖关系的设计，类与类之间的依赖关系简单清晰，即使两个类有依赖关系，一个类的代码改动也不会或很少导致依赖类的代码改动。
   2. 如何理解迪米特法则

        不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则希望减少类之间的耦合，类越独立越好。每个类都应该少了解系统的其他部分。

## 规范与重构

### 重构概述

1. 重构的目的：为什么重构（why）

    对于项目而言，重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。

2. 重构的对象：重构什么（what）
   - 对于重构的规模，可以将重构大致划分为大规模高层次的重构和小规模低层次的重构。
   - 大规模高层次的重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。
   - 小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。

3. 重构的时机：什么时候重构（when）

    建立持续重构的意识，把重构作为开发必不可少的部分融入到开发中，而不是等到代码出现很大问题的时候再进行重构。

4. 重构的方法：如何重构（how）
   - 大规模高层次的重构需要有计划、有组织的进行，分阶段的小步快跑，时刻保持代码处于一个可运行的状态。
   - 小规模低层次的重构因为影响范围小，改动耗时短，随时都可以做。

### 单元测试

1. 什么是单元测试？

    单元测试是代码层面的测试，用于测试自己编写代码的逻辑正确性。
2. 为什么要写单元测试？

    单元测试能有效发现代码中的bug、设计上的问题。
3. 如何编写单元测试？

    写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将其翻译成代码的过程。

    对于单元测试，需要建立以下认知：
      - 编写单元测试尽管繁琐，但并不耗时；
      - 稍微放低单元测试的质量要求；
      - 覆盖率作为衡量单元测试好坏的唯一标准是不合理的；
      - 写单元测试一般不需要了解代码的实现逻辑；
      - 单元测试框架无法测试多半是代码的可测试性不好。

### UML图

#### 六种箭头

- 泛化：表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在java中用extends关键字表示。

    表示方式：实线空心箭头，箭头方向是子类指向父类。
- 实现：是一种类与接口的关系，表示类是接口所有特征和行为的实现，在程序中一般通过类实现接口来描述。

    表示方式：虚线空心箭头，箭头方向是实现类指向接口。
- 依赖：是一种使用的关系，即一个类的实现需要另一个类的协助。在java中方法参数需要传入另一个类的对象，就表示依赖这个类。

    表示方式：虚线箭头，类A需要用到类B，类A指向类B。
- 关联：表示类与类之间的联接，使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的。在Java中，一个类的全局变量引用了另一个类，就表示关联了这个类。

    表示方式：实线箭头，类A中用到类B属性，类A指向类B。
- 聚合：聚合是关联关系的一种特例，是强的关联关系。聚合是整体和个体之间的关系，即has-a的关系，整体与个体可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。程序中聚合和关联关系是一致的，只能从语义级别来区分。

    表示方式：尾部为棱形的实线箭头（也可以没有箭头），类A中用到类B属性，类A指向类B。
- 组合：组合也是关联关系的一种特例。组合是一种整体与部分的关系，即contains-a的关系，比聚合更强。部分与整体的生命周期一致，整体的生命周期结束也就意味着部分的生命周期结束，组合关系不能共享。程序中组合和关联关系是一致的，只能从语义级别来区分。

    表示方式：尾部为实心棱形的实线箭头（也可以没有箭头），类A是类B的一部分，类B指向类A。

## 设计模式分类

### 创建型模式

创建型设计模式主要解决“对象的创建”问题。单例模式、工厂模式、建造者模式、原型模式

1. 单例模式

    用来创建全局唯一的对象。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类。
2. 工厂模式

    工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊。

    当每个对象创建逻辑比较简单时，推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。

    当每个对象的创建逻辑都比较复杂的时候，推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。

    作用：
    - 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者不透明。
    - 代码复用：创建代码抽离到独立的工厂类之后可以复用。
    - 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
    - 控制复杂度：将创建代码抽离出来，让原本的函数或类职责单一，代码更简洁。

3. 建造者模式

    建造者模式用来创建复杂对象，可以通过设置不同的可选参数，”定制化”地创建不同对象。

    应用场景：
    - 把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填属性有很多，把必填属性放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果把必填属性通过set()方法设置，那校验必填属性是否填写的逻辑无处安放。
    - 如果类的属性之间有一定的依赖关系或者约束条件，继续使用构造函数配合set()方法的设计思路，那依赖关系或约束条件的校验逻辑无处安放。
    - 如果希望创建不可变对象，就不能在类中暴露set()方法，构造方法配合set()方法设置属性值的方式就不适用了。

4. 原型模式

    如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段相同），在这种情况下，可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。

    原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象...而深拷贝得到的是一份完全独立的对象。深拷贝比浅拷贝更加耗时，耗内存空间。

    浅拷贝共享可变对象就有可能出现数据被修改的风险，除非操作非常耗时，比较推荐使用浅拷贝，否则不要为了一点性能提升而使用浅拷贝。

### 结构型设计模式

结构型设计模式主要解决“类或对象的组合”问题。代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。

1. 代理模式

    代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能。
    代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能与业务功能解耦，放到代理类统一处理。
2. 桥接模式
3. 装饰器模式

    装饰器模式主要解决继承过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。还有个特点是可以对原始类嵌套使用多个装饰器，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者或者接口。
4. 适配器模式

    适配器模式是用来做适配的，将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。有两种实现方式：类适配器和对象适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。

    应用场景：

    - 封装有缺陷的接口设计；
    - 统一多个类的接口设计；
    - 替换依赖的外部系统；
    - 兼容老版本接口；
    - 适配不同格式的数据；
5. 门面模式

    通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。
6. 组合模式

    主要用来处理树形结构数据。将一组对象组织成树形结构，将单个对象和组合对象都看作树中的节点，以统一处理逻辑，并且利用树形结构的特点，递归地处理每个子树，一次简化代码实现。
7. 享元模式

    享元模式意图是复用对象，节省内存，前提是享元对象是不可变对象。当一个系统中存在大量重复对象的时候，就可以利用享元模式，将对象设计成享元，在内存中保留一份实例，供多处代码引用，可以减少内存中对象的数量，以起到节省内存的目的。

### 行为型设计模式

行为型设计模式主要解决“类或对象之间的交互”问题。观察者模式、模版模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

1. 观察者模式

    将观察者和被观察者代码解耦。

    实现方式：
    - 同步阻塞的实现方式，主要是为了代码解耦；
    - 异步非阻塞的实现方式，除了能实现代码解耦外，还能提高代码的执行效率；
    - 进程间的观察者模式解耦更加彻底，一般是基于消息队列来实现，用来实现不同进程间的被观察者和观察者之间的交互。

2. 模版模式

    模版方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

    模版模式有两大作用：复用和扩展。复用指的是所有的子类可以复用父类中提供的模版方法的代码。扩展指的是，框架通过模版模式提供功能扩展点，让框架用户可以在不修改框架源码的情况，基于扩展点定制化框架的功能。

3. 策略模式

    策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。
    最常见的应用场景是，利用它来避免冗长的if-else或switch分支判断。

4. 职责链模式

    在职责链模式中，多个处理器依次处理同一个请求。链条上的每个处理器各自承担各自的处理职责。常用在框架开发中，用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。

5. 迭代器模式

    迭代器模式也叫游标模式，用来遍历集合对象。主要作用是解耦容器代码和遍历代码。
    在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。有两种解决方案，一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。

6. 状态模式

    状态模式一般用来实现状态机。状态机又叫有限状态机，由三个部分组成：状态、事件、动作。事件也叫转移条件，事件触发状态的转移及动作的执行。

    状态机的三种实现方式：
    - 分支逻辑法。利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样的直译成代码。
    - 查表法。对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大提高代码可读性和可维护性。
    - 状态模式。对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。

7. 访问者模式

    访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。

8. 备忘录模式

    备忘录模式也叫快照模式。在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。
    应用场景比较明确和有限，主要用来防丢失、撤销、恢复等。

9. 命令模式

    命令模式用到最核心的实现手段，是将函数封装成对象。
    命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等。

10. 解释器模式

    解释器模式为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法。核心思想是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般做法是将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。

11. 中介模式

    将一组对象之间的交互关系从多对多转换为一对多，最小化对象之间的交互关系，降低代码的复杂度，提高代码的可读性和可维护性。
    观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者之间的区别在于，在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者
