工厂方法模式
    1.定义
        对简单工厂模式的进一步抽象化，可以使系统在不修改原来代码的情况下引进新的产品。
    2.优缺点
    （1）优点：
        用户只需要知道具体工厂的名称就可得到所要的产品，无需知道产品的具体创建过程。
        灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
        典型的解耦框架。
    （2）缺点：
        类的个数容易增多，增加复杂度。
        增加了系统的抽象性和理解难度。
        抽象产品只能生产一种产品。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间一一对应。
    4.实现
    在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，
    这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。

    public class AbstractFactory{
        public static void main(String[] args){
            try{
                Product a;
                AbstractFactory af;
                af = (AbstractFactory) ReadXML1.getObject();
                a = af.newProduct();
                a.show();
            }catch(Exception e){
                System.out.println(e.getMessage());
            }
        }

        //抽象产品
        interface Product{
            public void show();
        }

        //具体产品1:实现抽象产品中的抽象方法
        class ConcreteProduct1 implements Product{
            public void show(){
                System.out.println("具体产品1");
            }
        }

        //具体产品2:实现抽象产品中的抽象方法
        class ConcreteProduct2 implements Product{
            public void show(){
                System.out.println("具体产品2");
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory1 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品1");
                return new ConcreteProduct1;
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory2 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品2");       
                return new ConcreteProduct2;

            }
        }
    }



    public abstract class Factory {
        abstract public Product factoryMethod();
        public void doSomething() {
            Product product = factoryMethod();
        }
    }
    public class ConcreteFactory extends Factory {
        public Product factoryMethod() {
            return new ConcreteProduct1();
        }
    }
    public class ConcreteFactory1 extends Factory {
        public Product factoryMethod() {
            return new ConcreteProduct1();
        }
    }
    public class ConcreteFactory2 extends Factory {
        public Product factoryMethod() {
            return new ConcreteProduct2();
        }
    }

//Python

    class Localizer(Protocol):
        def localize(self, msg:str) -> str:
            pass

    class GreekLocalizer:
        def __init__(self) -> None:
            self.translations = {"dog": "σκύλος", "cat": "γάτα"}

        def localize(self, msg:str) -> str:
            return self.translations.get(msg, msg)

    class EnglishLocalizer:
        def localize(self, msg:str) -> str:
            return msg
        
    def get_localizer(language: str = 'English') -> Localizer:
        localizer: Dict[str, Type[Localizer]] = {
            "English": EnglishLocalizer,
            "Greek": GreekLocalizer,
        }
        return localizer[language]()