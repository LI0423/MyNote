一、JDK动态代理
    使用jdk动态代理模式实现对接口耗时的统计。
    public class CostTimeInvocationHandler implements InvocationHandler{
        private Object target;

        public CostTimeInvocationHandler(Object target){
            this.target = target;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
            long startTime = System.nanoTime();
            Object result - method.invoke(this.target, args);
            long endTime = System.nanoTime();
            System.out.println(this.target.getClass() + "耗时：" + (endTime-startTime));
            return result;
        }

        public static <T> T createProxy(Object target, class<T> targetInterface){
            if(!targetInterface.isInterface()){
                throw new IllegalStateException("targetInterface 必须是接口类型");
            }else if(!targetInterface .isAssignableFrom(target.getClass())){
                throw new IllegalStateException("target 必须是targetInterface接口的实现类");
            }
            return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(),
                            target.getClass().getInterfaces(),new CostTimeInvocationHandler(target));
        }
    }

    public void costTimeProxy(){
        IService serviceA = CostTimeInvocationHandler.createProxy(new ServiceA(),IService.class);
        serviceA.m1();
    }
二、cglib动态代理
    cglib是一个强大、高性能的字节码生成库，用于在运行时扩展Java类和实现接口；本质上是通过动态的生成一个子类去覆盖所要代理的类。
Enhancer可能是CGLIB中最常用的一个类，和jdk中的Proxy不同的是，Enhancer既能够代理普通的class，也能代理接口。Enhancer创建
一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。
    public class Service1 {
        public void m1(){
            System.out.println("我是m1方法");
        }

        public void m2(){
            System.out.println("我是m2方法");
        }
    }

    public class CglibTest{
        public void test1(){
            //1.创建Enhancer对象
            Enhancer enhancer = new Enhancer();
            //2.通过setSuperclass来设置父类型，即需要给哪个类创建代理类
            enhancer.setSuperclass(Service1.class);
            //3.设置回调，需要实现org.springframework.cglib.Callback接口
            enhancer.setCallback(new MethodInterceptor(){
                //代理对象方法拦截器
                @Override
                public void intercept(Object o, Method method,Object[] objects,MethodProxy methodProxy) throws Throwable{
                    System.out.println("调用方法："+method);
                    Object result = methodProxy.invokeSuper(o,objects);
                    return result;
                }
            });
            //4.获取代理对象，调用enhancer.create方法获取代理对象，这个方法返回的是Object类型的，所以需要强转
            Service1 proxy = (Service1) enhancer.create();
            //5.调用代理对象的方法
            proxy.m1();
            proxy.m2();
        }
    }

实现示例：
    @Component
    public class Service1 {
        public void m1(){
            System.out.println(this.getClass() + ".m1()");
        }
    }

    @Component
    public class Service2 {
        public void m2() {
            System.out.println(this.getClass() + ".m2()")
        }
    }

    public class CostTimeProxy implements MethodInterceptor{
        private Object target;

        public CostTimeProxy(Object target){
            this.target = target;
        }

        @Override
        public Object intercept(Object o, Method method, Object[] objects,
        MethodProxy methodProxy)throws Throwable{
            long startTime = System.nanoTime();
            //调用被代理对象（即target）的方法获取结果
            Object result = method.invoke(target,objects);
            long endTime = System.nanoTime();
            System.out.println(method + "，耗时：" + (endTime - startTime));
            return result;
        }

        public static <T> T createProxy(T target){
            CostTimeProxy costTimeProxy = new CostTimeProxy();
            Enhancer enhancer = new Enhancer();
            enhancer.setCallback(costTimeProxy);
            enhancer.setSuperclass(target.getClass());
            return (T) enhancer.create();
        }

    }

    public class MethodCostTimeProxyBeanPostProcessor implements BeanPostProcessor {
        @Nullable
        @Override
        public Object postProcessorAfterInitialization(Object bean,String beanName) throws BeansException {
            if(bean.getClass().getName().toLowerCase().contains("service")){
                return CostTimeProxy.createProxy(bean);
            }else{
                return bean;
            }
        }
    }

    public class MethodCostTimeImportSelector implements ImportSelector {
        @Override
        public String[] selectImports(AnnotationMetadata importingClassMeta){
            return new String[]{MethodCostTimeProxyBeanPostProcessor.class.getName()};
        }
    }

    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Import(MethodCostTimeImportSelector.class)
    public @interface EnableMethodCostTime{
    }

    @ComponentScan
    @EnableMethodCostTime
    public class MainConfig{
    }

    @Test
    public void test(){
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class);
        Service1 service1 = context.getBean(Service1.class);
        Service2 service2 = context.getBean(Service2.class);
        service1.m1();
        service2.m1();
    }