抽象工厂模式
    1.定义
        为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。工厂方法模式只生产一个等级的产品，
        而抽象工厂模式可以生产多个等级的产品。
    2.优缺点
    （1）优点：
        可以在类内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
        当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品族。
        抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码。
    （2）缺点：
        当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，包含了多个创建产品的方法，可以创建多个不同等级的产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间是多对一的关系。
    4.实现
        抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。
        抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。
        而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。
        抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。
        至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。
        从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。

    public class AbstractProductA {
    }

    public class AbstractProductB {
    }

    public class ProductA1 extends AbstractProductA {
    }

    public class ProductA2 extends AbstractProductA {
    }

    public class ProductB1 extends AbstractProductB {
    }

    public class ProductB2 extends AbstractProductB {
    }

    public abstract class AbstractFactory {
        abstract AbstractProductA createProductA();
        abstract AbstractProductB createProductB();
    }

    public class ConcreteFactory1 extends AbstractFactory {
        AbstractProductA createProductA(){
            return new ProductA1();
        }

        AbstractProductB createProductB(){
            return new ProductB1();
        }
    }

    public class ConcreteFactory2 extends AbstractFactory {
        AbstractProductA createProductA(){
            return new ProductA2();
        }

        AbstractProductB createProductB(){
            return new ProductB2();
        }
    }

    public class Client {
        public static void main(String[] args) {
            AbstractFactory abstractFactory = new ConcreteFactory1();
            AbstractProductA productA = abstractFactory.createProductA();
            AbstractProductB productB = abstractFactory.createProductB();
        }
    }

//Python
    class Pet:
        def __init__(self, name:str) -> None
            self.name = name
        def speak(self) -> None:
            raise NotImplementedError
        def __str__(self) -> str:
            raise NotImplementedError

    class Dog(Pet):
        def speak(self) -> None:
            print('woof')
        def __str__(self) -> str:
            return f'Dog<{self.name}>'

    class Cat(Pet):
        def speak(self) -> None:
            print('woof')
        def __str__(self) -> str:
            return f'Cat<{self.name}>'
    
    class PetShop:
        def __init__(self, animal_factory:Type[Pet]) -> None:
            self.pet_factory = animal_factory
        def buy_pet(self, name:str) -> Pet:
            pet = self.pet_factory(name)
            print(f'Here is your lovely {pet}')
            return pet
        