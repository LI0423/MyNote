一、IOC
1.IOC配置的三种方式
（1）XML配置
    将bean的配置信息配置到.xml文件中，通过spring加载文件创建bean。
    <bean id="userService" class="service.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
    </bean>
（2）Java配置
    将类的创建交给JavaConfig类来完成，Spring只负责维护和管理。创建一个配置类，添加@Configuration注解声明为配置类，创建方法并加上@Bean，该方法用于创建实例并返回，
    该实例创建后会交给soring管理。
（3）注解配置
    通过在类上加注解的方式来声明一个类交给Spring管理，spring会自动扫描带有@Component，@Controller，@Service，@Reposity这四个注解的类。

2.依赖注入的三种方式
（1）setter方式
    在XML配置方式中，property都是setter方式注入。本质上是两步，先new UserServiceImpl()创建对象，所以需要默认构造函数，然后调用setUserDao()函数注入userDao的值，
    所以需要setUserDao()函数。
（2）构造函数
    在XML配置方式中，<constructor-arg>是通过构造函数参数注入。
    <bean id="userService" class="service.UserServiceImpl">
        <constructor-arg name="userDao" ref="userDao">
    </bean>
（3）注解注入
    以@Autowired（自动注入）注解为例，修饰符有三个属性：Constructor，byType，byName，默认是byType。
    constructor：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到
    多个匹配多参数构造方法的bean，Spring就会优先将bean注入到多参数的构造方法中。
    byName：被注入的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写。
    byType：查找所有的set方法，将符合参数类型的bean注入。

2.SpringBean的生命周期
    Spring启动，查找并加载需要被Spring管理的Bean，进行Bean的实例化；
    Bean实例化后对将Bean的引入和值注入到Bean的属性中；
    如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法；
    如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；
    如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将Bean所在应用上下文传入进来；
    如果Bean实现了BeanPostProcesser接口，Spring将调用postProcessBeforeInitialization()方法；
    如果Bean实现了InitializingBean接口，Spring将调用他们的afterPropertiSet()方法；
    如果Bean实现了BeanPostProcessor接口，Spring将调用它的postProcessAfterInitialization()方法；
    此时，Bean已经准备就绪，可以被应用程序使用了，将一直驻留在应用上下文中，直到应用上下文被销毁；
    如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destroy-method声明销毁方法，该方法也会被调用。
    
二、AOP
1.相关术语
    连接点（JoinPoint）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点。
    切入点（PointCut）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring默认使用AspectJ语法。
    通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（Before Advice）、后置通知（After Advice）、
        环绕通知（Around）、异常通知（After-throwing）、返回通知（After-returning），在spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知。
    切面（Aspect）：横切关注点的模块化，可以认为是通知、引入和切入点的组合，在spring中可以使用Schema和@AspectJ方式进行组织实现。
    引入（inter-type）：也称内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口到所有被代理对象。
    目标对象（Target Object）：需要被织入横切关注点的对象，，由于spring AOP通过代理模式实现，而这个对象永远是被代理对象。
    织入（Weaving）：把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象。可以在编译时，类加载时和运行时完成。spring在运行时完成织入。
    AOP代理（AOP Proxy）：AOP框架使用代理模式创建对象，从而实现在连接点处插入通知，在spring中AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。

2.AOP配置方式
（1）XML Schema配置方式
（2）AspectJ注解方式

3.@Transaction实现原理
    通过aop的方式进行管理，实现事务开启、提交或者回滚操作。

4.@Pointcut的12种用法
（1）execution
    格式：execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
    带‘?’的是可选项，ret-type-pattern,name-pattern,parameters-pattern是必选项。
    modifer-pattern? 修饰符匹配，public表示匹配公有方法；
    ret-type-pattern 返回值匹配，*表示任何返回值，全路径的类名等；
    declaring-type-pattern? 类路径匹配；
    name-pattern 方法名匹配，*代表所有，set* 代表所有以set开头的方法；
    (param-pattern) 参数匹配，指定方法参数（声明的类型），(..)代表所有参数，(*,String)代表第一个参数为任何值，第二个参数为String类型，
(..,String)代表最后一个参数是String类型；
    throws-pattern? 异常类型匹配

    ‘*’：匹配任何数量字符；
    ‘..’：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包，在方法参数模式中匹配任何数量参数
    ‘+’：匹配指定类型及其子类型，仅能作为后缀放在类型模式后边
（2）within
    格式：within(类型表达式),目标对象target的类型是否和within中指定的类型匹配
    within(com.test..*) test包以及子包下的任何方法执行。
    within(com.test..Service+) test包或所有子包下Service类型及子类型的任何方法。
    within(com.test.service.Service1) Service1中定义的所有方法，不包含其子类中的方法。
（3）this
    格式：this(类型全限定名)，通过aop创建的代理对象的类型是否和this中指定的类型匹配；判断的目标是代理对象；this中使用的表达式必须是类型全限定名，
    不支持通配符。
（4）target
    格式：target(类型全限定名)，判断目标对象的类型是否和指定类型匹配；判断的是目标对象的类型；表达式必须是类型全限定名，不支持通配符。
（5）args
    格式：args(参数类型列表)，匹配当前执行的方法传入的参数是否为args中指定的类型；匹配传入的参数类型，不是匹配方法签名的参数类型；
    参数类型列表中的参数必须是类型全限定名，不支持通配符；args属于动态切入点，也就是执行方法的时候进行判断，开销大，非特殊情况不要使用。
    args(String)匹配只有一个参数且传入的参数类型是String类型的方法。
    args(*,String)匹配只有2个参数的且第2个参数是String的方法。
    args(..,String)匹配最后1个参数是String的方法。
（6）@within
    格式：@within(注解类型)，匹配指定的注解内定义的方法。
    调用目标方法的时候，通过Java中Method.getDeclaringClass()获取当前的方法是哪个类中定义的，然后看这个类上是否有指定的注解。
    目标对象上有@within中指定的注解，这种情况下目标对象的所有方法都会被拦截。
    定义注解时未使用@Inherited说明子类无法继承父类上的注解。
（7）@target
    格式：@target(注解类型)，判断目标对象target类型上是否有指定的注解，@target中注解类型也必须是全限定类型名。
    注解直接标注在目标类上；注解标注在父类上，注解上没有@Inherited这种情况下目标类无法匹配到。
（8）@args
    格式：@args(注解类型)：方法参数所属的类上有指定的注解；不是参数上有指定的注解而是参数类型的类上有指定的注解。
（9）@annotation
    格式：@annotation(注解类型)：匹配被调用的方法上有指定的注解。
（10）@bean
    格式：bean(bean名称)，用在spring环境中，匹配容器中指定名称的bean。
（11）reference pointcut
    表示引用其他命名切入点。可以将切入专门放在一个类中集中定义，其他地方可以通过引用的方式引入其他类中定义的切入点。
    
    public class AspectPcDefine {
        @Pointcut("bean(bean1)")
        public void pc1(){
        }

        @Pointcut("bean(bean2)")
        public void pc2(){
        }
    }

    @Aspect
    public class AspectTest{
        @Pointcut("com.test.AspectPcDefine.pc1()")
        public void pointcut1(){
        }
    }
（12）组合型的pointcut
    &&：多个匹配都需要满足
    ||：多个匹配中只需满足一个
    ！：匹配不满足的情况下
    @Pointcut("bean(bean1) || bean(bean2)") //匹配bean1或者bean2
    @Pointcut("@target(Ann1) && @target(Ann2)") //匹配目标类上有Ann1注解以及Ann2注解
    @Pointcut("@target(Ann1) && !@target(Ann2)") //匹配目标类上有Ann1注解但是没有Ann2注解

5.@Aspect中的5种通知
（1）@Before：前置通知，在方法执行之前执行
    被@Before标注的方法参数可以为空，或者为JoinPoint类型，当为JoinPoint类型时，必须为第一个参数。
    通知中获取被调用方法信息：
        非环绕通知，可以将org.aspectj.lang.JoinPoint作为通知方法的第一个参数，通过该参数获取被调用方法的信息。
        环绕通知，将org.aspectj.lang.ProceedingJoinPoint作为方法的第一个参数，通过该参数获取信息。
（2）@Around：环绕通知
（3）@Afte：后置通知
    不管目标方法是否有异常，后置通知都会执行。
（4）@AfterReturning：返回通知
    可以获取到方法的返回值，当目标方法返回异常的时候，这个方法不会被调用。
    该注解用到了两个参数：
        value：用来指定切入点
        returning：用来指定返回值对应方法的参数名称，返回值对应方法的第二个参数。
（5）@AfterThrowing：异常通知
    被标注的方法可以指定异常的类型，当被调用的方法触发该异常及其子类型的异常之后，会触发异常的回调，
    也可以不指定异常类型，此时会匹配所有异常。
    


4.综合示例
    public class Service1{
        public void m1(){
            System.out.println("m1方法");
        }

        public void m2(){
            System.out.println("m2方法");
        }
    }

    //这个类使用@Aspect进行标注
    @Aspect
    public class Aspect1{

        //定义一个切点，可以匹配Service1中所有方法
        @Pointcut("execution(*com.test.service.Service1.*(..))")
        public void pointcut(){
        }

        //定义一个前置通知，这个通知对上面定义的切入点中的所有方法奏效
        @Before(value="pointcut()")
        public void before(JoinPoint joinPoint){
            System.out.println("前置通知");
        }

        //定义了一个异常通知，这个通知对上面定义的切点所有方法奏效
        @AfterThrowing(value="pointcut()",throwing="e")
        public void after(JoinPoint joinPoint,Exception e){
            System.out.println("异常通知"+e.getMessage());
        }
    }

    public class Test{
        @Test
        public void test(){
            try{
                Service1 target = new Service1();
                AspectJProxyFactory proxyFactory = new AspectJProxyFactory();
                proxyFactory.setTarget(target);
                proxyFactory.addAspect(Aspect1.class);
                Service1 proxy = proxyFactory.getProxy();
                proxy.m1();
            }catch(Exception e){
            }
        }
    }

三、注解使用
1.自定义注解

    public @interface MyAnnotation {
        [public] 参数类型 参数名称() [default 参数默认值];
    }
    注解有没有参数都可以。
    访问修饰符必须为public，不写默认为public。
    参数的类型只能是基本数据类型、String、Class、枚举类型、注解类型、注解类型以及数组。
    参数名称一般定义为名词，如果注解只有一个元素，名字定义为value会使用更便利。
    参数名称后面的括号只是特殊语法。

（1）指定注解的使用范围：@Target
    @Target(value={ElementType.TYPE,ElementType.METHOD})

    TYPE：类、接口、枚举、注解上面
    FIELD：字段上
    METHOD：方法上
    PARAMETER：方法的参数上
    CONSTRUCTOR：构造函数上
    LOCAL_VARIABLE：本地变量上
    ANNOTATION_TYPE：注解上
    PACKAGE：包上
    TYPE_PARAMETER：类型参数上
    TYPE：类型名称上

（2）指定注解的保留策略：@Retention
    @Retention(RetentionPolicy.SOURCE)

    SOURCE：注解只保留在源码中，编译为字节码之后就丢失了，也就是class文件中就不存在了。
    CLASS：注解只保留在源码和字节码中，运行阶段会丢失。
    RUNTIME：源码、字节码、运行期间都存在。

（3）综合示例：
    @Target(value={
        ElementType.TYPE,
        ElementType.METHOD,
        ElementType.FIELD,
        ElementType.PARAMETER,
        ElementType.CONSTRUCTOR,
        ElementType.LOCAL_VARIABLE
    })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Ann {
        String value();

        ElementType elementType();
    }

    @Ann(value="用在类上",elementType = ElementType.TYPE)
    public class UseAnn {
        @Ann(value="用在属性上",elementType = ElementType.FIELD)
        private String a;

        @Ann(value="用在构造方法上",elementType = ElementType.CONSTRUCTOR)
        public UseAnn(@Ann(value = "用在参数上",elementType = ElementType.PARAMETER)String a){
            this.a = a;
        }

        @Ann(value="用在普通方法上",elementType = ElementType.METHOD)
        public void method(){
            @Ann(value="用在本地变量上",elementType = ElementType.LOCAL_VARIABLE)
            String arg;
        }
    }

2.@Configuration 和 @Bean
（1）@Configuration
    加在类上让这个类的功能等同于一个bean.xml配置文件
（2）@Bean
    用在方法上表示通过方法来定义一个bean，默认将方法名称作为bean名称，将方法返回值作为bean对象，注册到spring容器中。
（3）@Configuration加不加的区别
    有没有@Configuration注解，@Bean都会生效，都会将修饰的方法作为bean注册到容器中。
    被@Configuration修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被@Bean修饰的方法，默认情况下
保证这些方法只被调用一次，确保是单例的。

3.@ComponentScan 和 @ComponentScans
（1）@ComponentScan
    会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器中。
    通过value、basePackages、basePackageClasses这3个参数来扫描指定的包，并且会递归下面子包，得到一批类的数组。
    通过useDefaultFilters、includeFilters、excludeFilters来控制过滤器，剩下的类会被注册到容器中。
    指定包名的方式配置扫描范围存在的隐患，包名被重命名之后会导致扫描失效，所以我们在需要扫描的包中可以创建一个标记的接口或者类，
作为basePackageClasses的值，通过这个来控制包的扫描范围。
