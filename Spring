一、IOC
1.IOC配置的三种方式
（1）XML配置
    将bean的配置信息配置到.xml文件中，通过spring加载文件创建bean。
    <bean id="userService" class="service.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
    </bean>
（2）Java配置
    将类的创建交给JavaConfig类来完成，Spring只负责维护和管理。创建一个配置类，添加@Configuration注解声明为配置类，创建方法并加上@Bean，该方法用于创建实例并返回，
    该实例创建后会交给soring管理。
（3）注解配置
    通过在类上加注解的方式来声明一个类交给Spring管理，spring会自动扫描带有@Component，@Controller，@Service，@Reposity这四个注解的类。

2.依赖注入的三种方式
（1）setter方式
    在XML配置方式中，property都是setter方式注入。本质上是两步，先new UserServiceImpl()创建对象，所以需要默认构造函数，然后调用setUserDao()函数注入userDao的值，
    所以需要setUserDao()函数。
（2）构造函数
    在XML配置方式中，<constructor-arg>是通过构造函数参数注入。
    <bean id="userService" class="service.UserServiceImpl">
        <constructor-arg name="userDao" ref="userDao">
    </bean>
（3）注解注入
    以@Autowired（自动注入）注解为例，修饰符有三个属性：Constructor，byType，byName，默认是byType。
    constructor：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到
    多个匹配多参数构造方法的bean，Spring就会优先将bean注入到多参数的构造方法中。
    byName：被注入的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写。
    byType：查找所有的set方法，将符合参数类型的bean注入。

2.SpringBean的生命周期
    Spring启动，查找并加载需要被Spring管理的Bean，进行Bean的实例化；
    Bean实例化后对将Bean的引入和值注入到Bean的属性中；
    如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法；
    如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；
    如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将Bean所在应用上下文传入进来；
    如果Bean实现了BeanPostProcesser接口，Spring将调用postProcessBeforeInitialization()方法；
    如果Bean实现了InitializingBean接口，Spring将调用他们的afterPropertiSet()方法；
    如果Bean实现了BeanPostProcessor接口，Spring将调用它的postProcessAfterInitialization()方法；
    此时，Bean已经准备就绪，可以被应用程序使用了，将一直驻留在应用上下文中，直到应用上下文被销毁；
    如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destroy-method声明销毁方法，该方法也会被调用。
    
二、AOP
1.相关术语
    连接点（JoinPoint）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点。
    切入点（PointCut）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring默认使用AspectJ语法。
    通知（Advice）：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（Before Advice）、后置通知（After Advice）、
        环绕通知（Around）、异常通知（After-throwing）、返回通知（After-returning），在spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知。
    切面（Aspect）：横切关注点的模块化，可以认为是通知、引入和切入点的组合，在spring中可以使用Schema和@AspectJ方式进行组织实现。
    引入（inter-type）：也称内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口到所有被代理对象。
    目标对象（Target Object）：需要被织入横切关注点的对象，，由于spring AOP通过代理模式实现，而这个对象永远是被代理对象。
    织入（Weaving）：把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象。可以在编译时，类加载时和运行时完成。spring在运行时完成织入。
    AOP代理（AOP Proxy）：AOP框架使用代理模式创建对象，从而实现在连接点处插入通知，在spring中AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。

2.AOP配置方式
（1）XML Schema配置方式
（2）AspectJ注解方式

3.@Transaction实现原理
    通过aop的方式进行管理，实现事务开启、提交或者回滚操作。

三、注解使用
1.自定义定义注解

    public @interface MyAnnotation {
        [public] 参数类型 参数名称() [default 参数默认值];
    }
    注解有没有参数都可以。
    访问修饰符必须为public，不写默认为public。
    参数的类型只能是基本数据类型、String、Class、枚举类型、注解类型、注解类型以及数组。
    参数名称一般定义为名词，如果注解只有一个元素，名字定义为value会使用更便利。
    参数名称后面的括号只是特殊语法。

（1）指定注解的使用范围：@Target
    @Target(value={ElementType.TYPE,ElementType.METHOD})

    TYPE：类、接口、枚举、注解上面
    FIELD：字段上
    METHOD：方法上
    PARAMETER：方法的参数上
    CONSTRUCTOR：构造函数上
    LOCAL_VARIABLE：本地变量上
    ANNOTATION_TYPE：注解上
    PACKAGE：包上
    TYPE_PARAMETER：类型参数上
    TYPE：类型名称上

（2）指定注解的保留策略：@Retention
    @Retention(RetentionPolicy.SOURCE)

    SOURCE：注解只保留在源码中，编译为字节码之后就丢失了，也就是class文件中就不存在了。
    CLASS：注解只保留在源码和字节码中，运行阶段会丢失。
    RUNTIME：源码、字节码、运行期间都存在。

（3）综合示例：
    @Target(value={
        ElementType.TYPE,
        ElementType.METHOD,
        ElementType.FIELD,
        ElementType.PARAMETER,
        ElementType.CONSTRUCTOR,
        ElementType.LOCAL_VARIABLE
    })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Ann {
        String value();

        ElementType elementType();
    }

    @Ann(value="用在类上",elementType = ElementType.TYPE)
    public class UseAnn {
        @Ann(value="用在属性上",elementType = ElementType.FIELD)
        private String a;

        @Ann(value="用在构造方法上",elementType = ElementType.CONSTRUCTOR)
        public UseAnn(@Ann(value = "用在参数上",elementType = ElementType.PARAMETER)String a){
            this.a = a;
        }

        @Ann(value="用在普通方法上",elementType = ElementType.METHOD)
        public void method(){
            @Ann(value="用在本地变量上",elementType = ElementType.LOCAL_VARIABLE)
            String arg;
        }
    }

2.@Configuration 和 @Bean
（1）@Configuration
    加在类上让这个类的功能等同于一个bean.xml配置文件
（2）@Bean
    用在方法上表示通过方法来定义一个bean，默认将方法名称作为bean名称，将方法返回值作为bean对象，注册到spring容器中。
（3）@Configuration加不加的区别
    有没有@Configuration注解，@Bean都会生效，都会将修饰的方法作为bean注册到容器中。
    被@Configuration修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被@Bean修饰的方法，默认情况下
保证这些方法只被调用一次，确保是单例的。

3.@ComponentScan 和 @ComponentScans
（1）@ComponentScan
    会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器中。
    通过value、basePackages、basePackageClasses这3个参数来扫描指定的包，并且会递归下面子包，得到一批类的数组。
    通过useDefaultFilters、includeFilters、excludeFilters来控制过滤器，剩下的类会被注册到容器中。
    指定包名的方式配置扫描范围存在的隐患，包名被重命名之后会导致扫描失效，所以我们在需要扫描的包中可以创建一个标记的接口或者类，
作为basePackageClasses的值，通过这个来控制包的扫描范围。
