
主从同步一致性问题
1、异步复制
    mysql默认的复制即是异步复制，主库在执行完客户端提交的事务后会立即将结果返给客户端，并不关心从库是否已经接收并处理，主如果crash掉了，
    此时主已经提交的事务可能没有传到从库上，如果此时强行将从提升为主，可能导致新主的数据不完整。
        主库将事务binlog事件写入到binlog文件中，此时主库只会通知一下dump线程，发送这些新的binlog，然后主库就会继续处理提交操作，而
        此时不会保证这些binlog传到任何一个从库节点上。
2、全同步复制
    当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会受到
    严重的影响。
        当主库提交事务后，所有的从库节点必须收到、apply并且提交这些事务，然后主库线程才能继续做后续操作。缺点是主库完成一个事务的时间会
        被拉长，性能降低。
3、半同步复制
    是介于同步复制与全异步复制之间的一种，主库只需要等待至少一个从库节点收到并且flush binlog到relay log文件即可，主库不需要等待所有从库
    给主库反馈，同时，这里只是一个收到的反馈，而不是已经完全完成并且提交的反馈。
        主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半
        同步复制提高了数据的安全性，同时也造成了一定程度的延迟，这个延迟最少是一个tcp/ip往返的时间，所以，半同步复制最好在低延时的网络中使用。
    事实上，半同步复制并不是严格意义上的半同步复制，mysql半同步复制架构中，主库在等待备库ack的时候，如果超时会退化为异步，也可能导致数据不一致。
        当半同步复制发生超时（由rpl_semi_sync_master_timeout参数控制，单位是毫秒，默认为10000，即10s），会暂时关闭半同步复制，转而使用
        异步复制。当master dump线程发送完一个事务的所有事件后，如果在rpl_semi_sync_master_timeout内收到了从库的响应，则主从又重新恢复为
        半同步复制。

    潜在问题：客户端事务在存储引擎提交后，在得到从库确认的过程中，主库宕机了，可能有两种情况发生。
        事务还没发送到从库上
            此时客户端会收到事务提交失败的信息，客户端会重新提交该事务到新的主上，当宕机的主库重新启动后，以从库的身份重新加入到主从结构中，该事务
            在从库中就被提交了两次，一次是之前作为主的时候，一次是被新主同步过来的。
        事务已经发送到从库上
            从库已经收到并应用了事务，但是客户端仍然会收到事务提交失败的信息，重新提交该事务到新的主上。
        
半同步复制安装部署
    加载插件
        master：install plugin rpl_semi_sync_master soname 'semisync_master.so';
        slave：install plugin rpl_semi_sync_slave soname 'semisync_slave.so';
    查看是否加载成功
        show plugins;
        select plugin_name, plugin_status from information_schema.plugins where plugin_name like '%semi%';
    启动半同步复制
        set global rpl_semi_sync_master_enabled = 1;
        set global rpl_semi_sync_slave_enabled = 1;
    重启从上的io线程
        stop slave io_thread;
        start slave io_thread;
    查看半同步是否在运行
        show status like 'Rpl_semi_sync_master_status';
        show status like 'Rpl_semi_sync_slave_status';