1、MVCC的产生背景
    MVCC是为了实现读-写冲突不加锁，读指的是快照读而不是当前读，当前读是一种加锁的操作，是悲观锁的实现。
    读-读：不存在任何问题，也不需要并发控制。
    读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复度。
    写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失（回滚丢失），第二类更新丢失（覆盖丢失）。
            回滚丢失：A事务撤销时，把已经提交的B事务的更新数据覆盖了。
            覆盖丢失：A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。
2、什么是MVCC
    多版本并发控制，是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MVCC在InnoDB中的实现主要是为了提高
    数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。
    MVCC只在RC和RR两个隔离级别下工作，其他两个隔离级别和MVCC不兼容，因为RU总是读取最新的数据行，而不是符合当前事务版本的数据行，而SERIALIZABLE则会对所有读取的行都加锁。

3、当前读和并发读
（1）当前读
    当前读就是像select lock in share mode(共享锁)，select * from db for update；update，insert，delete（排他锁），读取的是记录的最新版本，读取时还要
    保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
（2）快照读
    快照读就是像不加锁的select操作就是快照读，即不加锁的非阻塞读，快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；快照读的实现是
    基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，那可能读到的不一定是最新的
    版本，有可能是之前的历史版本。

4、MVCC的实现原理
    主要是依赖记录中的3个隐式字段，undo log，Read View来实现的。
（1）隐式字段
    DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引。 
    DB_TRX_ID 6byte，最近修改（修改/插入）事务ID：记录创建这条记录/最后一次修改该记录的事务ID，每处理一个事务其值自动+1。
    DB_ROLL_PTR 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）。配合undo日志，指向上一个版本。
    DELETE_BIT 1byte，记录被更新或删除并不代表真的删除，而是删除flag变了。
（2）undo log
    主要用于记录数据被修改之前的日志，在表信息修改之前会先把数据拷贝到undo log里，当事务进行回滚时可以通过undo log里的日志进行还原。
    InnoDB把这些为了回滚而记录的这些东西称之为undo log。这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作时，不会记录
    用户相应的日志。undo log主要记录的是数据的逻辑变化，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，
    当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

    Insert undo log：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键对应的记录删掉就好。
    Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
    Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，之后回滚时再把由这些内容组成的记录插入到表中。
        删除操作都只是设置一下老记录的DELETE_BIT，并不真正将过时的记录删除。
        InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己维护了一个read view（这个read view相当于
        系统中最老活跃事务的read view）；如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以
        被安全清除的。
    不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的首链就是最新的旧记录，链尾就是最早的旧记录。
（3）Read View（读视图）
        主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。这个ReadView 
    中有个 id 列表 trx_ids 来存储系统中当前活跃着的读写事务，也就是 begin 了还未 commit 或 rollback 的事务。
        RC每次查询数据前都生成一个ReadView。RR在第一次查询数据时生成一个ReadView，之后的读都复用之前的。
        readview主要是用来做可见性判断的，即当我们某个事务执行快照读的时候，对该记录创建一个readview读视图，把它比作条件用来判断当前事务能够看到哪个版本的
    数据，既可能是当前最新的数据，也可能是该行记录的undo log里面的某个版本的数据。
        readview遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由read view维护），
    如果DB_TRX_ID跟readview的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出undo log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID，
    直到找到满足特定条件的DB_TRX_ID，这个所在的旧记录就是当前事务能看见的最新老版本。

5、基于ReadView实现可重复读
    事务A第一次读完，事务B要修改这行数据，undolog会为所有写操作生成日志，所以就会生成一条undo log日志，roll_pointer会指向上一条undo log日志。第一次读
    的时候，开启事务A的时候就生成一个ReadView，当事务A第二次去读这条数据时，先查到的是事务B修改的那条数据，会发现现在的 DB_TRX_ID 比最小的事务ID大，有
    可能是读不到的，回去当前活跃事务列表查询是否有这条事务记录，如果有那说明在事务A开启事务的时候，这个事务是没有提交的，修改的数据就不应该被读到，顺着回滚
    指针往下找，找到之前的一条记录，发现可以读到，数值与第一次结果一致。