一、全局网络层次
1.七层网络模型
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
（1）物理层：数据的单位是bit。
（2）数据链路层：在物理层提供比特流服务的基础上建立相邻节点之间的数据链路，该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
    数据的单位称为帧。
（3）网络层：选择合适的网间路由和交换节点，确保数据及时传送。单位称为数据包。
（4）传输层：为上层提供端到端的透明的、可靠的数据传输服务。TCP的数据单元称为段，而UDP的数据单元称为数据报。
（5）会话层：提供包括访问验证和会话管理在哪的建和和维护应用之间通信的机制。
（6）表示层：解决用户信息的语法表示问题，提供格式化的表示和转换数据服务，数据的压缩和解压缩，加密和解密等。
（7）应用层：为操作系统或网络应用程序提供访问网络服务的接口。Telnet、FTP、HTTP等。

2.TCP/IP网络模型
    网络接口层、网际层、传输层（TCP、UDP）、应用层。

3.五层网络模型
    物理层、数据链路层、网络层、传输层、应用层。

二、TCP协议详解
1、为什么要三次握手
    主要是初始化Sequence Number的初始值。通信的双方要互相通知自己的初始化的Sequence Number。

2、断开连接为什么要四次挥手

3、建立连接SYN超时
    连接会处于一个中间状态，既没成功也没失败。server端如果在一定时间内没有收到TCP的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试
    时间间隔为1s,2s,4s,8s,16s，总共31s。第五次发出后还需要等32s才知道超时了，因此断开连接需要31+32s，也就是63s。

4、SYN Flood攻击
    给服务器发送一个连接请求然后就下线了，于是服务器需要等待63s才能断开，攻击者就可以把服务器的syn队列耗尽，让正常的请求无法连接。Linux下给了一个叫tcp_syncookies的参数来应对。
    当tcp的syn队列满了以后，tcp会通过源地址端口，目标地址端口和时间戳来打造一个特殊的Sequence Number返回去，如果是攻击者就不会有反应，如果是正常的连接就会把这个Syn cookie给
    返回来，然后服务端可以根据syn cookie建立连接。正常的请求可以调整tcp_synack_retries来减少重试次数，调整tcp_max_syn_backlog增大连接数，调整tcp_abort_on_overflow处理
    不过来就直接拒绝。

5、为什么要有TIME_WAIT
（1）TIME_WAIT确保有足够的时间让对端收到ACK，如果被动关闭的那方没有收到ACK，就会触发被动端重发FIN，一来一去刚好两个MSL（Maximum Segment Lifetime）；
（2）有足够的时间让这个连接不会跟后面的连接混在一起。（有些路由器会缓存IP数据包，如果连接被重用那么延迟收到的包就可能会跟新连接混在一起）

6、TCP重传机制
（1）超时重传机制
    一种是不回ACK，死等丢掉的包，当发送方发现收不到丢包的ACK时，会重传丢掉的包，一旦接收方收到丢的包时，会回ACK。会有比较严重的问题，因为要死等丢掉的包，即使后面的包已经收到了，
    发送方也完全不知道发生了什么事，因为没有收到ACK，发送方可能会悲观地认为后面的包也丢了，可能导致后面的包重传。
（2）快速重传机制
    TCP引入了一种叫快速重传的算法，不以时间驱动，而是以数据驱动重传。也就是说如果包没有连续到达，就ACK最后那个可能被丢了的包，如果发送方连续收到3次相同的ACK就重传。
（3）SACK方法
    在TCP头里加一个SACK的东西，发送端根据回传的SACk判断哪些包到了哪些包没到。发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK
    的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。

7.TCP滑动窗口
    TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端可以根据这个接收端的处理能力来发送数据，而不会导致
    接收端处理不过来。
    接收端LastByteRead指向TCP缓冲区读到的位置，NextByteExpected指向的是收到的连续包的最后一个位置，LastByteReved指向的是收到的包的最后一个位置。
    发送端LastByteAcked指向了被接收端ACK过的位置（表示成功发送确认），LastByteSent表示发出去了但还没有收到成功确认的ACK，LastByteWritten指向的是上层应用正在写入的位置。

8.TCP如何保证可靠传输
（1）确认应答和序列号
    TCP传输时将每个字节的数据都进行了编号，这就是序列号。tcp按序号发送报文，接收端收到报文后，会给发送端一个ACK确认报文，用来表示已经成功接收到报文，报文中还带有ACK，表示下一次
    发送端应该从哪里开始发送报文。
（2）超时重传
    如果发送端发送的数据没有收到ACK确认，可能是（1）发送给接收端的报文丢失（2）接收端发送的ACK确认报文丢失了。不管是哪种原因，超过一定时间后，没有收到ACK确认，TCP启动超时重传
    机制，发送端重新发送数据，如果接收端已经有了该数据，只是由于ACK确认丢失导致超时重传，会将刚刚发送过来的数据包丢弃。超时重传保证报文即使丢失能再传输，直到传输成功为止。
（3）流量控制
    发送端如果发送数据过快，导致接收端的缓冲区很快就满了，如果持续下去，数据溢出缓冲区，就会出现数据丢失。这时需要在发送端有一个窗口，窗口的作用为：在发送缓冲区，只有在窗口里面
    的数据，才能被发送，在接收缓冲区，只有在窗口里的数据才能被接收，接收端收到数据之后，会回复ack，发送端会根据ack的值来判断接收能力，从而动态调整窗口大小，实现流量控制。
（4）拥塞控制
    如果网络出现拥塞，TCP会根据不同情况，采用不同算法：慢开始，拥塞避免，快重传，快恢复来对窗口大小cwnd和慢开始门限值ssthresh进行调整，从而降低网络拥塞的可能性。

9.TCP拥塞控制算法
（1）慢开始
    拥塞窗口初始值cwnd=1，慢开始门限值初始值为ssthresh=16。慢开始过程为：拥塞窗口初始值为1，发送端先发送一个数据包，如果该数据包没有出现超时重传，拥塞窗口就翻倍，
    变为2，再发送数据包，如果还没有超时重传，那么继续翻倍，直到拥塞窗口的大小变为16，如果再继续翻倍的话，就会超过慢开始门，所以此时慢开始结束，进入拥塞避免阶段。
（2）拥塞阶段
    当发送的包出现了超时重传，那么就是出现了网络拥塞。当cwnd>ssthresh时，采用拥塞避免算法控制。拥塞避免的过程为：cwnd=16，发送一个数据包，没有超时重传，拥塞窗口cwnd+1变为17，
    依次类推，直到出现了超时重传，说明网络出现了拥塞。拥塞避免算法为：把cwnd设为1，ssthresh设为出现拥塞时的cwnd/2，这样又开始慢传输，当超过ssthresh时又采用拥塞避免控制。
（3）快重传
    如果接收方收不到数据包是因为数据包丢失，而不是网络拥塞，但是把cwnd设为1，ssthresh设为原来cwnd的一半，那网络的传输效率就会很低。所以采用快重传算法，其核心是：如果接收方连续
    三次发送相同的确认包，发送方收到三次确认包后就认为该包丢失，于是重新发送丢失的包。
（4）快恢复
    当发送方连续收到三个重复确认时，把慢开始门限设置为cwnd/2，拥塞窗口的值设为慢开始门减半后的值，然后开始执行拥塞避免算法。

三、UDP协议
1、UDP特点
    UDP无连接，时间上不存在连接需要的延迟，空间上TCP需要在端系统中维护连接状态。
    分组首部开销小，TCP首部20字节，UDP首部8字节。
    UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。
    UDP提供最大努力交付，不保证可靠交付。
    UDP面向报文，对应用层交下来的报文，添加首部后直接向下交付给IP层，既不合并也不拆分。
    UDP常用一次性传输比较少量数据的网络应用。
    UDP支持一对一、一对多、多对一和多对多的交互通信。

四、HTTP协议
1、HTTP方法

2、cookie
    cookie是服务器发送到用户浏览器并保存在本地的一小块数据，会在浏览器之后向同一服务器再次发起请求时被鞋带上，用于告知服务器两个请求是否来自同一浏览器。

3、Session
    Session可以将用户信息存储在服务器端。
    Session维护用户登陆状态的过程：
        用户进行登录时，用户提交包含用户名和密码的表单，放入HTTP请求报文中。
        服务器验证该用户名和密码。
        如果正确则把用户信息保存到Redis中，在Redis中的key称为SessionID。
        服务器返回的响应报文的Set-Cookie首部字段包含了这个这个SessionID，客户端收到响应报文之后将该Cookie值存到浏览器中。
        客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到之后提取出SessionID，从Redis中取出用户信息继续之前的业务操作。

五、HTTPS协议
    HTTPS是让HTTP先和SSL（Secure Sockets Layer）通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。通过使用SSL，HTTPS具有了加密（防窃听）、
    认证（防伪装）和完整行保护。
    
1、过程
    服务器把自己的公钥登录至数字认证机构。
    数字证书机构把自己的私有密钥向服务器的公开密钥部署数字签名并颁发公钥证书。
    客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器公钥的真实性。
    使用服务器的公开密钥对报文加密后发送。
    服务器私有密钥对报文解密。

六、DNS
1、浏览器通过域名去查询URL对应的IP
    浏览器缓存：浏览器会按照一定的频率缓存DNS记录
    操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就去操作系统中找。
    路由缓存：路由器也有DNS缓存。
    ISP的DNS服务器：ISP是互联网提供商的简称，ISP有专门的DNS服务器应对DNS查询请求。
    根服务器：ISP的DNS服务器还找不到的话，就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器依此类推）
    