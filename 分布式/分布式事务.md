# 分布式事务

## 两阶段提交/XA方案

XA规范主要定义了（全局）事务管理器（TM）和（局部）资源管理器（RM）之间的接口，本地的数据库如MySQL扮演的是RM角色。

- 第一阶段（prepare）：所有的参与者RM准备执行事务并锁住需要的资源，参与者ready时，向TM报告已准备就绪。
- 第二阶段（commit/rollback）：当事务管理者（TM）确认所有参与者（RM）都ready后，向所有参与者发送commit命令。

成功完成的XA事务例子：

经典的转账问题，A需要转100给B，那么需要A的余额减去100，B的余额加上100，整个转账要保证成功。

1. AP/应用程序开启全局事务
2. AP/应用程序调用TransOut。
3. 微服务1在TM/事务管理器上注册子事务。
4. 微服务1进行本地prepare。
5. AP/应用程序调用TransIn。
6. 微服务2在事务管理器上注册子事务。
7. 微服务2进行本地prepare。
8. AP/应用程序上报全部prepare成功。
9. TM/事务管理器通知TransOut提交。
10. 微服务1进行本地提交。
11. TM/事务管理器通知TransIn提交。
12. 微服务2进行本地提交。

如果有任何一个参与者prepare失败，TM会通知所有完成prepare的参与者进行回滚。

## TCC方案

TCC全称是：Try、Confirm、Cancel。

- Try阶段：对各个服务的资源做检测以及对资源进行锁定或者预留。
- Confirm阶段：确认执行真正的业务，不做任何资源检查，只使用Try阶段的预留资源。Confirm要求具备幂等设计，Confirm失败后需要重试。
- Cancel阶段：取消执行，释放Try阶段预留的业务资源。

成功完成的TCC事务例子：

以转账作为例子，通常会在Try里面冻结金额，但不扣款，Confirm里扣款，Cancel里解冻资金。

1. AP/应用程序在TM/事务管理器上注册全局事务
2. AP/应用程序在TM/事务管理器上注册分支TransOut
3. AP/应用程序调用微服务1TransOut Try
4. AP/应用程序在TM/事务管理器注册分支TransIn
5. AP/应用程序调用微服务2TransIn Try
6. AP/应用程序向TM/事务管理器提交全局事务
7. TM/事务管理器调用微服务1TransOut Confirm
8. TM/事务管理器调用微服务2TransIn Confirm
9. TM/事务管理器全局事务成功

TCC的Confirm/Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM会不断的重试，直到Confirm/Cancel返回成功。

特点：

- 并发度较高，无长期资源锁定。
- 开发量较大，需要提供Try/Confirm/Cancel接口。
- 一致性较好，不会发生已扣款最后又转账失败的情况。
- TCC适用于订单类业务，对中间状态有约束的业务。

## Saga方案

业务流程中每个参与者都提交本地事务，若某一个参与者失败，则补偿前面已经成功的参与者。

使用场景：

- 业务流程长、业务流程多；
- 参与者包含其他公司或遗留系统服务，无法提供TCC模式要求的三个接口。

优势：

- 一阶段提交本地事务，无锁，高性能；
- 参与者可异步执行，高吞吐；
- 补偿服务易于实现，因为一个更新操作的反向操作容易理解。

缺点：

- 不保证事务的隔离性。

## 本地消息表方案

将需要分布式处理的任务通过消息的方式来异步确保执行。写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么全部成功，要么全部失败。

大致流程：

1. A系统在自己本地一个事务里操作同时，插入一条数据到消息表；
2. 接着A系统将这个消息发送到MQ中；
3. B系统接收到消息后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果消息已经被处理过，那么这个事务会回滚，保证不会重复处理消息；
4. B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；
5. 如果B系统处理失败，那么就不会更新消息表状态，此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中，让B再次处理；

该方案保证了最终一致性，哪怕事务B失败了，但是A会不断重发消息，直到B成功。

特点：

- 不支持回滚。
- 轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难。

## 可靠消息最终一致性方案

不用本地的消息表了，直接基于MQ来实现事务。

方案流程：

1. A系统先发送一个prepared消息到MQ，如果prepared消息发送失败就直接取消操作不执行了；
2. 如果A系统消息发送成功了，就直接执行本地事务，如果执行成功就给MQ发送确认消息，如果执行失败就给MQ发送回滚消息；
3. 如果发送了确认消息，那么B系统就会接收到确认消息，然后执行本地事务；
4. MQ会自动定时轮询所有prepared消息，回调相应接口，确认这个消息的本地事务是否执行失败，所以没发送确认消息，是继续重试还是回滚。一般可以查询数据库确认本地事务是否执行，如果回滚了，那么这里也进行回滚。可以避免本地事务执行成功，而确认消息却发送失败；
5. B系统事务如果执行失败，就自动不断重试直到成功。如果实在不行，就针对重要的资金类业务进行回滚，如果B系统本地回滚后，想办法通知系统A也回滚；或者发送报警由人工来手工回滚和补偿。

特点：

- 长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单。
- 事务消息的回查没有好的方案，极端情况可能出现数据错误。

## 最大努力通知方案

大致流程：

1. 系统A本地事务执行完之后，发送消息到MQ；
2. 有个专门消费MQ的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者放入内存队列，接着调用系统B的接口；
3. 要是系统B执行成功了就可以了；如果系统B执行失败了，那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃执行。
