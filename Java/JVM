一、Java虚拟机是如何加载java类的
    从class文件到内存中的类，需要经过三大步骤：加载、链接、初始化
1.加载
    指查找字节流，并且据此创建类的过程。对于数组类来说，并没有对应的字节流，是由java虚拟机直接生成的。对于其他类来说，java虚拟机则要借助类加载器来完成加载过程。
（1）双亲委派模型：
    每当一个类加载器接收到加载请求时，会先将请求转发给父类加载器，父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。
（2）类加载器
    启动类加载器（bootstrapClassLoader）：
        负责加载最为基础，最为重要的类，比如存放在JRE目录下的lib目录下的jar包中的类（以及由虚拟机参数-Xbootclasspath指定的类）。
    扩展类加载器（extensionClassLoader）：
        扩展类加载器的父类加载器是启动类加载器，它负责加载相对次要、但又通用的类，比如存放在JRE的lib/ext目录下jar包中的类（以及由系统变量java.ext.dirs指定的类）。
    应用类加载器（applicationClassLoader）：
        应用类加载器的父类加载器是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数-cp/-classpath、系统变量java.class.path或环境变量CLASSPATH所指定的路径）。
        默认情况下，应用程序中包含的类便是由应用类加载器加载的。
    除了由java核心类库提供的类加载器外，还可以加入自定义的类加载器，来实现特殊的加载方式。例如，我们可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。
（3）在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的，即使是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。
2.链接
    指将创建成的类合并至Java虚拟机中，使之能够执行的过程。可以分为验证、准备、解析三个阶段。
（1）验证：
    验证阶段的目的，在于确保被加载类能够满足Java虚拟机的约束条件。
（2）准备：
    准备阶段的目的，是为被加载类的静态字段分配内存。
在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段对应的具体地址，甚至不知道自己方法、字段的地址。每当需要引用这些成员时，Java编译器会生成一个符号引用。
在运行阶段，这个符号引用一般都能够无歧义的定位到具体目标上。
（3）解析：
    解析阶段的目的，是将符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，解析将触发这个类的加载（但未必触发这个类的链接以及初始化）。
3.初始化
    如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段会被Java编译器标记成常量值（ConstantValue），
    其初始化直接由Java虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并命名为<clinit>。
    初始化就是为标记为常量值的字段赋值，以及执行<clinit>方法的过程。Java虚拟机会通过加锁来确保类的<clinit>方法仅被执行一次。
    类的初始化何时会被触发呢？
        当虚拟机启动时，初始化用户指定的主类；
        当遇到用以新建目标实例的new指令时，初始化new指令的目标类；
        当遇到调用静态方法的指令时，初始化该静态方法所在的类；
        当遇到访问静态字段的指令时，初始化该静态字段所在的类；
        子类的初始化会触发父类的初始化；
        如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化会触发该接口的初始化；
        使用反射API对某个类进行反射调用时，初始化这个类；
        当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。

二、JVM是如何执行方法调用的
1.重载与重写
    如果想要在同一个类中定义名字相同的方法，那么参数类型必须不同，这些方法之间的关系是重载。
    重载的方法在编译过程中即可完成识别，具体到每一个方法调用，Java编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法，选取的过程共分为三个阶段：
        在不考虑对基本类型自动装拆箱，以及可变长参数的情况下选取重载方法；
        如果在第一个阶段没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
        如果在第二个阶段没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。
    如果Java编译器在同一个阶段中找到了多个适配的方法，那么会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。例如传入null时，既可以匹配
    声明为Object的形式参数，也可以匹配声明为String的形式参数。由于String是Object的子类，因此Java编译器会认为第二个方法更贴切。
2.JVM的静态绑定和动态绑定
    Java虚拟机识别方法的关键在于类名、方法名以及方法描述符。方法描述符是由方法的参数以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，
    Java虚拟机会在类的验证阶段报错。
    由于对重载方法的区分在编译阶段已经完成，可以认为在Java虚拟机不存在重载这一概念。
    Java虚拟机中的静态绑定指的是在解析时能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
3.调用指令的符号引用
    在编译过程中，并不知道目标方法的具体内存地址，因此，Java编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。
    符号引用存储在class文件的常量池中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。
（1）对于非接口符号引用，假定该符号引用所指向的类为C，则Java虚拟机会按照如下步骤进行查找：
        在C中查找符合名字及描述符的方法；
        如果没有找到，在C的父类中继续搜索，直至Object类；
        如果没有找到，在C所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果目标方法在间接实现的接口中，则需满足C与该接口之间没有其他符合条件的目标方法。
        如果有多个符合条件的目标方法，则任意返回其中一个。
（2）对于接口符号引用，假定该符号引用所指向的接口为I，则Java虚拟机会按照如下步骤进行查找：
        在I中查找符合名字及描述符的方法；
        如果没有找到，在Object类中的公有实例方法中搜索；
        如果没有找到，则在I的超接口中搜索。
    经过上述步骤，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。
4.虚方法调用
    Java里所有非私有实例方法调用都会被编译成invokevirtual指令，而接口方法调用会被编译成invokeinterface指令。这两种指令，均属于Java虚拟机中的虚方法调用。
    在Java虚拟机中，静态绑定包括用于调用静态方法的invokestatic指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的invokespecial指令。如果虚方法调用指向一个标记为final的方法，
    那么虚拟机也可以静态绑定该虚方法调用的目标方法。
5.方法表
    方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。
    方法表满足两个特征：子类方法表中包含父类方法表中的所有方法；子类方法在方法表中的索引值与它重写的父类方法的索引值相同。
    方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法；对于动态绑定的方法而言，实际引用则是方法表的索引值。
    在执行过程中，Java虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法，这个过程就是动态绑定。
    实际上，使用方法表的动态绑定与静态绑定相比，仅仅多出几个内存解析引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。
5.内联缓存
    内联缓存是一种加快动态绑定的优化技术，能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在执行过程中，如果碰到已缓存的类型，内联缓存会直接调用该类型所所对应的目标方法。
    如果碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。
    对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存是只缓存了一种动态类型以及它所对应的目标方法。实现简单：比较缓存的动态类型，如果命中则直接调用对应的目标方法。
    多态内联缓存则缓存了多个动态类型及其目标方法，需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中则调用对应的目标方法。
    
三、JVM是如何处理异常的
1.异常的基本概念
    所有异常都是Throwable类或者其子类的实例。Throwable有两个直接子类，第一个是Error，涵盖程序不应捕获的异常，当程序触发Erro时，它的执行状态已经无法恢复，需要终止线程甚至是终止虚拟机。
    第二个是Exception，涵盖程序可能需要捕获并且处理的异常。
    Exception有一个特殊的子类RuntimeException，和Error属于Java里的非检查异常，其他异常则属于检查异常。所有的检查异常都需要程序显式地捕获，或者在方法声明中用throws关键字标注。
    在构造异常实例时，Java虚拟机需要生成该异常栈轨迹，该操作会逐一访问当前线程的Java栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。
    在生成栈轨迹时，Java虚拟机会忽略掉异常构造器以及填充栈帧的Java方法，直接从新建异常位置开始算起
2.Java虚拟机是如何捕获异常的
    在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每个条目代表一个异常处理器，并且由from指针、to指针、target指针以及所捕获的异常类型构成。这些指针的值是字节码索引，用以定位字节码。
    from指针和to指针标示了该异常处理器所监控的范围，例如try代码块所覆盖的范围。target指针指向异常处理器的起始位置，例如catch代码块的起始位置。
    当程序触发异常时，Java虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，
    Java虚拟机会将控制流转移至该条目target指针指向的字节码。
    如果遍历完所有异常表条目，Java虚拟机仍未匹配到异常处理器，那么会弹出当前方法对应的栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java虚拟机需要遍历当前线程Java栈上所有方法的异常表。
    finally代码块的编译比较复杂，是复制finally代码块的内容，分别放在try-catch代码所有正常执行路径以及异常执行路径的出口中。

四、JVM是如何实现反射的
1.反射调用的实现
    MethodAccessor 是一个接口，有两个已有的具体实现，一个通过本地方法来实现反射调用，另一个使用委派模式。每个Method实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现是一个本地实现。
    反射调用先是调用了Method.invoke，然后进入委派实现（DelegatingMethodAccessorImpl），再然后进入本地实现（NativeMethodAccessorImpl），最后到达目标方法。采用委派实现是为了能够在本地实现以及
    动态实现中切换。
    动态实现和本地实现相比，运行效率要更快，这是因为动态实现无需经过Java到C++再到Java的切换，由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快。许多反射调用仅会执行一次，Java虚拟机设置了一个
    阈值15，当某个反射调用的次数在15之下时，采用本地实现；当达到15时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称为inflation。反射调用的inflation机制是可以关闭的，在反射
    调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。
2.反射调用的开销
    Class.forName会调用本地方法，Class.getMethod会遍历该类的公有方法。如果没有匹配到，还将遍历父类的公有方法。