一、Java虚拟机是如何加载java类的
    从class文件到内存中的类，需要经过三大步骤：加载、链接、初始化
1.加载
    指查找字节流，并且据此创建类的过程。对于数组类来说，并没有对应的字节流，是由java虚拟机直接生成的。对于其他类来说，java虚拟机则要借助类加载器来完成加载过程。
（1）双亲委派模型：
    每当一个类加载器接收到加载请求时，会先将请求转发给父类加载器，父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。
（2）类加载器
    启动类加载器（bootstrapClassLoader）：
        负责加载最为基础，最为重要的类，比如存放在JRE目录下的lib目录下的jar包中的类（以及由虚拟机参数-Xbootclasspath指定的类）。
    扩展类加载器（extensionClassLoader）：
        扩展类加载器的父类加载器是启动类加载器，它负责加载相对次要、但又通用的类，比如存放在JRE的lib/ext目录下jar包中的类（以及由系统变量java.ext.dirs指定的类）。
    应用类加载器（applicationClassLoader）：
        应用类加载器的父类加载器是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数-cp/-classpath、系统变量java.class.path或环境变量CLASSPATH所指定的路径）。
        默认情况下，应用程序中包含的类便是由应用类加载器加载的。
    除了由java核心类库提供的类加载器外，还可以加入自定义的类加载器，来实现特殊的加载方式。例如，我们可以对class文件进行加密，加载时再利用自定义的类加载器对其解密。
（3）在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的，即使是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。
2.链接
    指将创建成的类合并至Java虚拟机中，使之能够执行的过程。可以分为验证、准备、解析三个阶段。
（1）验证：
    验证阶段的目的，在于确保被加载类能够满足Java虚拟机的约束条件。
（2）准备：
    准备阶段的目的，是为被加载类的静态字段分配内存。
在class文件被加载至Java虚拟机之前，这个类无法知道其他类及其方法、字段对应的具体地址，甚至不知道自己方法、字段的地址。每当需要引用这些成员时，Java编译器会生成一个符号引用。
在运行阶段，这个符号引用一般都能够无歧义的定位到具体目标上。
（3）解析：
    解析阶段的目的，是将符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，解析将触发这个类的加载（但未必触发这个类的链接以及初始化）。
3.初始化
    如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。如果直接赋值的静态字段被final所修饰，并且它的类型是基本类型或字符串时，那么该字段会被Java编译器标记成常量值（ConstantValue），
    其初始化直接由Java虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并命名为<clinit>。
    初始化就是为标记为常量值的字段赋值，以及执行<clinit>方法的过程。Java虚拟机会通过加锁来确保类的<clinit>方法仅被执行一次。
    类的初始化何时会被触发呢？
        当虚拟机启动时，初始化用户指定的主类；
        当遇到用以新建目标实例的new指令时，初始化new指令的目标类；
        当遇到调用静态方法的指令时，初始化该静态方法所在的类；
        当遇到访问静态字段的指令时，初始化该静态字段所在的类；
        子类的初始化会触发父类的初始化；
        如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化会触发该接口的初始化；
        使用反射API对某个类进行反射调用时，初始化这个类；
        当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。

二、JVM是如何执行方法调用的
1.重载与重写
    如果想要在同一个类中定义名字相同的方法，那么参数类型必须不同，这些方法之间的关系是重载。
    重载的方法在编译过程中即可完成识别，具体到每一个方法调用，Java编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法，选取的过程共分为三个阶段：
        在不考虑对基本类型自动装拆箱，以及可变长参数的情况下选取重载方法；
        如果在第一个阶段没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
        如果在第二个阶段没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。
    如果Java编译器在同一个阶段中找到了多个适配的方法，那么会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。例如传入null时，既可以匹配
    声明为Object的形式参数，也可以匹配声明为String的形式参数。由于String是Object的子类，因此Java编译器会认为第二个方法更贴切。
2.JVM的静态绑定和动态绑定
    Java虚拟机识别方法的关键在于类名、方法名以及方法描述符。方法描述符是由方法的参数以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，
    Java虚拟机会在类的验证阶段报错。
    由于对重载方法的区分在编译阶段已经完成，可以认为在Java虚拟机不存在重载这一概念。
    Java虚拟机中的静态绑定指的是在解析时能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
3.调用指令的符号引用
    在编译过程中，并不知道目标方法的具体内存地址，因此，Java编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。
    符号引用存储在class文件的常量池中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。
（1）对于非接口符号引用，假定该符号引用所指向的类为C，则Java虚拟机会按照如下步骤进行查找：
        在C中查找符合名字及描述符的方法；
        如果没有找到，在C的父类中继续搜索，直至Object类；
        如果没有找到，在C所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果目标方法在间接实现的接口中，则需满足C与该接口之间没有其他符合条件的目标方法。
        如果有多个符合条件的目标方法，则任意返回其中一个。
（2）对于接口符号引用，假定该符号引用所指向的接口为I，则Java虚拟机会按照如下步骤进行查找：
        在I中查找符合名字及描述符的方法；
        如果没有找到，在Object类中的公有实例方法中搜索；
        如果没有找到，则在I的超接口中搜索。
    经过上述步骤，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。
4.虚方法调用
    Java里所有非私有实例方法调用都会被编译成invokevirtual指令，而接口方法调用会被编译成invokeinterface指令。这两种指令，均属于Java虚拟机中的虚方法调用。
    在Java虚拟机中，静态绑定包括用于调用静态方法的invokestatic指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的invokespecial指令。如果虚方法调用指向一个标记为final的方法，
    那么虚拟机也可以静态绑定该虚方法调用的目标方法。
5.方法表
    方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。
    方法表满足两个特征：子类方法表中包含父类方法表中的所有方法；子类方法在方法表中的索引值与它重写的父类方法的索引值相同。
    方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法；对于动态绑定的方法而言，实际引用则是方法表的索引值。
    在执行过程中，Java虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法，这个过程就是动态绑定。
    实际上，使用方法表的动态绑定与静态绑定相比，仅仅多出几个内存解析引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。
5.内联缓存
    内联缓存是一种加快动态绑定的优化技术，能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在执行过程中，如果碰到已缓存的类型，内联缓存会直接调用该类型所所对应的目标方法。
    如果碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。
    对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存是只缓存了一种动态类型以及它所对应的目标方法。实现简单：比较缓存的动态类型，如果命中则直接调用对应的目标方法。
    多态内联缓存则缓存了多个动态类型及其目标方法，需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中则调用对应的目标方法。
    
三、JVM是如何处理异常的
1.异常的基本概念
    所有异常都是Throwable类或者其子类的实例。Throwable有两个直接子类，第一个是Error，涵盖程序不应捕获的异常，当程序触发Erro时，它的执行状态已经无法恢复，需要终止线程甚至是终止虚拟机。
    第二个是Exception，涵盖程序可能需要捕获并且处理的异常。
    Exception有一个特殊的子类RuntimeException，和Error属于Java里的非检查异常，其他异常则属于检查异常。所有的检查异常都需要程序显式地捕获，或者在方法声明中用throws关键字标注。
    在构造异常实例时，Java虚拟机需要生成该异常栈轨迹，该操作会逐一访问当前线程的Java栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。
    在生成栈轨迹时，Java虚拟机会忽略掉异常构造器以及填充栈帧的Java方法，直接从新建异常位置开始算起
2.Java虚拟机是如何捕获异常的
    在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每个条目代表一个异常处理器，并且由from指针、to指针、target指针以及所捕获的异常类型构成。这些指针的值是字节码索引，用以定位字节码。
    from指针和to指针标示了该异常处理器所监控的范围，例如try代码块所覆盖的范围。target指针指向异常处理器的起始位置，例如catch代码块的起始位置。
    当程序触发异常时，Java虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，
    Java虚拟机会将控制流转移至该条目target指针指向的字节码。
    如果遍历完所有异常表条目，Java虚拟机仍未匹配到异常处理器，那么会弹出当前方法对应的栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java虚拟机需要遍历当前线程Java栈上所有方法的异常表。
    finally代码块的编译比较复杂，是复制finally代码块的内容，分别放在try-catch代码所有正常执行路径以及异常执行路径的出口中。

四、JVM是如何实现反射的
1.反射调用的实现
    MethodAccessor 是一个接口，有两个已有的具体实现，一个通过本地方法来实现反射调用，另一个使用委派模式。每个Method实例的第一次反射调用都会生成一个委派实现，它所委派的具体实现是一个本地实现。
    反射调用先是调用了Method.invoke，然后进入委派实现（DelegatingMethodAccessorImpl），再然后进入本地实现（NativeMethodAccessorImpl），最后到达目标方法。采用委派实现是为了能够在本地实现以及
    动态实现中切换。
    动态实现和本地实现相比，运行效率要更快，这是因为动态实现无需经过Java到C++再到Java的切换，由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快。许多反射调用仅会执行一次，Java虚拟机设置了一个
    阈值15，当某个反射调用的次数在15之下时，采用本地实现；当达到15时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称为inflation。反射调用的inflation机制是可以关闭的，在反射
    调用一开始便会直接生成动态实现，而不会使用委派实现或者本地实现。
2.反射调用的开销
    Class.forName会调用本地方法，Class.getMethod会遍历该类的公有方法。如果没有匹配到，还将遍历父类的公有方法。

五、方法句柄
1.概念
    方法句柄是一个强类型的，能够被直接执行的引用。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段
    的getter或setter方法。
    方法句柄的类型是由所指向方法的参数类型以及返回类型组成的。是用来确认方法句柄是否适配的唯一关键，当使用方法句柄时，并不关心方法句柄所指向方法的类名或者方法名。
2.创建方式
    方法句柄的创建是通过MethodHandles.Lookup类来完成的。提供了多个API，既可以使用反射API中的Method来查找，也可以根据类、方法名以及方法句柄类型来查找。
（1）通过反射创建MethodHandle
    public class Cobra{
        public static void race(){}
        public static Lookup lookup(){
            return MethodHandles.lookup();
        }
    }
    MethodHandles.Lookup lookup = Cobra.lookup();
    Method method = Cobra.class.getDeclaredMethod("race");
    MethodHandle methodHandle = lookup.unreflect(method);
（2）根据MethodType创建MethodHandle
    public class Cobra{
        public static void race(){}
        public void say(){
            System.out.println("say");
        }
        public static Lookup lookup(){
            return MethodHandles.lookup();
        }
    }
    public class Test{
        public static void main(String[] args){
            MethodHandles.Lookup = Cobra.lookup();
            MethodType methodType = MethodType.methodType(void.class);
            MethodHandle methodHandle = lookup.findStatic(Cobra.class, "race", methodType);
            MethodHandle methodHandle2 = lookup.findVirtual(Cobra.class, "say", methodType);
        }
    }
3.权限
    在实际调用过程中，Java虚拟机不会检查方法句柄的权限。方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于Lookup对象的创建位置。
    例一：在Test类中访问Cobra类的私有方法，提示权限错误。
    public class Cobra{
        private void eat(){
            System.out.println("eat");
        }
    }
    public class Test{
        public static void main(String[] args){
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            MethodType methodType = MethodType.methodType(void.class);
            MethodHandle methodHandle = lookup.findSpecial(Cobra.class, "eat", methodType, Cobra.class);
        }
    }

    例二：在Test类中访问Cobra类的私有字段，提示权限错误。
    public class Cobra{
        private String name;
    }
    public class Test{
        public static void main(String[] args){
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            MethodHandle methodHandle = lookup.findSetter(Cobra.class, "name", String.class);
            Cobra cobra = new Cobra();
            methodHandle.invokeExact(cobra, "111");
        }
    }

    例三：Lookup对象在Cobra类中创建。
    public class Cobra{
        private String name;

        public static Lookup lookup(){
            return MethodHandles.lookup();
        }
    }
    public class Test{
        public static void main(String[] args){
            MethodHandles.Lookup lookup = Cobra.lookup();
            MethodHandle methodHandle = lookup.findSetter(Cobra.class, "name", String.class);
            Cobra cobra = new Cobra();
            methodHandle.invokeExact(cobra, "111");
            methodHandle getterMethodHandle = lookup.findGetter(Cobra.class, "name", String.class);
            ; System.out.println(getDeclaredMethod.invoke(cobra));
        }
    }

    例四：JDK9中MethodHandles引入了一个新的方法privateLookupIn(Class<?> targetClass, MethodHandles.Lookup lookup)，
    该方法具有在目标类上模拟所有支持的字节码行为（包括私有访问）的完整功能。
    public class Cobra{
        private void say(){
            System.out.println("say");
        }
    }
    public class Test{
        public static void main(String[] args) throws Throwable {
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            Cobra cobra = new Cobra();
            MethodHandles.Lookup privateLookupIn = MethodHandles.privateLookupIn(Cobra.class, lookup);
            MethodHandle eat = privateLookupIn.findSpecial(Cobra.class, "eat", MethodType.methodType(void.class), Cobra.class);
            eat.invoke(cobra);
        }
    }
4.方法句柄的操作
    方法句柄的调用可分为两种，一是需要严格匹配参数类型的invokeExact，二是invoke。
    （1）invokeExact()
    如果一个方法句柄将接收一个Object类型的参数，如果直接传入String作为实际参数，那么方法句柄的调用会在运行时抛出方法类型不匹配的异常。正确的调用方式
    是将String显示转化为Object类型。在普通Java方法调用中，只有在选择重载方法时，才会用到这种显示转化。这是因为经过显示转化后，参数的声明类型发生了改变，
    因此有可能匹配到不同的方法描述符，从而选取不同的目标方法。使用注解@polymorphicSignature，Java编译器会根据所传入参数的声明类型来生成方法描述符，
    而不是采用目标方法所声明的描述符。
    （2）invoke()
    invoke会自动适配参数类型，同样是一个签名多态性的方法。会调用MethodHandles.asType方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法
    句柄。调用原方法句柄的返回值同样也会进行适配，然后再返回给调用者。
    方法句柄还支持增删改参数的操作，这些操作都是通过生成另一个方法句柄来实现的。改操作就是MethodHandle.asType方法。删操作指的是将传入的部分参数就地抛弃，
    再调用另一个方法句柄，对应的API是MethodHandles.dropArguments方法。增操作会往传入的参数中插入额外的参数，再调用另一个方法句柄，对应的API是
    MethodHandle.bindTo方法。
5.方法句柄的实现
    Java虚拟机会对invokeExact调用做特殊处理，调用至一个共享的、与方法句柄类型相关的特殊适配器中。这个适配器是一个LambdaForm，在这个适配器中，会调用
    Invokers.checkExactType方法来检查参数类型，然后调用Invokers.checkCustomized方法（该方法会在方法句柄的执行次数超过一个阈值时进行优化），最后
    会调用方法句柄的invokeBasic方法。
    Java虚拟机同样会对invokeBasic调用做特殊处理，会将调用至方法句柄本身所持有的适配器中。这个适配器也是一个LambdaForm，将获取方法句柄中的MemberName
    类型的字段，并且以它为参数调用linkToStatic方法。Java虚拟机也会对linkToStatic调用做特殊处理，将根据传入的MemberName参数所存储的方法地址或者方法
    表索引，直接跳转至目标方法。
6.invokedynamic指令
    invokedynamic用以支持动态语言的方法调用，它将调用点（CallSite）抽象成一个Java类，并且将原本由Java虚拟机控制的方法调用以及方法链接暴露给了应用程序。
    在运行过程中，每一条invokedynamic指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄。
    第一次执行invokedynamic指令时，Java虚拟机会调用该指令所对应的启动方法（BootStrap），来生成前面提到的调用点，并且将之绑定至该invokedynamic指令中。
    在之后的运行过程中，Java虚拟机会直接调用绑定的调用点所链接的方法句柄。
7.Java8的Lambda表达式
    lambda表达式也是借助invokedynamic来实现的。Java编译器利用invokedynamic指令来生成实现了函数式接口的适配器。
    在编译过程中，Java编译器会对Lambda表达式进行解语法糖（desugar），生成一个方法来保存Lambda表达式的内容。该方法的参数列表不仅包含原本Lambda表达式的
    参数，还包含它所捕获的变量。（方法引用，如Horse::race，不会生成额外的方法）。
    IntStream.of(1,2,3).map(i -> i * 2).map(i -> i * x);
    map(i -> i * 2)没有捕获其他变量，而map(i -> i * x)则捕获局部变量x。
    根据Lambda表达式是否捕获其他变量，启动方法生成的适配器类以及所链接的方法句柄不同。如果该Lambda表达式没有捕获其他变量，那么可以认为它是上下文无关的。
    因此，启动方法将新建一个适配器类的实例，并且生成一个特殊的方法句柄，始终返回该实例。如果Lambda表达式捕获了其他变量，那么每次执行该invokedynamic指令，
    都要更新捕获了的变量，以防发生变化。
六、Java对象的内存布局
1.压缩指针
    为了尽量减少对象的内存使用量，64位Java虚拟机引入了压缩指针的概念（对应虚拟机选项-XX:+UseCompressedOops，默认开启），将堆中原本64位的Java对象指针
    压缩成32位的。对象头中的类型指针也会被压缩成32位，使得对象头的大小从16字节降至12字节。压缩指针不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段，
    以及引用类型数组。
    Java虚拟机会进行内存对齐，内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存中。如果字段
    不是对齐的，那么就有可能出现夸缓存行的字段。也就是说该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。
2.字段重排列
    Java虚拟机重新分配字段的先后顺序，以达到内存对齐的目的。Java虚拟机中有三种排列方法，都会遵循两个规则。
    其一，如果一个字段占据C个字节，那么该字段的偏移量需要对齐至NC。偏移量指的是字段地址与对象的起始地址差值。
        以long类为例，在使用了压缩指针的64位虚拟机中，尽管对象头大小是12个字节，该long类型字段的偏移量也只能是16，中间空着的4个字节会被浪费掉。
    其二，子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。
        在具体实现中，Java虚拟机还会对齐子类字段的起始位置。对于使用了压缩指针的64位虚拟机，子类第一个字段需要对齐至4N；而对于关闭了压缩指针的64位虚拟机，子类
        第一个字段则需要对齐至8N。
七、引用计数法与可达性分析
1.引用计数法
    为每个对象添加一个引用计数器，用来统计指向该对象的引用计数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收。
    具体实现：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1。如果一个只向某一个对象的引用，被赋值为其他值，那么该对象的引用器-1.
2.可达性分析算法
    将一列GC Roots作为初始存活对象合集（live set），然后从该集合出发，探索所有能够被该合集引用到的对象，并将其加入到该集合中，这个过程称为标记（mark）。最终
    未被探索到的对象便是死亡的，是可以回收的。
    GC Roots包括一下几种：
        引用栈帧中的本地变量表的所有对象；
        引用方法区静态属性的所有对象；
        引用方法区常量的所有对象；
        引用native方法的所有对象。
3.Stop-the-world以及安全点
    在Java虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那就是Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。
    Stop-the-world是通过安全点（safepoint）机制来实现的。当Java虚拟机收到Stop-the-world请求，它便会等待所有的线程到达安全点，才允许请求Stop-the-world的线程
    进行独占的工作。
4.垃圾回收的三种方式
（1）标记清除算法
    标记阶段：从根对象开始，通过引用链追踪，标记所有的活动对象。标记过程中，将活动对象的标记位设置为有效状态，表示这些对象是可达的，不会被回收。
    清除阶段：在标记阶段完成后，遍历整个内存空间，将未被标记的对象视为垃圾对象，将未被标记的对象视为垃圾对象，将其所占用的内存空间释放，以便下次分配给新的对象使用。
    缺点：会造成内存碎片，由于Java虚拟机的堆中对象必须是连续分布的，可能出现总空闲内存足够，但是无法分配的极端情况；
         分配效率低，如果是一块连续的内存空间，可以通过指针加法来做分配，而对于空闲列表，Java虚拟机需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。
（2）复制算法
    把内存区域分为两等分，分别用两个指针from和to来维护，并且只是用from指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到to指针指向的内存区域中，
    并且交换from指针和to指针的内容。
    缺点：堆空间的使用效率极其低下。
（3）标记整理算法（标记-清除-压缩算法）
    标记阶段：从GC Roots开始标记所有被引用的对象。
    整理阶段：将所有的存活对象压缩到内存的一端，按顺序排放，之后清理外边界的空间。
（4）分代收集算法
    根据对象存活周期进行分区，不同的分区采用不同的算法。年轻代，复制算法；老年代，标记清除算法，标记整理算法。
5.Java虚拟机的堆划分
    Java虚拟机将堆划分为新生代和老年代，新生代又被划分为Eden区，以及两个大小相同的Survivor区。
    当调用new指令时，会在Eden区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在Eden区划空间是需要同步的。否则有可能出现两个对象共用一段内存的事故。
    当Eden区的空间耗尽，Java虚拟机便会触发一次MinorGC，来收集新生代的垃圾，存活下来的对象就会被送到Survivor区。当发生MinorGC时，Eden区和from指向的Survivor区
    中的存活对象会被复制到to指向的Survivor区中，然后交换from和to指针，以保证下次MinorGC时，to指向的Survivor区还是空的。
    Java虚拟机会记录Survivor区中的对象一共被来回复制了几次，如果一个对象被复制的次数为15，那么该对象将被晋升至老年代。如果单个Survivor区已经被占用了50%，那么较高
    复制次数的对象也会被晋升至老年代。
    当发生MinorGC时，应用了标记-复制算法，将Survivor区中的存活对象晋升到老年代，然后将剩下的存活对象和Eden区的存活对象复制到另一个Survivor区中。理想情况下，Eden
    区中的对象基本都死亡了，那么复制的数据将非常少，采用这个算法效果好。
6.Java虚拟机中的垃圾回收器
（1）新生代（标记-复制算法）
    Serial：单线程收集，进行垃圾收集时必须暂停所有工作线程。
    Parallel New：多线程收集，其余的行为特点和Serial收集器一样。
    Parallel Scavenge：与Parallel New类似，更关注吞吐量。
（2）老年代
    Serail Old：采用标记-整理算法，单线程收集，进行垃圾收集时必须暂停所有工作线程。
    Parallel Old：采用标记-整理算法，多线程收集，吞吐量优先。
    CMS：采用标记-清除算法，并且是并发的。除了少数几个操作需要StopTheWorld，可以在应用程序运行时进行垃圾回收。在并发收集失败的情况下，Java虚拟机会使用其他两个压缩型
        垃圾回收器进行垃圾回收。（由于G1的出现，CMS在Java9中已被废弃。）
（3）G1收集器（标记-压缩算法）
    横跨新生代和老年代，将Java堆内存划分为多个大小相等的Region，每个区都可以充当Eden区，Survivor区或者老年代中的一个。可以在程序运行过程中并发地进行垃圾回收。
    能够针对每个细分的区域进行垃圾回收，在选择进行垃圾回收区域时，会优先回收死亡对象较多的区域。
八、Java内存模型
1.Java内存模型与happens-before关系
    happens-before是用来描述两个操作的内存可见性的。如果操作X happens-before操作Y，那么X的结果对于Y可见。
    程序次序规则：在一个线程内，按照控制流顺序，如果操作A先行发生于操作B，那么操作A所产生的影响对于操作B是可见的。
    管程锁定规则：对于同一个锁，如果一个unlock操作先行发生于一个lock操作，那么该unlock操作所产生的影响对于该lock操作是可见的。
    volatile变量规则：对于同一个volatile变量，如果对于这个变量的写操作先行发生于这个变量的读操作，那么对于这个变量的写操作所产生的影响对于这个变量的读操作是可见的。
    线程启动规则：对于同一个Thread对象，该Thread对象的start()发生于此线程的每一个动作，也就是说对线程start()方法调用所产生的影响对于该线程的每一个动作都是可见的。
    线程终止规则：对于一个线程，线程中发生的所有操作先行发生于对此线程的终止检测，也就是说线程中的所有操作所产生的影响对于调用线程Thread.join()方法或者
    Thread.isAlive()方法都是可见的。
    线程中断规则：对于同一个线程，对线程interrupt()方法的调用先行发生于该线程检测到中断事件的发生，也就是说线程interrupt()方法调用所产生的影响对于该线程检测到中断
    事件是可见的。
    对象终结规则：对于同一个对象，它的构造方法执行先行发生于它的finalize()方法的开始，也就是说一个对象的构造方法结束所产生的影响，对于它的finalize()方法方法开始执行
    是可见的。
    传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，则操作A先行发生于操作C，也就说操作A所产生的所有影响对于操作C是可见的。
2.Java内存模型的底层实现
    Java内存模型是通过内存屏障（memory barrier）来禁止重排序的。
    对于即时编译器来说，会针对每个happens-before向正在编译的目标方法中插入相应的读读、读写、写读、以及写写内存屏障。
3.锁，volatile，final字段与安全发布
（1）锁
    解锁操作heppens-before之后对同一把锁的加锁操作，在解锁时，Java虚拟机同样需要强制刷新缓存，使得当前线程修改的内存对其他线程可见。
    如果编译器能够（通过逃逸分析）证明某把锁仅被同一线程持有，那么可以移除相应的加锁操作，因此也不再强制刷新缓存。
（2）volatile
    volatile字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于锁操作。然而频繁访问volatile字段也会因为不断强制刷新缓存而严重影响程序的性能。
    volatile字段的每次访问均需要直接从内存中读写。
（3）final实例字段
    final实例字段涉及新建对象的发布问题。当一个对象包含final实例字段时，希望其他线程只能看到已初始化的final实例字段。因此即时编译器在final字段的写操作后插入一个写写
    屏障，以防某些优化将新建对象的发布重排序至final字段的写操作之前。
九、Java虚拟机如何实现synchronized
    当执行monitorenter时，如果目标对象的计数器为0，那么说明没有被其他线程所持有。在这个情况下，Java虚拟机会将该锁对象持有线程设置为当前线程，并且将其计数器加1。
    在目标锁对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。
    当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。当计数器减为0时，那便代表该锁已经被释放掉了。
1.重量级锁
    重量级锁是Java虚拟机中最为基础的锁实现。在这种状态下，Java虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。
    为了尽量避免昂贵的线程阻塞、唤醒操作，Java虚拟机会在线程进入阻塞状态之前，以及被唤醒后竞争不到锁的情况下，进入自旋状态，在处理器上空跑并且轮询锁是否被释放。如果此时
    锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。与线程阻塞相比，自旋状态可能会浪费大量的处理器资源。因为当前线程仍处于运行状况，只不过跑的是无用
    指令，期望在运行无用指令的过程中，锁能够被释放出来。
2.轻量级锁
    采用CAS操作，将锁对象的标记字段替换为一个指针，指向当前线程栈上的一块空间，存储着锁对象原本的标记字段。针对的是多个线程在不同时间段申请同一把锁的情况。
3.偏向锁
    在线程进行加锁时，如果该锁对象支持偏向锁，那么Java虚拟机会通过CAS操作，将当前线程的地址记录在锁对象的标记字段中，并且将标记字段的最后三位设置为101。在接下来运行过程中，
    每当有线程请求这把锁，Java虚拟机只需判断锁对象标记字段中，最后三位是否为101，是否包含当前线程的地址，以及epoch值是否和锁对象的类的epoch值相同。如果都满足，那么当前
    线程持有该偏向锁，可以直接返回。
十、Java语法糖与Java编译器
1.自动装箱与自动拆箱
2.泛型与类型擦除
    Java程序里的泛型信息，在Java虚拟机里全部都丢失了，主要是为了兼容引入泛型之前的代码。
    并不是每一个泛型参数被擦除类型后都会变成Object类，对于限定了继承类的泛型参数，经过类型擦除后，所有的泛型参数都将变成所限定的继承类。Java编译器将选取该泛型所能指代的
    所有类中层次最高的那个，作为替换泛型的类。
3.桥接方法
    为了保证编译而成的Java字节码能保留重写的语义，Java编译器额外添加了一个桥接方法。该桥接方法在字节码层面重写了父类的方法，并将调用子类的方法。
十一、即时编译（Just-in-time Compilation，JIT）
    即时编译是一种通过在运行时将字节码翻译为机器码，从而改善字节码编译语言性能的技术。
1.热点代码
    在Java编译体系中，一个Java的源码文件变成计算机可执行的机器指令的过程中，需要经过两段编译，第一段是把 .java 文件转换成 .class 文件。第二段编译是把 .class 转换成
    机器指令的过程。
    当JVM发现某个方法或代码块运行特别频繁时，就会认为这是“热点代码（Hot Spot Code）”。JIT会把部分热点代码class翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的
    机器码缓存起来，以备下次使用。
    参数-XX:ReservedCodeCacheSize=N（N是为特定编译器提供的默认值）主要设置热点代码缓存codecache的大小。如果缓存不够，则JIT无法继续编译，并且会去优化，比如编译执行
    改为解释执行，性能会降低。
2.HotSpot编译器
    HotSpot虚拟机包含多个即时编译器C1、C2和Graal。
（1）C1编译器
    C1编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，称为Client Compiler。
（2）C2编译器
    C2编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，也称为Server Compiler。
（3）Graal JIT编译器
    Graal编译器自Java10起可以使用，作为C2的替代品。与C2不同，Graal可以在即时和提前编译模式下运行以生成本机代码。
3.分层编译
    最早在Java7引入，目标是混合使用C1和C2编译器，以实现快速启动和良好的长期性能。
    JVM使用一个解释器和两个JIT编译器工作，仍有五种可能的编译级别。因为C1编译器可以在三个不同的级别上运行。
（1）0级——解释代码
（2）1级——简单的C1编译代码
    JVM使用C1编译器编译代码，但不收集任何分析信息，JVM将级别1用于被认为不重要的方法。
（3）2级——有限C1编译代码
    JVM使用C1编译器和轻度分析来编译代码。当C2队列已满时，JVM使用此级别。目标是尽快编译代码以提高性能。
（4）3级——完整的C1编译代码
    JVM使用具有完整分析功能的C1编译器来编译代码，是默认编译路径的一部分，JVM在所有情况下都会使用它，除了简单的方法或编译器队列已满时。
（5）4级——C2编译代码
    JVM使用C2编译器来编译代码，以获得最大的长期性能，也是默认编译路径的一部分。JVM使用该级别“编译除普通方法外的所有方法”。
4.即时编译的触发
    Java虚拟机是根据方法的调用次数以及循环回边的执行次数来即时编译的。
    回边计数器：用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”，该值用于计算是否触发C1编译的阈值。
5.OSR编译
    Java虚拟机还存在着另一种以循环为单位的即时编译，叫做On-Stack-Replacement（OSR）编译，循环回边计数器就是用来触发这种类型的编译的。
    OSR实际上是一种技术，指的是在程序执行过程中，动态替换掉Java方法栈桢，从而使得程序能够在非方法入口进行解释执行和编译后的代码之间的切换。
十二、Java字节码
1.操作数栈
    在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。
    执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的
    结果重新压入栈中。
    作用在操作数栈上的指令：
        dup：常用于复制new指令所生成的未经初始化的引用。
        pop：常用于舍弃调用指令的返回结果。
2.局部变量区
    字节码程序可将计算结果缓存在局部变量区中。Java虚拟机将局部变量区当成一个数组，依次存放this指针（仅非静态方法），所传入的参数，以及
    字节码中的局部变量。
    存储在局部变量区的值，通常需要加载至操作数栈中，才能进行计算，得到计算结果后再存储至局部变量数组中。加载、存储指令是区分类型的。
    局部变量数组的加载、存储指令都需要指明所加载单元的下标。
3.字节码简介
    Java相关指令：
        new：后跟目标类，生成该类的未初始化的对象；
        instanceof：后跟目标类，判断栈顶元素是否为目标类、接口的实例。是则压入1，否则压入0。
        checkcast：后跟目标类，判断栈顶元素是否为目标类、接口的实例。如果不是就抛出异常。
        athrow：将栈顶异常抛出。
        monitorenter和monitorexit：为栈顶对象加锁和解锁。
        getstatic、putstatic、getfield、putfield
十三、方法內联
    在编译过程中，当遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。

十四、逃逸分析
    一种确定指针动态范围的静态分析，可以分析在程序的哪些地方可以访问到指针。
1.逃逸分析
    在Java虚拟机的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。
    即时编译器判断对象是否逃逸的依据：
        一是对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用。即时编译器因此无法追踪
        所有使用该对象的代码未知。
        二是对象是否被传入未知代码中，由于Java虚拟机是以方法为单位的，对于方法中未被內联的方法调用，即时编译器会将其当成未知代码，无法确认该方法
        调用会不会将调用者或所传入的参数存储至堆中。因此可以认为方法调用的调用者以及参数是逃逸的。
2.基于逃逸分析的优化
    即时编译器可以根据逃逸分析的结果进行锁消除、栈上分配以及标量替换的优化。
    如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没有意义。因为其他线程并不能获得该锁对象，也不可能对其进行加锁。在这种情况下，
    即时编译器可以消除对该不逃逸锁对象的加锁、解锁操作。
    标量，就是能够仅存储一个值的变量。标量替换这项技术可以看成将原本对对象的字段的访问，替换成一个个局部变量的访问。