一、线程
1、线程和进程
    进程是程序的一次执行过程，是系统运行程序的基本单位，进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
    线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有
    自己的程序计数器、虚拟机栈和本地方法栈，线程也被称为轻量级进程。
    一个Java程序的运行是main线程和多个其他线程同时运行。
2、线程与进程的关系，区别和优缺点
    一个进程中可以有多个线程，多个线程共享进程的堆和方法区（jdk1.8之后的原空间）资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。
    线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程有可能会相互影响。线程
    执行开销小，但不利于资源的管理和保护；而进程正相反。
3、程序计数器为什么是私有的
    程序计数器的作用：
        字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
        在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。如果执行的是native方法，
        那么程序计数器记录的是undefined地址，只有执行的是Java代码时程序计数器记录的才是下一条指令的地址。
    程序计数器是为了线程切换后能恢复到正确的执行位置。
4、虚拟机栈和本地方法栈为什么是私有的
    虚拟机栈：每个Java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在
        Java虚拟机栈中入栈和出栈的过程。
    本地方法栈：和虚拟机栈所发挥的作用非常相似，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
    为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。
5、如何创建线程
    一般来说，创建线程有很多方式，例如继承Thread类、实现Runnable类、实现Callable接口、使用线程池、使用CompletableFuture类等。这些方式其实并
    没有真正创建出线程。准确说这些都是在Java代码中使用多线程的方法。Java就只有一种方式可以创建线程，就是通过new Thread().start()创建。不管哪种
    方式，最终还是依赖于new Thread().start()。
6、线程的生命周期和状态
    Java线程在运行的生命周期中的指定时刻只能处于下面6种不同状态的一个状态：
        NEW：初始状态，线程被创建出来但没有被调用start()。
        RUNNABLE：运行状态，线程被调用了start()等待运行的状态。
        BLOCKED：阻塞状态，需要等待锁释放。
        WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知和中断）。
        TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像WAITING那样一直等待。
        TERMINATED：终止状态，表示该线程已经运行完毕。
7、什么是线程上下文切换
    线程在执行过程中会有自己的运行条件和状态（也称上下文）。
        主动让出CPU，比如调用了sleep()，wait()等。
        时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。
        调用了阻塞类型的系统中断，比如请求IO，线程被阻塞。
        被终止或结束运行。
    前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用CPU的时候恢复线程。并加载下一个将要占用CPU的上下文。这就是上下文切换。
8、Thread的sleep()方法和Object的wait()方法对比
    共同点：两者都可以暂停线程的执行。
    区别：sleep()方法没有释放锁，而wait()方法释放了锁。
        wait()通常被用于线程间交互/通信，sleep()通常被用于暂停执行。
        wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒，
        或者也可以使用wait(long timeout)超时后线程会自动苏醒。
        sleep()是Thread类的静态本地方法，wait()则是object类的本地方法。
9、为什么wait()方法不定义在Thread中
    wait()是让获得对象锁的线程等待，会自动释放当前线程占有的对象锁。每个对象（object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，
    自然是要操作对应的对象（object）而非当前线程（Thread）。
10、可以直接调用Thread类的run方法
    new一个Thread，线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就开始运行了。start()会执行线程
    的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。但是直接执行run()方法，会把run()方法当成一个main线程下的普通方法去执行，
    并不会在某个线程中执行它，所以并不是多线程工作。

二、多线程
1、并发与并行的区别
    并发：两个及两个以上的作业在同一时间段内执行。
    并行：两个及两个以上的作业在同一时刻执行。
2、同步和异步的区别
    同步：发出一个调用后，在没有得到结果之前，该调用就不可以返回，一直等待。
    异步：调用在发出之后，不用等待返回结果，该调用直接返回。
3、为什么要使用多线程
    