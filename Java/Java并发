一、线程
1、线程和进程
    进程是程序的一次执行过程，是系统运行程序的基本单位，进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。
    线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有
    自己的程序计数器、虚拟机栈和本地方法栈，线程也被称为轻量级进程。
    一个Java程序的运行是main线程和多个其他线程同时运行。
2、线程与进程的关系，区别和优缺点
    一个进程中可以有多个线程，多个线程共享进程的堆和方法区（jdk1.8之后的原空间）资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。
    线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程有可能会相互影响。线程
    执行开销小，但不利于资源的管理和保护；而进程正相反。
3、程序计数器为什么是私有的
    程序计数器的作用：
        字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
        在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。如果执行的是native方法，
        那么程序计数器记录的是undefined地址，只有执行的是Java代码时程序计数器记录的才是下一条指令的地址。
    程序计数器是为了线程切换后能恢复到正确的执行位置。
4、虚拟机栈和本地方法栈为什么是私有的
    虚拟机栈：每个Java方法在执行之前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在
        Java虚拟机栈中入栈和出栈的过程。
    本地方法栈：和虚拟机栈所发挥的作用非常相似，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
    为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。
5、如何创建线程
    一般来说，创建线程有很多方式，例如继承Thread类、实现Runnable类、实现Callable接口、使用线程池、使用CompletableFuture类等。这些方式其实并
    没有真正创建出线程。准确说这些都是在Java代码中使用多线程的方法。Java就只有一种方式可以创建线程，就是通过new Thread().start()创建。不管哪种
    方式，最终还是依赖于new Thread().start()。
6、线程的生命周期和状态
    Java线程在运行的生命周期中的指定时刻只能处于下面6种不同状态的一个状态：
        NEW：初始状态，线程被创建出来但没有被调用start()。
        RUNNABLE：运行状态，线程被调用了start()等待运行的状态。
        BLOCKED：阻塞状态，需要等待锁释放。
        WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知和中断）。
        TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像WAITING那样一直等待。
        TERMINATED：终止状态，表示该线程已经运行完毕。
7、什么是线程上下文切换
    线程在执行过程中会有自己的运行条件和状态（也称上下文）。
        主动让出CPU，比如调用了sleep()，wait()等。
        时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。
        调用了阻塞类型的系统中断，比如请求IO，线程被阻塞。
        被终止或结束运行。
    前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用CPU的时候恢复线程。并加载下一个将要占用CPU的上下文。这就是上下文切换。
8、Thread的sleep()方法和Object的wait()方法对比
    共同点：两者都可以暂停线程的执行。
    区别：sleep()方法没有释放锁，而wait()方法释放了锁。
        wait()通常被用于线程间交互/通信，sleep()通常被用于暂停执行。
        wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒，
        或者也可以使用wait(long timeout)超时后线程会自动苏醒。
        sleep()是Thread类的静态本地方法，wait()则是object类的本地方法。
9、为什么wait()方法不定义在Thread中
    wait()是让获得对象锁的线程等待，会自动释放当前线程占有的对象锁。每个对象（object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，
    自然是要操作对应的对象（object）而非当前线程（Thread）。
10、可以直接调用Thread类的run方法
    new一个Thread，线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就开始运行了。start()会执行线程
    的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。但是直接执行run()方法，会把run()方法当成一个main线程下的普通方法去执行，
    并不会在某个线程中执行它，所以并不是多线程工作。

二、多线程
1、并发与并行的区别
    并发：两个及两个以上的作业在同一时间段内执行。
    并行：两个及两个以上的作业在同一时刻执行。
2、同步和异步的区别
    同步：发出一个调用后，在没有得到结果之前，该调用就不可以返回，一直等待。
    异步：调用在发出之后，不用等待返回结果，该调用直接返回。

三、死锁
1、产生死锁的四个必要条件
    互斥条件：该资源任意一个时刻只由一个线程占用。
    请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
    不剥夺条件：该线程已获得的资源在为使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
    循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。
2、如何检测死锁
    使用jmap、jstack等命令查看JVM线程栈和堆内存的情况。如果有死锁，jstack的输出中通常会有Found one Java-level deadlock的字样，后面会
    跟着死锁相关的线程信息。实际项目中还可以搭配使用top、df、free等命令查看操作系统的基本情况，出现死锁可能会导致CPU、内存等资源消耗过高。
3、如何预防线程死锁
    破坏请求与保持条件：一次性申请所有的资源。
    破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放占有的资源。
    破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。

四、volatile关键字
1、如何保证变量的可见性
    volatile关键字可以保证变量的可见性，如果将变量声明为volatile，指示JVM这个变量是共享且不稳定的，每次使用它都到主存中进行读取。
2、如何禁止指令重排序
    volatile关键字除了可以保证变量的可见性，还有一个重要的作用就是防止JVM的指令重排序。如果将变量声明为volatile，在对这个变量进行读写操作的时候，
    会通过插入特定的内存屏障的方式来禁止指令重排序。
    双重检验锁实现对象单例：
        public class Singleton{
            private volatile static Singleton uniqueInstance;
            private Singleton(){}

            public static getInstance(){
                if(uniqueInstance == null){
                    synchronized(Singleton.class){
                        if(uniqueInstance==null){
                            uniqueInstance = new Singleton();
                        }
                    }
                }
                return uniqueInstance;
            }
        }
3、volatile可以保证原子性吗？
    volatile关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。
    public class VolatileAtomicityDemo{
        public volatile static int inc = 0;
        public void increase(){
            inc++;
        }
        public static void main(String[] args) throws InterruptedException{
            ExecutorService threadPool = Executors.newFixedThreadPool(5);
            VolatileAtomicityDemo volatileAtomicityDemo = new VolatileAtomicityDemo();
            for(int i = 0; i < 5; i++){
                threadPool.execute(() -> {
                    for (int j = 0; j < 500; j++){
                        volatileAtomicityDemo.increase();
                    }
                })
            }
            Thread.sleep(1500);
            System.out.println(inc);
            threadPool.shutdown();
        }
    }
    原则上应该输出的最终结果是2500，但实际上并不是2500。因为inc++并不是一个原子操作，inc++其实是一个复合操作，分为三步：读取inc的值；对inc加1；
    将inc的值写回内存。当两个线程对inc进行操作，线程1先读取inc的值，还未对inc进行操作，线程2也读取了inc的值，并将其加1，再将inc的值写回内存。而
    线程1不知道inc的值已经改变，依然对inc的值加1，此时线程1持有的inc的值为2，再将其写回内存。这样两个线程执行了两次，但是inc的值只增加了1。
    使用synchronized改进：
        public synchronized void increase(){
            inc++;
        }
    使用AtomicInteger改进：
        public AtomicInteger inc = new AtomicInteger();
        public void increase(){
            inc.getAndIncrement();
        }
    使用ReentrantLock改进：
        Lock lock = new ReentrantLock();
        public void increase(){
            lock.lock();
            try{
                inc++;
            } finally {
                lock.unlock();
            }
        }

五、乐观锁和悲观锁
1、悲观锁
    悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出问题，所以每次在获取资源的时候都会上锁，这样其他线程拿到这个资源就会阻塞直到锁被
    上一个持有者释放。
    高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。悲观锁还可能存在死锁问题，影响代码运行。
2、乐观锁
    乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出问题，线程可以不停执行，无需加锁也无需等待，只是在提交修改的时候去验证资源是否被
    其他线程修改了。
3、如何实现乐观锁
    版本号机制和CAS算法。
4、版本号机制
    一般是在数据表上加一个数据版本号version字段，表示被修改的次数。当数据被修改时，version会加一。当线程A更新数据值时，在读取数据的同时也会读取
    version值，在提交更新时，如果读取的version值跟当前数据的version值相等才更新，否则重试更新，直到成功。
5、CAS算法
    CAS全称是Compare And Swap（比较交换），用于实现乐观锁，就是用一个预期值和要更新的变量值进行比较，两值相等才会更新。
    CAS涉及三个操作数：
        V：要更新的变量值（Var）
        E：预期值（Expected）
        N：要写入的新值（New）
    当且仅当C的值等于E时，CAS通过原子方式用新值N来更新V的值。如果不等说明有别的线程更新了V，则放弃这次更新。
6、Java如何实现的CAS
    Java中实现CAS操作的一个关键类是Unsafe。Unsafe类位于sun.misc下，是一个提供低级别、不安全操作的类。不推荐在应用程序中使用。
7、CAS算法的问题
（1）ABA问题
    如果一个变量初次读取的时候是A值，并且在准备更新的时候还是A值，这无法说明这个变量没有被更新过。在这段时间中可能被改成了其他值，又改回了A值，
    但是CAS会认为该变量从来没有被修改过。
    如何解决：
        在变量前面追加版本号或者时间戳。AtomicStampedReference类就是用来解决ABA问题的，其中的compareAndSet()方法就是首先检查当前引用是否
        等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则用原子方式将该引用和该标志的值设为给定的更新值。
（2）循环时间长开销大
    CAS操作会用自旋来重试，不成功就一直循环直到成功，长时间不成功会给CPU带来非常大的执行开销。
（3）只能保证一个共享变量的原子操作

六、synchronized关键字
1、synchronized的作用
    主要解决多个线程之间访问资源的同步性，可以保证被修饰的方法或者代码块在任一时刻只能有一个线程执行。
    在Java早期版本中，synchronized属于重量级锁。因为监视器锁是依赖于底层操作系统的Mutex Lock来实现的，Java的线程是映射到操作系统的原生线程上的，
    如果要挂起或者唤醒一个线程都需要操作系统的帮忙，操作系统实现线程之间的切换需要从用户态转换到内核态，这个操作需要比较长的时间。
2、如何使用synchronized
（1）修饰实例方法（锁当前对象实例）
    synchronized void method(){}
（2）修饰静态方法（锁当前类）
    synchronized static void method(){}
    静态synchronized方法和非静态synchronized方法之间的调用互斥吗？
        不互斥，如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，不会发生互斥。
        因为访问静态syncrhonized占用的锁是，而访问非静态synchronized方法占用的锁是当前实例对象锁。
（3）修饰代码块（锁指定对象/类）
    synchronized(object){} 表示进入同步代码库前要获得给定对象的锁。
    synchronized(类.class){} 表示进入同步代码前要获得给定Class的锁。
3、synchronized底层原理
（1）synchronized代码块
    synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令
    则指向同步代码块的结束位置。
    当执行monitorenter指令时，线程试图获取对象监视器monitor的持有权。在执行monitorenter时会尝试获取对象的锁，如果锁的计数器为0则表示锁可以
    被获取，获取后将锁计数器设为1。对象锁的拥有者线程才可以执行monitorexit指令来释放锁。在执行monitorexit之后，将锁计数器设为0，表明锁被释放，
    其他线程可以尝试获取锁。
（2）synchronized修饰方法
    synchronized使用的是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。JVM通过该标志来辨别一个方法是否声明为同步方法，从而执行相应的方法调用。
4、synchronized和volatile的区别
    volatile关键字是线程同步的轻量级实现。volatile关键字只能用于变量而synchronized关键字可以修饰方法和代码块。
    volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。
    volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字结局的是多个线程之间访问资源的同步性。