# JVM

## JVM内存结构

![JVM结构](images/JVM.png)

### 堆

虚拟机管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

### Java虚拟机栈

每个方法执行的时候，Java虚拟机都会同步的创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用直至执行完毕的时候，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。

- 局部变量表存放了编译器可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和返回地址类型。
- 在栈深度溢出或栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError的异常。

### 本地方法栈

为虚拟机使用到的本地方法服务。

### 方法区

被各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息（类名、方法描述、字段描述）、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 运行时常量池

- 运行时常量池是方法区的一部分。Class文件除类字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量和符号引用，在类加载后存放到运行时常量池中。
- 运行时常量池具备动态性，运行期间可以将新的常量放入池中，当无法申请到空间抛出OutOfMemoryError异常。

## 垃圾判断方法

### 引用计数法

在对象中添加一个引用计数器，有一个地方引用时，计数器加一，引用失效时减一。

### 可达性分析算法

通过一系列称为GC Roots的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。若某对象到GC Roots间没有任何引用链相连，证明此对象不能再被使用。

GC Roots对象：

1. 虚拟机栈中的引用对象。如线程调用方法堆栈的参数、局部变量、临时变量。
2. 在方法区中类静态属性引用的对象。如Java类的引用类型静态变量。
3. 在方法区中常量引用的对象。如字符串常量池的引用。
4. 在本地方法栈中的JNI引用的对象。
5. Java虚拟机内部的引用。如基本类型对应的Class对象，一些常驻异常对象（NullPointException）等，还有系统类加载器。
6. 所有被同步锁（synchronized）持有的对象。

### 三色标记算法

GCRoot如果想查找到存活的对象，会根据可达性性分析算法，遍历整个引用链，按照是否访问过该对象分成三种不同的颜色。

- 白色：本对象没有被GCRoot扫描过，有可能是垃圾对象；
- 灰色：本对象已经被GCRoot扫描过，且本对象中的属性没有被GCRoot扫描，该对象就是灰色对象；如果该对象的属性被扫描的情况下，从灰色变为黑色。
- 黑色：本对象已经被GCRoot扫描过，且本对象中的属性已经被GCRoot扫描过，该对象就是黑色对象。

算法缺陷：在并发标记阶段，因为用户线程，与GC线程同时运行，有可能会产生多标或者漏标。

漏标问题产生满足两个条件：

1. 至少有一个黑色对象指向了白色对象；
2. 在所有灰色对象扫描完整个链时，删除之前所有白色对象引用关系。

#### CMS如何解决漏标问题

写屏障+增量更新方式：

满足灰色对象与白色对象断开连接，在并发标记阶段当黑色对象引用关联白色对象，记录下黑色对象。在重新标记阶段（所有用户线程暂停），将黑色对象变为灰色对象将整个引用链全部扫描。

#### G1如何解决漏标问题

原始快照方式：

在灰色对象断开白色对象的时候，会记录原始快照，在重新标记阶段以白色对象变为灰色为起始点扫描整个链，本次GC不会被清理。

- 优点：如果黑色对象引用该白色对象，无需做任何遍历，效率高。
- 缺点：如果黑色对象没有引用该白色对象，该白色对象在本次GC继续存活，放在下一次GC的时候清理。

以浮动垃圾（占用内存）换用户线程暂停时间。

## 垃圾收集算法

### 标记清除算法

算法分为两个阶段，一个阶段是标记出所有需要回收的对象，在标记完成后，统一回收掉所有标记的对象，当然也可以反过来标记存活对象，统一回收未标记对象。

缺点：

1. 执行效率不稳定，如果Java堆中包含大量对象，并且其中大部分是需要回收的对象，当对象的数量增长，标记跟清除的执行效率会越来越低。
2. 内存碎片化，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致后续程序在分配大对象时不得不触发另一次垃圾收集动作。

### 标记复制算法

为了解决标记算法面对大量可回收对象时执行效率低以及空间碎片化问题，该算法将内存分为两个大小相等的空间，每次只使用其中一块。当一块内存使用完了，就将还存活的对象复制到另一半上去，然后把已使用过的空间一次性清理干净。

缺点：

- 当内存中大多数对象都是存活的，那么该算法会产生大量的复制开销。
- 将可用的对象内存缩小为原来的一半，空间浪费太多。

### 标记整理算法

移动存活的对象到另一端。

缺点：

- 在老年代这种每次回收都有大量存活的区域，移动存活对象并更新所有引用这些对象的地方会是一种极其负重的工作，期间必须暂停用户应用程序才能进行。

## 垃圾收集器

使用 java -XX:+PrintCommandLineFlags -version 命令查看jdk默认垃圾收集器。

JDK8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
JDK9-22：G1

### Serial收集器

单线程收集器，只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾回收时必须暂停所有的工作线程（”Stop The World“），直到收集结束。

新生代采用标记-复制算法，老年代采用标记-整理算法。

### Serial Old收集器

使用标记-整理算法。

### ParNew收集器

ParNew收集器是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等）和Serial收集器完全一样。

### Parallel Scavenge收集器

新生代收集器，基于标记-复制算法，能够并行收集的多线程收集器。特点是达到一个可控制的吞吐量。吞吐量=运行客户代码时间/（运行用户代码时间+运行垃圾收集时间）

- XX:MaxGCPauseMills：控制最大垃圾收集时间参数
- XX:GCTimeRatio：设置吞吐量大小时间
  - 设置的值应当是大于0小于100的整数，也就是垃圾回收时间占总时间的比率为吞吐量的倒数。
  - 设置成19，允许垃圾回收时间为总时间的5%(1/(1+19))，默认值为99，允许最大1%的时间进行垃圾回收。
- XX:+UseAdaptiveSizePolicy：开启自适应的调整策略。

### Paralle Old收集器

Parralle Scavenge收集器的老年版本，支持多线程并发收集，基于标记-整理算法。

### CMS（Concurrent Mark Sweep）收集器

一种以获取最短回收停顿时间为目标的收集器，工作于老年代。

工作流程：

1. 初始标记：仅仅标记一下GCRoot对象能直接关联到的对象，速度很快，需要暂停所有线程。
2. 并发标记：从GC Root关联对象开始遍历整个对象图的过程，可以与用户线程共同执行。
3. 重新标记：因用户程序继续运行而导致标记产生变动的那部分对象的标记记录，通常比初始标记长远比并发标记短。
4. 并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动对象，因此可以与用户线程共同执行。
