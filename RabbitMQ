1.消息队列定义
    消息队列是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递，消息发布者只管把消息发布到MQ中而不用管谁来取，
    消息使用者只管从MQ中取消息而不管是谁发布的。
2.RabbitMQ特点
（1）可靠性：使用一些机制来保证可靠性，如持久化、传输确认、发布确认。
（2）灵活的路由：在消息进入队列之前，通过Exchange来路由消息。对于典型的路由功能，RabbitMQ已经提供了一些内置的Exchange来实现，针对更复
杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制来实现自己的Exchange。
（3）消息集群：多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。
（4）高可用：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。
（5）多种协议：RabbitMQ支持多种消息队列协议，比如STOMP、MQTT等。
（6）多语言客户端：RabbitMQ几乎支持所有常用语言。
（7）管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。
（8）跟踪机制：如果消息异常，RabbitMQ提供了消息跟踪机制，使用者可以找出发生了什么。
（9）插件机制：RabbitMQ提供了许多插件来从多方面进行扩展，也可以编写自己的插件。
3.基本概念
（1）Message
    消息是不具名的，由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority
    （相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。
（2）Publisher
    消息的生产者，也是一个向交换器发布消息的客户端应用程序。
（3）Exchange
    交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。
（4）Binding
    绑定用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。
（5）Queue
    消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个
    队列将其取走。
（6）Connection
    网络连接，比如一个TCP连接。
（7）Channel
    信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队
    列还是接收消息，这些动作都是通过信道完成的。
（8）Consumer
    消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。
（9）Virtual Host
    虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服
    务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP的基础，必须在连接时指定。
（10）Broker
    表示消息队列服务器实体。
4.消息路由
    生产者把消息发送到Exchange上，消息最终到达队列并被消费者接收，而Binding决定交换器的消息应该发送到哪个队列。
5.Exchang类型
（1）direct
    消息中的路由键（routing key）如果和Binding中的binding key一致，交换器就将消息发送到对应的队列中。路由键与队列名完全匹配，如果一个队列
    绑定到交换机要求路由键为‘dog’，则只转发routing key标记为’dog‘的消息，不会转发‘dog.puppy’，它是完全匹配、单播的模式。
（2）fanout
    每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息
    都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网的主机都获得了一份复制的消息。fanout类型转发消息是最快的。
（3）topic
    topic交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，
    这些单词之间用点隔开。同样也会识别两个通配符：符号‘#’和‘*’。符号：* 表示允许一个单词，my.* 支持my.email、my.sms,不支持my.email.test
    符号：# 表示允许多个单词，my.# 支持my.email、my.email.test、my.email.test.ttt
6.代码示例

    //消息生产者
    import com.rabbitmq.client.Channel;
    import com.rabbitmq.client.Connection;
    import com.rabbitmq.client.ConnectionFactory;
    import java.io.IOException;
    import java.util.concurrent.TimeoutException;
    public class Producer {

        public static void main(String[] args) throws IOException, TimeoutException {
            //创建连接工厂
            ConnectionFactory factory = new ConnectionFactory();
            factory.setUsername("guest");
            factory.setPassword("guest");
            //设置 RabbitMQ 地址
            factory.setHost("localhost");
            //建立到代理服务器到连接
            Connection conn = factory.newConnection();
            //获得信道
            Channel channel = conn.createChannel();
            //声明交换器
            String exchangeName = "hello-exchange";
            channel.exchangeDeclare(exchangeName, "direct", true);

            String routingKey = "hola";
            //发布消息
            byte[] messageBodyBytes = "quit".getBytes();
            channel.basicPublish(exchangeName, routingKey, null, messageBodyBytes);

            channel.close();
            conn.close();
        }
    }

    //消息消费者
    import com.rabbitmq.client.*;
    import java.io.IOException;
    import java.util.concurrent.TimeoutException;
    public class Consumer {

        public static void main(String[] args) throws IOException, TimeoutException {
            ConnectionFactory factory = new ConnectionFactory();
            factory.setUsername("guest");
            factory.setPassword("guest");
            factory.setHost("localhost");
            //建立到代理服务器到连接
            Connection conn = factory.newConnection();
            //获得信道
            final Channel channel = conn.createChannel();
            //声明交换器
            String exchangeName = "hello-exchange";
            channel.exchangeDeclare(exchangeName, "direct", true);
            //声明队列
            String queueName = channel.queueDeclare().getQueue();
            String routingKey = "hola";
            //绑定队列，通过键 hola 将队列和交换器绑定起来
            channel.queueBind(queueName, exchangeName, routingKey);

            while(true) {
                //消费消息
                boolean autoAck = false;
                String consumerTag = "";
                channel.basicConsume(queueName, autoAck, consumerTag, new DefaultConsumer(channel) {
                    @Override
                    public void handleDelivery(String consumerTag,
                                            Envelope envelope,
                                            AMQP.BasicProperties properties,
                                            byte[] body) throws IOException {
                        String routingKey = envelope.getRoutingKey();
                        String contentType = properties.getContentType();
                        System.out.println("消费的路由键：" + routingKey);
                        System.out.println("消费的内容类型：" + contentType);
                        long deliveryTag = envelope.getDeliveryTag();
                        //确认消息
                        channel.basicAck(deliveryTag, false);
                        System.out.println("消费的消息体内容：");
                        String bodyStr = new String(body, "UTF-8");
                        System.out.println(bodyStr);

                    }
                });
            }
        }
    }
7.RabbitMQ发送消息到MQ失败
（1）发送方确认机制
    消息发送到MQ那端以后，MQ会回一个确认收到的消息。
    配置：
        spring:
            rabbitmq:
                publisher-confirm-type: correlated  //打开消息确认（true是返回客户端，false是自动删除）
                listener:
                    simple:
                        retry:
                            enabled: true  //开启重试
                            max-attempts: 5     //最大重试次数
                            initial-interval: 3000      //重试时间间隔
    生产者代码中需要CorrelationData correlationData = new CorrelationData（UUID.randomUUID().toString）是用来做消息的唯一标识，同时打开消息确认后需要对
    rabbitTemplate多设置一个setConfirmCallback，参数是一个匿名类，消息确认成功或失败后的处理写在匿名类里。
    比如一条订单消息，当消息确认到达MQ确认后再行入库或者修改订单的节点状态，如果消息没有成功到达MQ可以进行一次记录或者将订单状态修改。
（2）事务机制
    AMQP协议提供了事务机制，在投递消息时开启事务支持，如果消息投递失败则回滚事务。这是同步操作，一条消息发送之后会使发送端阻塞，以等待RabbitMQ-Server的回应，
    之后才能继续发送下一条消息，生产者生产消息的吞吐量和性能都会大大降低。

    //自定义事务管理器
    @Configuration
    public class RabbitTransacation{
        @Bean
        public RabbitTransacationManager rabbitTransacationManager(ConnectionFactory connectionFactory){
            return new RabbitTransacationManager(connectionFactory);
        }

        @Bean
        public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory){
            return new RabbitTemplate(connectionFactory);
        }
    }

    //修改yml
    spring：
        rabbitmq：
            publisher-returns: true //消息在未被队列收到的情况下返回

    //开启事务支持
    rabbitTemplate.setChannelTransacted(true);

    //消息未接收时调用ReturnCallBack
    rabbitTemplate.setMandatory(true);

8.消息发送到MQ后，MQ宕机导致内存中的消息丢失
    消息在MQ中有可能发生丢失，就需要将队列和消息都进行持久化。
    持久化队列
        @Queue（value = "名字",durable = "false",autoDelete = "false"）
    持久化消息
        发送消息的时候将消息的deliveryMode设置为2，在SpringBoot中消息默认就是持久化。
9.消费者消费消息的时候，未消费完毕就出现了异常
    需要关闭自动确认，改为手动确认消息。打开手动确认消息确认之后，只要这条消息没有成功消费，无论中间是出现消费者宕机还是代码异常，只要断开连接之后这条消息还没有被
    消费那么这条消息就会被重新放入队列再次被消费。
    修改yml为手动签收模式
        spring:
            rabbitmq:
                simple:
                    acknowledge-mode: manual    //手动确认模式
                    prefetch: 1     //每次签收一条消息
    消费者手动签收