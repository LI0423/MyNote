缓存一致性
    强一致性：要求系统写入什么，读出来的就是什么，实现起来对系统性能影响大。
    弱一致性：约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久后数据能达到一致，但会尽可能保证到某个时间级别后数据能达到一致性状态。
    最终一致性：是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。

一、Cache-Aside Pattern（旁路模式）
1、读流程
    读的时候，先读缓存，缓存命中的话，直接返回数据。
    缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回相应。
2、写流程
    更新的时候，先更新数据库，然后再删除缓存。

二、Read-Through/Write-Through（读写穿透）
    读写穿透模式中，服务端把缓存作为主要数据存储，应用程序跟数据库缓存交互都是通过抽象缓存层完成的。
1、Read-Through
    从缓存读取数据，读到直接返回，如果读取不到就从数据库加载，写入缓存后再返回相应。
    Read-Through就是多了一层Cache-Provider，实际只是在Cache-Aside之上进行了一层封装，可以让程序代码变得更简洁，也减少数据源上的负载。
2、Write-Through
    在该模式下，当发生写请求时，也是由缓存抽象层完成数据源和缓存数据的更新。

三、Write Behind（异步缓存写入）
    Write Behind也是由Cache Provider来负责缓存和数据库的读写，但是只更新缓存，不直接更新数据库，通过批量异步的方式来更新数据库。
    这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用，适合频繁写的场景。


为什么不更新缓存而是删除缓存？
    如果同时有线程A和线程B进行更新操作，线程A先更新了数据库，线程B后更新了数据库，线程B更新了缓存，线程A更新了缓存，因为网络等原因线程B比线程A更早的更新了缓存，
    那么就出现了脏数据。
    如果是写数据库场景比较多，而读数据库场景比较少的业务，采用这种方案就会导致数据还没读到，缓存就被频繁的更新，浪费性能。
    如果写入数据库中的值并不是直接写入缓存的，需要经过复杂的计算，那么每次写入数据库后，都要再次经过计算写入缓存，浪费性能。

    如果业务简单，只是去数据库拿一个值写入缓存，那么更新缓存也是可以的，但是淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss。

先操作缓存还是先操作数据库？
    先删除缓存，再更新数据库
        如果同时有线程A进行更新操作，线程B进行查询操作，请求A先删除缓存，请求B发现缓存不存在，请求B去数据库查询得到旧值，请求B将旧值写入缓存，请求A将
        新值写入数据库。
        导致数据不一致的情形出现，如果没有给缓存设置过期时间，该数据永远都是脏数据。
    先更新数据库，再删除缓存
        如果同时有线程A进行查询操作，线程B进行更新操作，缓存刚好失效，请求A查询数据库得到一个旧值，请求B将新值写入数据库，请求B删除缓存，请求A将查到的
        旧值写入缓存。
        如果发生这种情况，会出现脏数据，但是发生这种情况的条件是，请求B的写数据操作比请求A的查询操作耗时短，才有可能使请求B删除缓存操作在请求A写入缓存
        操作之前。但是数据库读操作的速度是远大于写操作的，因此这种情况很难出现。

数据库和缓存强一致性如何实现？
    没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP，可以做到BASE理论中的最终一致性。
    最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致性的状态。本质是需要系统保证最终数据能够达到一致，而不需要实时
    保证系统数据的强一致性。
'缓存延时双删'
    先淘汰缓存，再写数据库，休眠1秒，再次淘汰缓存。
    如果同时有请求A进行更新操作，请求B进行查询操作，请求A先删除缓存，请求B未查询到缓存数据，请求A更新数据库，请求B去数据库中查询，请求A休眠，请求B将数据更新到缓存中，
    请求A休眠结束删除缓存数据。
    写请求的休眠时间应该在读数据库业务逻辑的耗时基础上，加几百毫秒，确保在读请求结束后，写请求可以删除读请求造成的缓存脏数据。
    如果使用的是mysql读写分离架构，休眠时间可以修改为在主从同步的延时时间上加上几百毫秒。
    也可以将第二次的删除进行异步操作，写的请求就不需要休眠，加大了吞吐量。

    在先删除缓存，再更新数据库的情况下，可以使用延时双删的策略，来保证脏数据只会存活一段时间，就会被准确的数据覆盖。在先更新数据库，再删缓存的情况下，缓存出现脏数据的
    情况虽然可能性极小，但也会出现。我们依然可以用延时双删策略，在请求A对缓存写入了脏的旧值之后，再次删除缓存。来保证去掉脏缓存。

删除缓存失败如何解决？
    重试机制
        消息队列：
            （1）更新数据库数据；
            （2）缓存因为种种问题删除失败；
            （3）将需要删除的key发送至消息队列；
            （4）自己消费消息，获得需要删除的key；
            （5）继续重试删除操作，直到成功
            该方案有一个缺点，对业务线代码造成大量的侵入。
        监听binlog：适用阿里开源的canal
            （1）更新数据库数据；
            （2）数据库会将操作信息写入binlog日志当中；
            （3）订阅程序提取出所需要的数据以及key；
            （4）另起一段非业务代码，获得该信息；
            （5）尝试删除缓存操作，发现删除失败；
            （6）将这些信息发送至消息队列；
            （7）重新从消息队列中获得该数据，重试操作。