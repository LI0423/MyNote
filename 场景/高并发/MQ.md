# 消息队列场景

## 如何解决消息队列的延时以及过期失效问题？

### 大量消息在MQ里积压

紧急扩容，具体操作步骤和思路如下：

1. 先修复consumer问题，确保恢复消费速度，然后将现有consumer停掉。
2. 新建一个topic，partition是原来的10倍，临时建立好原先10倍的queue数量。
3. 写一个临时分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue。
4. 临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据。
5. 当快速消费完积压数据后，得恢复原先部署的架构，重新用原先的consumer机器来消费消息。

### MQ中的消息过期失效了

RabbitMQ是可以设置过期时间的，也就是TTL。如果消息积压超过一定时间就会被RabbitMQ给清理掉。只能手动写程序，将丢失的那批数据一点一点查出来，然后重新灌入MQ里面去。

### MQ快写满了

1. 提高消费并行度

    绝大部分消息消费行为都属于IO密集型，即可能是操作数据库，或者调用RPC，这类消费行为的消费速度在于后端数据库或者外系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。如下修改消费并行度：

    - 同一个ConsumerGroup下，通过增加Consumer实例数量来提高并行度（需要注意的是超过订阅队列数的Consumer实例无效）。可以增加机器，或者在已有机器启动多个进程的方式。提高单个Consumer的消费并行线程，通过修改参数consumerThreadMin、consumerThreadMax实现。

2. 批量方式消费

    某些业务流程如果支持批量消费，则可以很大程度上提高消费吞吐量。例如订单扣款类应用，一次处理一个订单耗时1s，一次处理一个订单耗时1s，一次处理10个订单可能也只耗时2s，这样可以大幅提高消费的吞吐量，通过设置consumer的consumerMessageBatchMaxSize参数，默认是1，即一次只消费一条消息，例如设置为N，那么每次消费的消息数小于等于N。

3. 跳过非重要消息

    发生消息堆积时，如果消费速度一直追不上发送速度，如果业务对数据要求不高的话，可以丢弃不重要的消息。

4. 优化每条消息消费过程

## 如何保证消息幂等性

- 如果数据要写数据库，就先根据主键查一下，如果数据有了，就不插入了，采用update的方式。
- 如果数据要写缓存，那就直接set，天然幂等性。
- 给消息加一个全局唯一id，消费者消费的时候去redis里查一下是否被消费过了，如果没有消费过就进行数据处理，如果消费过了，就丢弃该数据。
- 基于数据库的唯一键来保证数据不会重复插入多条。

## 如何保证消息有序性

顺序会错乱的场景：

- RabbitMQ：一个queue，多个consumer。生产者想RabbitMQ里发送了三条数据，压入的是RabbitMQ的一个队列。三个消费者分别从MQ中消费这三条数据中的一条，结果消费者执行完成顺序与压入顺序不一致，导致消息消费错乱。

解决方案：

拆分多个queue，一个queue一个consumer，然后这个consumer内部用内存队列做排队，分发给不同的worker来处理。消费者不直接消费消息，而是将消息根据关键值进行哈希，哈希值相同的消息保存到相同的内存队列里。也就是说需要保证顺序的消息到了相同的内存队列，然后由唯一的worker去处理。

## 如何保证消息的可靠性传输

消息丢失的三种情况：

- 生产者丢失了数据
- 消息队列丢失了数据
- 消费者丢失了数据

### 生产者丢失了数据

生产者将数据发送到RabbitMQ的时候，可能数据在半路丢失，因为网络问题丢失。

解决办法：

选择RabbitMQ提供的事务功能。生产者发送数据前开启RabbitMQ事务，然后发送消息，如果消息没有被RabbitMQ接收到，那么生产者会收到异常报错，进行事务回滚，再重试发送消息；如果收到了消息，就可以提交事务。

但是开启事务机制之后，因为太耗性能会降低吞吐量。所以一般会采用开启confirm模式，生产者每次写消息都会分配一个唯一的id，然后如果写入了RabbitMQ中，RabbitMQ会回传一个ack消息。如果RabbitMQ没能处理这个消息，会回调一个nack接口，告诉生产者消息接收失败，可以重试发送。而且可以结合这个机制在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，就可以重新发送。

事务机制和confirm机制最大的不同在于，事务机制是同步的，提交事务后会阻塞，但是confirm机制是异步的，发送消息后可以继续发送下一个消息，然后RabbitMQ接收后会异步回调一个接口通知生产者消息接收到了。

客户端实现生产者confirm的3种方式：

- 普通confirm模式：每发送一条消息，调用waitForConfirms()方法，等待服务器端confirm，如果服务端返回false或者在一段时间内没返回，客户端可以进行消息重发。
- 批量confirm模式：每发送一批消息后，调用waitForConfirms()方法，等待服务端confirm。
- 异步confirm模式：提供一个回调方法，服务端confirm了一条或者多条消息后客户端会回调这个方法。

### RabbitMQ丢失了数据

RabbitMQ丢失数据必须开启RabbitMQ的持久化。消息写入后会持久化到磁盘，哪怕是RabbitMQ自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非RabbitMQ还没持久化数据，自己就挂了，可能导致少量数据丢失。

设置持久化的两个步骤：

- 创建queue的时候将其设置为持久化。可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里的数据。
- 发送消息的时候将消息的deliveryMode设置为2。就是将消息设置为持久化的，此时RabbitMQ就会将消息持久化到磁盘上去。

必须同时设置这两个持久化，RabbitMQ挂了再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。

### 消费者丢失了数据

消费者刚消费到，还没处理，进程挂掉了。RabbitMQ认为已经消费了，数据就会丢失。

解决办法：

选择Rabbit提供的ack机制。关闭RabbitMQ的自动ack，可以通过一个api来调用，每次处理完消息的时候，在程序里ack一次。如果还没处理完没有ack，RabbitMQ会认为还没处理完，这个时候RabbitMQ会把这个消息分配个别的consumer去处理，消息不会丢失。

消费者在声明队列的时候，可以指定noAck参数，当noAck=false，RabbitMQ会等待消费者显示发回ack信号后，才从内存（和磁盘，如果是持久化消息）中移去消息。否则一旦消息被消费者消费，RabbitMQ会在队列中立即删除。
