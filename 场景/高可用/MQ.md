# MQ的高可用性

## RabbitMQ

### 普通集群模式（无高可用性）

在多台机器上启动多个RabbitMQ实例，每台机器启动一个。创建的queue只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据（元数据可以认为是queue的一些配置信息，通过元数据，可以找到queue所在的实例）。消费的时候，如果连接到了另外一个实例，那么这个实例会从queue所在的实例上拉取数据过来。

没做到分布式，就是个普通集群。导致要么消费者每次随机连接一个实例然后拉取数据，要么固定连接queue所在的实例消费数据。前者有数据拉取的开销，后者有单实例性能瓶颈。

如果放queue的实例宕机了，会导致接下来其他实例无法从该实例拉取数据。如果开启了消息持久化，让RabbitMQ落地存储消息的话，数据不一定会丢，但是得等这个实例恢复才可以继续从该实例拉取数据。

### 镜像集群模式（高可用性）

这才是RabbitMQ的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上。每个RabbitMQ节点都有这个queue的一个完整镜像，包含queue的全部数据。每次写消息到queue的时候，都会自动把消息同步到多个实例的queue上。

这样任何一个节点宕机了，其他节点上还包含了这个queue的完整数据，别的consumer都可以到其他节点上去消费数据。但是性能开销比较大，消息需要同步到所有节点上，导致网络带宽压力和消耗很重。这个方案也不是分布式的实现，没有扩展性。如果某个queue的负载很重，加新的节点，新节点也包含了这个节点queue的所有数据，并没有办法线性扩展queue。

## Kafka

Kafka
