一、窗口函数
1.基本语法
    <窗口函数> over (partition by <用于分组的列名>
                    order by <用于排序的列名>)
    窗口函数包括专用窗口函数（rank,dense_rank,row_number等），聚合函数（sum,avg,count,max,min等）
    partition by 用来对表分组。
    order by 子句的功能是对分组后的结果进行排序，默认是升序。
    group by 分组汇总后改变了表的行数，一行只有一个类别。而partition by 和 rank 函数不会减少原表中的行数。
2.rank,dense_rank,row_number 的区别
    rank()：如果有并列情况，会占用下一个名次的位置，例如：1，1，1，4。
    dense_rank()：如果有并列的情况，不会占用下一个名次，例如：1，1，1，2。
    row_number()：会忽略并列的情况，例如：1，2，3，4。
3.聚合函数
    聚合函数用作窗口函数中，是对自身记录以及自身记录之上的所有数据进行计算。
    聚合函数作为窗口函数可以在每一行的数据里直观的看到截止到本行数据，统计数据是多少，对整体统计数据没影响。

二、SQL语法
1.WITH AS   
    也叫做子查询部分，可以定义一个SQL片段，该SQL片段会被整个SQL语句的可读性更高，也可以用在UNION ALL的不同部分，作为提供数据的部分。
    对与UNION ALL，使用WITH AS定义了一个UNION ALL语句，当该片段被调用2次以上，优化器会将该WITH AS短语所获取的数据放入一个Temp表中，
    [WITH <common_table_express> [ ,n]]
    <common_table_express>::=
            expression_name [(column_name [ ,n])]
        AS
            (CTE_query_definition)

三、Mysql大表优化

学习链接：  https://mp.weixin.qq.com/s/BMQC2oJlhLoeBDtveXgHpw

1.单表优化
（1）字段优化
    尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED。
    varchar的长度只分配真正需要的空间。
    使用枚举或整数代替字符串类型。
    尽量使用timestamp而非datetime。
    单表不要有太多字段，建议在20以内。
    避免使用null字段，很难查询优化且占用额外索引空间。
    用整型来存ip
（2）索引
    索引并不是越多越好，要根据查询有针对性的创建，考虑在where和order by命令上涉及的列建立索引，可根据explain来查看是否用了索引还是全表扫描。
    尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描。
    值分布很稀少的字段不适合建索引，例如“性别”这种只有两个值的字段。
    字符字段只建前缀索引。
（3）查询sql
    可通过开启查询慢日志来找出较慢的sql。
    不做列运算：select id where age + 1 = 10，任何对列的操作都将导致表扫描，包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至
等号右边。
    sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间。
    or 改写成in：or的效率是n级别，in的效率是log（n）级别，in的个数建议控制在200以内。
    避免在where子句中使用 != 或 <> 操作符，否则引擎将放弃使用索引而进行全表扫描。
    对于连续数据，使用 between 不用 in 。
（4）读写分离
（5）缓存
（6）垂直拆分
    垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、
把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数
一般情况下是相同的，只是字段不一样，使用主键关联。
    垂直拆分的优点是：
        可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)
        可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起
        数据维护简单
    缺点是：
        主键出现冗余，需要管理冗余列
        会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力
        依然存在单表数据量过大的问题（需要水平拆分）
        事务处理复杂
（7）水平拆分
    水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。
前面的表分区本质上也是一种特殊的库内分表库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL
服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决。
    水平拆分的优点是:
        不存在单库大数据和高并发的性能瓶颈
        应用端改造较少
        提高了系统的稳定性和负载能力
    缺点是：
        分片事务一致性难以解决
        跨节点Join性能差，逻辑复杂
        数据多次扩展难度跟维护量极大

三、MySQL索引
    索引是在存储引擎层实现的，而不是在服务器层实现的。
1、B+树
    B+树是一棵平衡二叉树，主索引的叶子节点冗余了完整的数据记录，叶子节点之间还是用指针相关联起来的，查找的时候在根节点进行二分查找，找到一个key所在的
    指针，然后在指针所指向的节点进行查找，直到查找到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的data。插入和删除操作会破坏平衡树的平衡性，
    在插入删除操作之后需要对树进行分裂、合并、旋转等操作。
2、哈希索引
    哈希索引能以O（1）的时间复杂度进行查找，但是失去了有序性，并且无法进行排序与分组和范围查询，只能进行精确查找。
    InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+Tree索引之上再创建一个哈希索引，这样就让B+Tree索引具有
    哈希索引的一些优点，比如快速的哈希查找。
3、全文索引
    MYISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等，查找条件使用MATCH AGAINST，而不是普通的WHERE。
4、空间存储索引
    MYISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有纬度来索引数据，可以有效地使用任意维度来进行组合查询。

四、InnoDB的MVCC实现机制
    MVCC是为了实现读-写冲突不加锁，读指的是快照读而不是当前读，当前读是一种加锁的操作，是悲观锁的实现。
1、什么是MVCC
    多版本并发控制，是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MVCC在InnoDB中的实现主要是为了提高
    数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

2、当前读和并发读
（1）当前读
    当前读就是像select lock in share mode(共享锁)，select for update；update，insert，delete（排他锁），读取的是记录的最新版本，读取时还要
    保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
（2）快照读
    快照读就是像不加锁的select操作就是快照读，即不加锁的非阻塞读，快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；快照读的实现是
    基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，那可能读到的不一定是最新的
    版本，有可能是之前的历史版本。

3、MVCC的实现原理
    主要是依赖记录中的3个隐式字段，undo日志，Read View来实现的。
（1）隐式字段
    DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引。 
    DB_TRX_ID 6byte，最近修改（修改/插入）事务ID：记录创建这条记录/最后一次修改该记录的事务ID
    DB_ROLL_PTR 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）。配合undo日志，指向上一个版本。
    DELETE_BIT 1byte，记录被更新或删除并不代表真的删除，而是删除flag变了。
（2）undo日志
    InnoDB把这些为了回滚而记录的这些东西称之为undo log。这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作时，不会记录
    用户相应的日志。
    Insert undo log：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键对应的记录删掉就好。
    Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
    Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，之后回滚时再把由这些内容组成的记录插入到表中。
        删除操作都只是设置一下老记录的DELETE_BIT，并不真正将过时的记录删除。
        InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己维护了一个read view（这个read view相当于
        系统中最老活跃事务的read view）；如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以
        被安全清除的。
    不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的首链就是最新的旧记录，链尾就是最早的旧记录。
（3）Read View（读视图）
    readview主要是用来做可见性判断的，即当我们某个事务执行快照读的时候，对该记录创建一个readview读视图，把它比作条件用来判断当前事务能够看到哪个版本的
    数据，既可能是当前最新的数据，也可能是该行记录的undo log里面的某个版本的数据。
    readview遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由read view维护），
    如果DB_TRX_ID跟readview的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出undo log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID，
    直到找到满足特定条件的DB_TRX_ID，这个所在的旧记录就是当前事务能看见的最新老版本。

五、一条SQL的执行过程
    首先执行器根据MySQL的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中，在数据被缓存到缓存池的同时，
    会写入undo log日志文件。更新的动作是在BufferPool中完成的，同时会将更新后的数据添加到redo log buffer中。完成以后就可以提交事务，在提交的同时会做以下
    三件事：将redo log buffer中的数据刷入到redo log文件中；将本次操作记录写入到bin log文件中；将bin log文件名字和更新内容在bin log中的位置记录到redo
    log中，同时在redo log最后添加commit 标记。
    