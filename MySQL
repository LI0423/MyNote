一、窗口函数
1.基本语法
    <窗口函数> over (partition by <用于分组的列名>
                    order by <用于排序的列名>)
    窗口函数包括专用窗口函数（rank,dense_rank,row_number等），聚合函数（sum,avg,count,max,min等）
    partition by 用来对表分组。
    order by 子句的功能是对分组后的结果进行排序，默认是升序。
    group by 分组汇总后改变了表的行数，一行只有一个类别。而partition by 和 rank 函数不会减少原表中的行数。
2.rank,dense_rank,row_number 的区别
    rank()：如果有并列情况，会占用下一个名次的位置，例如：1，1，1，4。
    dense_rank()：如果有并列的情况，不会占用下一个名次，例如：1，1，1，2。
    row_number()：会忽略并列的情况，例如：1，2，3，4。
3.聚合函数
    聚合函数用作窗口函数中，是对自身记录以及自身记录之上的所有数据进行计算。
    聚合函数作为窗口函数可以在每一行的数据里直观的看到截止到本行数据，统计数据是多少，对整体统计数据没影响。

二、SQL语法
1.WITH AS   
    也叫做子查询部分，可以定义一个SQL片段，该SQL片段会被整个SQL语句的可读性更高，也可以用在UNION ALL的不同部分，作为提供数据的部分。
    对与UNION ALL，使用WITH AS定义了一个UNION ALL语句，当该片段被调用2次以上，优化器会将该WITH AS短语所获取的数据放入一个Temp表中，
    [WITH <common_table_express> [ ,n]]
    <common_table_express>::=
            expression_name [(column_name [ ,n])]
        AS
            (CTE_query_definition)

2.SUM 和 CASE WHEN 组合使用
    sum(case when type = 1 then 1 when type = 2 then 1 ... end)
    计算某几种类型数据的总和。 

3.两个查询结果计算并转换为百分比形式
    select rate from (truncate(((select data from table where condition1 )/(select data from table where condition2))*100,2),'%') as rate

4.EXPLAIN 查询sql语句的执行计划
    explain select * from emp where name = 'Jefabc';
    （1）id：选择标识符。
        select的查询序列号，id相同时执行顺序由上至下；如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。id如果相同，可以认为是一组，从上往下执行。
    （2）select_type：查询中每个select子句的类型
        SIMPLE：简单select，不使用UNION或子查询等。
        PRIMARY：子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY。
        UNION：UNION中的第二个或后面的select语句。
        DEPENDENT UNION：UNION中的第二个或后面的select语句，取决于外面的查询
        UNION RESULT：UNION的结果，UNION语句中第二个select开始后面所有的select
    （3）table：数据库中表名称，显示这一行的数据是关于哪张表的
    （4）type：对表访问方式，标识MySQL在表中找到所需行的方式。
        ALL：Full Table Scan，MySQL将遍历全表以找到匹配的行。
        INDEX：Full Index Scan，遍历索引树
        RANGE：只检索给定范围的行，使用一个索引来选择行。
        ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。
        eq_ref：类似ref，使用的是唯一索引，对于每个索引键值，表中只有一条记录匹配，就是多表连接中使用primary key或unique key作为关联条件。
        const：表最多有一个匹配行，const用于比较primary key或者unique索引。
        system：表仅有一行，是const类型的特例。
        NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
    （5）possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用，如果没有任何索引显示为null。
        该列独立于EXPLAIN输出所示的表的次序，在possible_keys中的某些键实际上不能按生成的表次序使用。
    （6）key：显示MySQL实际决定使用的键（索引），必然包含在possible_keys中。
        如果没有选择索引，键是NULL，要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。
    （7）key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引长度（显示的值为索引字段的最大可能长度，并非实际使用长度，
    即key_len是根据定义计算而得，不是通过表内检索出的）。不损失精度的情况下，长度越短越好。
    （8）ref：列与索引的比较，表示表的连接匹配条件，哪些列或常量被用于查找索引列上的值。
    （9）rows：估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算找到所需的记录需要读取的行数。
    （10）extra：包含MySQL解决查询的详细信息。
        Using where：不用读取表中所有信息，仅通过索引仅可以获取所需数据，发生在对表的全部的请求列都是同一个索引的部分的时候，
            表示MySQL服务器将在存储引擎检索行后再进行过滤。
        Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。出现该值就表示sql需要优化了。
            MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，
            然后合并结果。EXPLAIN 结果中，第一行出现的表就是驱动表，对驱动表可以直接排序，对非驱动表（的字段排序）需要对循环查询的合并结果（临时表）进行排序。
        Using filesort：当Query中包含order by操作，而且无法利用索引完成的排序操作称为“文件排序”。
        Using join buffer：表示在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现该值，应该注意根据查询的具体情况可能需要天机索引来改进。
        Impossible where：强调了where语句会导致没有符合条件的行。
        Select table optimized away：意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行。
        

三、Mysql大表优化

学习链接：  https://mp.weixin.qq.com/s/BMQC2oJlhLoeBDtveXgHpw

1.单表优化
（1）字段优化
    尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED。
    varchar的长度只分配真正需要的空间。
    使用枚举或整数代替字符串类型。
    尽量使用timestamp而非datetime。
    单表不要有太多字段，建议在20以内。
    避免使用null字段，很难查询优化且占用额外索引空间。
    用整型来存ip
（2）索引
    索引并不是越多越好，要根据查询有针对性的创建，考虑在where和order by命令上涉及的列建立索引，可根据explain来查看是否用了索引还是全表扫描。
    尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描。
    值分布很稀少的字段不适合建索引，例如“性别”这种只有两个值的字段。
    字符字段只建前缀索引。
（3）查询sql
    可通过开启查询慢日志来找出较慢的sql。
    不做列运算：select id where age + 1 = 10，任何对列的操作都将导致表扫描，包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至
等号右边。
    sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间。
    or 改写成in：or的效率是n级别，in的效率是log（n）级别，in的个数建议控制在200以内。
    避免在where子句中使用 != 或 <> 操作符，否则引擎将放弃使用索引而进行全表扫描。
    对于连续数据，使用 between 不用 in 。
（4）读写分离
（5）缓存
（6）垂直拆分
    垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、
把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数
一般情况下是相同的，只是字段不一样，使用主键关联。
    垂直拆分的优点是：
        可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)
        可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起
        数据维护简单
    缺点是：
        主键出现冗余，需要管理冗余列
        会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力
        依然存在单表数据量过大的问题（需要水平拆分）
        事务处理复杂
（7）水平拆分
    水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。
前面的表分区本质上也是一种特殊的库内分表库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL
服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决。
    水平拆分的优点是:
        不存在单库大数据和高并发的性能瓶颈
        应用端改造较少
        提高了系统的稳定性和负载能力
    缺点是：
        分片事务一致性难以解决
        跨节点Join性能差，逻辑复杂
        数据多次扩展难度跟维护量极大

三、MySQL索引
    索引是在存储引擎层实现的，而不是在服务器层实现的。
1、B+树
    B+树是一棵平衡二叉树，主索引的叶子节点冗余了完整的数据记录，叶子节点之间还是用指针相关联起来的，查找的时候在根节点进行二分查找，找到一个key所在的
    指针，然后在指针所指向的节点进行查找，直到查找到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的data。插入和删除操作会破坏平衡树的平衡性，
    在插入删除操作之后需要对树进行分裂、合并、旋转等操作。
2、哈希索引
    哈希索引能以O（1）的时间复杂度进行查找，但是失去了有序性，并且无法进行排序与分组和范围查询，只能进行精确查找。
    InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+Tree索引之上再创建一个哈希索引，这样就让B+Tree索引具有
    哈希索引的一些优点，比如快速的哈希查找。
3、全文索引
    MYISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等，查找条件使用MATCH AGAINST，而不是普通的WHERE。
4、空间存储索引
    MYISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有纬度来索引数据，可以有效地使用任意维度来进行组合查询。

四、InnoDB的MVCC实现机制
    MVCC是为了实现读-写冲突不加锁，读指的是快照读而不是当前读，当前读是一种加锁的操作，是悲观锁的实现。
1、什么是MVCC
    多版本并发控制，是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MVCC在InnoDB中的实现主要是为了提高
    数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

2、当前读和并发读
（1）当前读
    当前读就是像select lock in share mode(共享锁)，select for update；update，insert，delete（排他锁），读取的是记录的最新版本，读取时还要
    保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
（2）快照读
    快照读就是像不加锁的select操作就是快照读，即不加锁的非阻塞读，快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；快照读的实现是
    基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，那可能读到的不一定是最新的
    版本，有可能是之前的历史版本。

3、MVCC的实现原理
    主要是依赖记录中的3个隐式字段，undo日志，Read View来实现的。
（1）隐式字段
    DB_ROW_ID 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引。 
    DB_TRX_ID 6byte，最近修改（修改/插入）事务ID：记录创建这条记录/最后一次修改该记录的事务ID
    DB_ROLL_PTR 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）。配合undo日志，指向上一个版本。
    DELETE_BIT 1byte，记录被更新或删除并不代表真的删除，而是删除flag变了。
（2）undo日志
    InnoDB把这些为了回滚而记录的这些东西称之为undo log。这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作时，不会记录
    用户相应的日志。
    Insert undo log：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键对应的记录删掉就好。
    Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
    Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，之后回滚时再把由这些内容组成的记录插入到表中。
        删除操作都只是设置一下老记录的DELETE_BIT，并不真正将过时的记录删除。
        InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己维护了一个read view（这个read view相当于
        系统中最老活跃事务的read view）；如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以
        被安全清除的。
    不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的首链就是最新的旧记录，链尾就是最早的旧记录。
（3）Read View（读视图）
    readview主要是用来做可见性判断的，即当我们某个事务执行快照读的时候，对该记录创建一个readview读视图，把它比作条件用来判断当前事务能够看到哪个版本的
    数据，既可能是当前最新的数据，也可能是该行记录的undo log里面的某个版本的数据。
    readview遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由read view维护），
    如果DB_TRX_ID跟readview的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出undo log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID，
    直到找到满足特定条件的DB_TRX_ID，这个所在的旧记录就是当前事务能看见的最新老版本。

4、基于ReadView实现可重复读
    事务A第一次读完，事务B要修改这行数据，undolog会为所有写操作生成日志，所以就会生成一条undo log日志，roll_pointer会指向上一条undo log日志。第一次读
    的时候，开启事务A的时候就生成一个ReadView，当事务A第二次去读这条数据时，先查到的是事务B修改的那条数据，会发现现在的 DB_TRX_ID 比最小的事务ID大，有
    可能是读不到的，回去当前活跃事务列表查询是否有这条事务记录，如果有那说明在事务A开启事务的时候，这个事务是没有提交的，修改的数据就不应该被读到，顺着回滚
    指针往下找，找到之前的一条记录，发现可以读到，数值与第一次结果一致。

五、一条SQL的执行过程
    首先执行器根据MySQL的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中，在数据被缓存到缓存池的同时，
    会写入undo log日志文件。更新的动作是在BufferPool中完成的，同时会将更新后的数据添加到redo log buffer中。完成以后就可以提交事务，在提交的同时会做以下
    三件事：将redo log buffer中的数据刷入到redo log文件中；将本次操作记录写入到bin log文件中；将bin log文件名字和更新内容在bin log中的位置记录到redo
    log中，同时在redo log最后添加commit 标记。
    
六、MySQL宕机时数据不丢失的原理
    MySQL在更新数据时，为了减少磁盘的随机IO，因此并不会直接更新磁盘上的数据，而是先更新Buffer Pool中缓存页的数据，等到合适的时间点，再将这个缓存页持久化到磁盘。
    而Buffer Pool中所有缓存都是处于内存当中的，当MySQL宕机或者机器断电，内存中的数据就会丢失。当进行增删操作时，MySQL会在更新Buffer Pool中的缓存页数据时，
    会记录一条对应操作的redo log日志，当出现宕机或者断电时，如果有缓存页的数据还没来得急刷入磁盘，当MySQL重新启动时，可以根据redo log日志文件进行数据重做，
    将数据恢复到宕机或者断电前的状态，保证了更新的数据不丢失，因此redolog叫做重做日志，本质是保证事务提交后更新的数据不丢失。
    redo log中记录的是对物理磁盘上某个表空间的某个数据页的某一行数据的某个字段做的修改，修改后的值是多少。redolog日志文件是持久化在磁盘上的，磁盘上可以有多个
    redo log 文件，默认有两个文件，每个文件大小为48MB。
1、如何保证数据不丢失
（1）Mysql Server层的执行器调用InnoDB存储引擎的数据更新接口；
（2）存储引擎更新Buffer Pool中的缓存页；
（3）同时存储引擎记录一条redo log到redo log buffer中，并将该条redo log的状态标记为prepare状态；
（4）接着存储引擎告诉执行器，可以提交事务了，执行器接到通知后会写binlog日志，然后提交事务；
（5）存储引擎接到提交事务的通知后，将redo log的日志状态标记为commit状态；
（6）接着根据innodb_flush_log_at_commit参数的配置，决定是否将redo log buffer中的日志刷入磁盘。

2、两阶段事务提交
    将redolog 日志标记为prepare和commit状态，这种就是两阶段事务提交。redolog在进行重做的时候，只有读到了commit标识，才会认为这条redo log日志是完整的，
    才会进行数据重做，否则会认为这条redo log日志不完整，不会进行数据重做。

七、BinLog日志
    binlog日志是记录所有数据库表结构变更以及表数据修改的二进制日志文件，不会记录select和show这类操作。
1、使用场景
（1）主从复制：在主库中开启Binlog功能，主库可以把Binlog传递给从库，从库拿到Binlog后实现数据恢复达到主从数据一致性。
（2）数据恢复：通过mysql binlog工具来恢复数据。

2、文件记录模式
（1）Row
    日志记录每一行数据被修改的情况，然后在slave端对相同数据进行修改。
    优点：能清楚记录每一个行数据的修改细节，能完全实现主从数据同步和数据的恢复。
    缺点：批量操作，会产生大量的日志，尤其是alter table会让日志暴涨。
（2）Statement
    每一条被修改数据的SQL都会记录到master的Binlog中，slave在复制的时候SQL进程会解析成和原来master端执行过的相同的SQL再次执行。
    优点：日志量小，减少磁盘IO，提升存储和恢复速度。
    缺点：在某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数。
（3）Mixed
    以上两种模式的混合使用，一般会使用Statement模式保存binlog，对于statement模式无法复制的操作使用row模式保存binlog，mysql会根据执行的sql语句选择写入模式。

3、Binlog写入机制
    常见的log event有：Query event、Row event、Xid event等。binlog 文件的内容就是各种Log event的集合。
（1）根据记录模式和操作触发event事件生成log event（事件触发执行机制）
（2）将事务执行过程中产生log event写入缓冲区，每个事务线程都有一个缓冲区。
    log event保存在一个binlog_cache_mngr数据结构中，在该结构中有两个缓冲区，一个是stmt_cache，用与存放不支持事务的信息；另一个是trx_cache，用于存放支持事务的信息。
（3）事务在提交阶段会将产生的log event写入到外部binlog文件中。
    不同事务以串行方式将log event写入binlog文件中，所以一个事务包含的log event信息在binlog文件中是连续的，中间不会插入其他事务的log event。

4、Redo Log 和 BinLog 区别
（1）Redo Log属于InnoDB引擎功能，Binlog属于MySQL Server自带功能，以二进制记录。
（2）Redo Log属于物理日志，记录该数据页更新状态内容，BinLog是逻辑日志，记录更新过程。
（3）Redo Log日志是循环写，日志空间大小是固定的，BinLog是追加写入，写完一个写下一个，不会覆盖使用。
（4）Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有Crash-safe能力。
    （Crash-safe即在InnoDB存储引擎中，事务提交过程中任何阶段，MySQL突然崩溃，重启后都能保证事务的完整性，已提交的数据不会丢失，未提交完整的数据会自动回滚。这个能力依赖的
    是redo log 和undo log两个日志）

八、B+树和B树的区别
1、B+树内节点不存储数据，所有data存储在叶节点导致查询时间复杂度固定为O(logn)，而B树每个节点都有key和data，查询时间复杂度不固定，与key在树中的位置有关，最好为O(1)。
2、B+树节点两两相连，而且在磁盘里是顺序存储的，当读到某个值的时候，磁盘预读原理会提前把这些数据读进内存，可大大增加区间访问性，可使用在范围查询等，而B树每个节点key和data
    在一起，无法区间查找。
    （空间局部性原理：如果一个存储器的某个位置被访问，那么它附近的位置也会被访问。）
3、B+树更适合外部存储。由于节点内无data域，每个节点能索引的范围更大更精确。
    由于B树的节点内部每个key都带有data，而B+树只存key的副本，真实的key和data都存在叶子结点上。磁盘是分block的，一次磁盘IO会读取若干个block，磁盘IO的大小是固定的，在
    一次IO中，单个元素越小，量就越大。也就是B+树单词IO的信息量大于B树，能读出的索引值更。