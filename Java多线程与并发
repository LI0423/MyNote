Java多线程与并发

1.为什么需要多线程
 （1）CPU增加了缓存，用来均衡与内存的速度差异；//导致“可见性”问题
 （2）操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；//导致“原子性”问题
 （3）编译程序优化指令执行次序，使缓存能够得到更加合理地利用。//导致“有序性”问题

2.并发三要素：
 （1）可见性：一个线程对共享变量的修改，另一个线程能够立刻看到。
 （2）原子性：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 （2）有序性：程序执行的顺序按照代码的先后顺序执行。

3.线程使用
 （1）实现Runnable接口
    public class MyThread implements Runnable{
        public void run(){
            //...
        }
    }

    public static void main(String[] args){
        MyThread thread = new MyThread();
        Thread run = new Thread(instance);
        run.start();
    }
 （2）实现Callable接口
    public class MyCallable implements Callable{
        public void call(){
            return 123;
        }
    }

    public static void main(String[] args){
        MyCallable mc = new MyCallable();
        FutureTask<Integer> ft = new FutureTask<>(mc);
        Thread thread = new Thread(ft);
        thread.start(); 
    }
 （3）继承Thread类
    public class MyThread extends Thread{
        public void run(){
            //...
        }
    }

    public static void main(String[] args){
        MyThread mt =new MyThread();
        mt.start();
    }

4.基础线程机制
 （1）Executor
    主要有三种Executor：
    CachedThreadPool：一个任务只创建一个线程；
    FixedThreadPool：所有任务只能使用固定大小的线程；
    SingleThreadExecutor：相当于大小为1的FixedThreadPool。

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i++) {
            executorService.execute(new MyRunnable());
        }
        executorService.shutdown();
    }
5.synchronized详解
    Monitorenter和MonitorExit会让对象在执行使其锁计数器加一或者减一。每一个对象在同一时间只与一个Monitor相关联，一个monitor在同一时间只能被一个线程获取，
    一个对象在尝试获得与这个对象相关联的Monitor时，会发生三种情况之一：
    （1）monitor计数器为0时，就是目前还没有被获得，线程会立刻获得，然后计数器+1，别的线程想要获得时就要等待。
    （2）线程已经拿到这个锁的所有权，又重入这把锁，锁计数器就会累加，变为2，并随着累加的次数一直累加。
    （3）这把锁已经被别的线程获取了，等待锁释放。
6.JVM锁的优化
    （1）锁粗化：减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。
    （2）锁消除：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程贡献的数据的锁的保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的
    分配（同时减少Heap上的垃圾收集开销）。意思就是JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM会把他们当作栈上数据对待，认为这些数据
    是线程独有的，不需要加同步。
    （3）轻量级锁：
    （4）偏向锁：为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令。
            当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作了加锁和解锁，只需要测
        试下对象头的Mark Word里是否存储着指向当前线程的偏向锁。偏向锁使用了一种等待竞争才会释放锁的机制，当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。
        偏向锁的撤销需要等到全局安全点（当前线程没有正在执行的字节码）。首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否还活着，如果线程处于不活动状态，直接
        将对象头设置为无锁状态，如果还活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态活着标记对象不适合作为偏向锁。
    （5）适应性自旋锁：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁前会进入忙等，然后再次尝试，当尝试一定的次数后如果仍然
    没有成功与该monitor关联的semaphore（互斥锁）进入到阻塞状态。
            如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到
        100次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。
7.volatile
    