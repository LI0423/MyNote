Java多线程与并发

1.为什么需要多线程
 （1）CPU增加了缓存，用来均衡与内存的速度差异；//导致“可见性”问题
 （2）操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；//导致“原子性”问题
 （3）编译程序优化指令执行次序，使缓存能够得到更加合理地利用。//导致“有序性”问题

2.并发三要素：
 （1）可见性：一个线程对共享变量的修改，另一个线程能够立刻看到。
 （2）原子性：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 （2）有序性：程序执行的顺序按照代码的先后顺序执行。

3.线程使用
 （1）实现Runnable接口
    public class MyThread implements Runnable{
        public void run(){
            //...
        }
    }

    public static void main(String[] args){
        MyThread thread = new MyThread();
        Thread run = new Thread(instance);
        run.start();
    }
 （2）实现Callable接口
    public class MyCallable implements Callable{
        public void call(){
            return 123;
        }
    }

    public static void main(String[] args){
        MyCallable mc = new MyCallable();
        FutureTask<Integer> ft = new FutureTask<>(mc);
        Thread thread = new Thread(ft);
        thread.start(); 
    }
 （3）继承Thread类
    public class MyThread extends Thread{
        public void run(){
            //...
        }
    }

    public static void main(String[] args){
        MyThread mt =new MyThread();
        mt.start();
    }

4.基础线程机制
 （1）Executor
    主要有三种Executor：
    CachedThreadPool：一个任务只创建一个线程；
    FixedThreadPool：所有任务只能使用固定大小的线程；
    SingleThreadExecutor：相当于大小为1的FixedThreadPool。

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i++) {
            executorService.execute(new MyRunnable());
        }
        executorService.shutdown();
    }
    
5.synchronized详解
    Monitorenter和MonitorExit会让对象在执行使其锁计数器加一或者减一。每一个对象在同一时间只与一个Monitor相关联，一个monitor在同一时间只能被一个线程获取，
    一个对象在尝试获得与这个对象相关联的Monitor时，会发生三种情况之一：
    （1）monitor计数器为0时，就是目前还没有被获得，线程会立刻获得，然后计数器+1，别的线程想要获得时就要等待。
    （2）线程已经拿到这个锁的所有权，又重入这把锁，锁计数器就会累加，变为2，并随着累加的次数一直累加。
    （3）这把锁已经被别的线程获取了，等待锁释放。

6.JVM锁的优化
    （1）锁粗化：减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。
    （2）锁消除：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程贡献的数据的锁的保护，通过逃逸分析也可以在线程本地Stack上进行对象空间的
    分配（同时减少Heap上的垃圾收集开销）。意思就是JVM会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM会把他们当作栈上数据对待，认为这些数据
    是线程独有的，不需要加同步。
    （3）轻量级锁：
    （4）偏向锁：为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令。
            当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作了加锁和解锁，只需要测
        试下对象头的Mark Word里是否存储着指向当前线程的偏向锁。偏向锁使用了一种等待竞争才会释放锁的机制，当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。
        偏向锁的撤销需要等到全局安全点（当前线程没有正在执行的字节码）。首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否还活着，如果线程处于不活动状态，直接
        将对象头设置为无锁状态，如果还活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态活着标记对象不适合作为偏向锁。
    （5）适应性自旋锁：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁前会进入忙等，然后再次尝试，当尝试一定的次数后如果仍然
    没有成功与该monitor关联的semaphore（互斥锁）进入到阻塞状态。
            如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到
        100次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

7.Thread.sleep()和Object.wait()的区别 
    Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁； 
    Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去； 
    Thread.sleep()到时间了会自动唤醒，然后继续执行； 
    Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒； 
    Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁； 
    其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。

8.Thread.sleep()和LockSupport.park()的区别 
    LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。 
    从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源； 
    Thread.sleep()没法从外部唤醒，只能自己醒过来； 
    LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒； 
    Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出； 
    LockSupport.park()方法不需要捕获中断异常； 
    Thread.sleep()本身就是一个native方法； 
    LockSupport.park()底层是调用的Unsafe的native方法；

9.Object.wait()和LockSupport.park()的区别 
    Object.wait()方法需要在synchronized块中执行； 
    LockSupport.park()可以在任意地方执行； 
    Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出； 
    LockSupport.park()不需要捕获中断异常； 
    Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容； 
    LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容； 
    如果在wait()之前执行了notify()会怎样? 抛出IllegalMonitorStateException异常； 
    如果在park()之前执行了unpark()会怎样? 线程不会被阻塞，直接跳过park()，继续执行后续内容；

10.ThreadLocal如何实现线程隔离
    主要是用到了Thread对象中的一个ThreadLocalMap类型的变量threadLocals，负责存储当前线程的关于Connection的对象，dbConnectionLocal这个变量为key，以新建的Connection
    对象为value，线程第一次读取的时候如果不存在就会调用ThreadLocal的initialValue方法创建一个Connection对象并且返回。
    首先获取当前线程对象，然后从线程对象中获取到ThreadLocalMap的成员属性threadLocals。如果当前线程的threadLocals已经初始化（即不为null）并且存在以当前ThreadLocal对象
    为key的值，则直接返回当前线程要获取的对象。如果当前线程的threadLocals已经初始化（即不为null）但是不存在以当前ThreadLocal对象为key的对象，重新创建一个对象，并添加到当前
    线程threadLocals中并返回。如果当前线程的threadLocals属性还没有被初始化，则重新创建一个ThreadLocalMap对象，并且创建一个对象并添加到ThreadLocalMap对象中并返回。

11.ThreadLocal造成内存泄露的问题
    用线程池来操作ThreadLocal对象确实会造成内存泄露，因为对于线程池里面不会销毁的线程，里面总会存在着<ThreadLocal,LocalVariable> 的强引用，因为final static修饰ThreadLocal
    并不会释放，而ThreadLocalMap对于key虽然是弱引用，但是强引用不会释放，弱引用当然也会一直有值，同时创建的LocalVariable对象也不会释放，就造成了内存泄露；如果LocalVariable
    对象不是一个大对象的话，其实泄露的并不严重，泄露的内存=核心线程数*LocalVariable对象的大小。

12.手写死锁


13.如何避免死锁
（1）打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
（2）打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源无法满足，则退出原占有的资源。
（3）打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待。
（4）打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。