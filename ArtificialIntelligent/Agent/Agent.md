# Agent

## 核心思想

从“函数”到“智能体”的范式转变。

传统程序是一个函数：输入 -> 处理 -> 输出。被动执行，没有内部状态和主动性。

Agent是智能体：

- 主动性：有自己的目标，会为了达成目标而主动采取行动。
- 感知性：能持续地从环境中获取信息（用户输入、API返回、传感器数据）。
- 自主性：能够独立判断在何种情况下应该采取何种行动，而无需人工每一步干预。
- 持续性：通常在循环中运行，保持对话或任务的状态，直到目标达成或会话终止。

## 经典架构：ReAct与其他变体

### ReAct：Reasoning + Acting

- Thought / Reasoning：Agent思考当前的状况。在这一步中Agent会分析现状、分解问题、制定下一步计划。基于：
  - 最终目标
  - 历史记录
  - 当前环境
  - 可用工具
- Act / Action：Agent根据思考结果，执行一个动作。
  - 调用一个工具
  - 向用户提出一个问题以澄清需求。
- Observation：Agent观察行动结果，将其作为新的信息输入到下一个循环的“思考”中。

### 其他常见模式

- Plan-and-Execute：Agent先制定完整的计划（步骤1，2，3...），然后按计划执行。适合步骤清晰、依赖关系明确的任务。
- Reflection：在行动后，引入一个“反思”步骤，评估行动结果的好坏，并决定是继续、修正还是重试。这对于复杂任务和自我改进至关重要。

## 关键组件设计

### 大脑——大型语言模型

负责所有的推理、决策、规划和内容生成。

### 工具——能力扩展

赋予Agent超越文本的能力，使其能够与世界互动。

- 设计思路：
  - 标准化定义：使用统一的格式描述工具。描述应包括工具名称、描述、参数（JSON Schema）。
  - 丰富与专一性：工具库尽可能丰富（网络搜索、计算器、数据库查询、代码执行、API调用等），每个工具的功能尽可能单一和专注。
  - 安全性：对工具调用（特别是写操作、代码执行）要有严格的控制权限和沙盒环境。

### 记忆——状态管理

- 短期记忆/对话记忆：
  - 作用：记住当前会话中发生的事情（用户消息、AI回复、工具调用结果）。
  - 实现：通常通过维护一个消息列表来实现，并作为上下文传递给LLM。
  - 问题：上下文窗口有限，需要做摘要或选择性记忆。
- 长期记忆/向量数据库：
  - 作用：存储跨越多个会话的、重要的信息，供未来检索。
  - 实现：将关键信息向量化后存入向量数据库，遇到相关问题时，从中检索相关信息作为上下文。
- 工作记忆/思维链：
  - 在ReAct循环中，保存当前的计划、已执行的动作和观察结果，整个循环的历史。

### 规划与反思——高级认知

- 规划：在开始行动前，让Agent先输出一个计划大纲。可以通过提示工程（“让我们一步步思考”）或专门的任务分解工具来实现。
- 反思：
  - 作用：让Agent批判性地评估自己行动的结果和质量。
  - 实现：在关键节点或任务结束时，让LLM作为一个“审查者”，回答诸如“这个结果正确吗？”“有没有更好的方法？”“我犯了什么错误？”等问题，并根据反思结果决定下一步行动（如重试、修正）。
