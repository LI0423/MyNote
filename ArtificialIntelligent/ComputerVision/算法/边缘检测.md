# 边缘检测

## 原理

边缘的本质是图像亮度（灰度）发生剧烈变化的地方。在数学上是通过导数或梯度来度量的。

通过计算图像的梯度，找到梯度幅值很大的像素点，这些点就是潜在的边缘点。

## 经典算法实现

### Sobel算子

Sobel算子在计算一阶导的同时，引入了加权平均，对噪声有一定的抑制作用。

- 卷积核
  - X方向：检测垂直边缘
    $$
    G_x=\begin{bmatrix}
    -1 & 0 & 1 \\
    -2 & 0 & 2 \\
    -1 & 0 & 1
    \end{bmatrix}
    $$
  - Y方向：检测水平边缘
    $$
    G_y=\begin{bmatrix}
    -1 & -2 & -1 \\
    0 & 0 & 0 \\
    1 & 2 & 1
    \end{bmatrix}
    $$
- 计算过程：
  1. 用$G_x$与图像进行卷积，得到X方向的梯度图$I_x$。
  2. 用$G_y$与图像进行卷积，得到Y方向的梯度图$I_y$。
  3. 计算每个像素点的梯度幅值：$G=\sqrt{(I_x^2 + I_y^2)}$。
  4. 设定一个阈值，幅值大于该阈值的点被认为是边缘。

### Prewitt算子

- 卷积核
  - X方向：检测垂直边缘
    $$
    G_x=\begin{bmatrix}
    -1 & 0 & 1 \\
    -1 & 0 & 1 \\
    -1 & 0 & 1
    \end{bmatrix}
    $$
  - Y方向：检测水平边缘
    $$
    G_y=\begin{bmatrix}
    -1 & -1 & -1 \\
    0 & 0 & 0 \\
    1 & 1 & 1
    \end{bmatrix}
    $$

### Laplacian算子

一个二阶导数算子，直接使用一个卷积核来近似计算二阶导数。对噪声非常敏感，可以同时检测出边缘的方向。

- 核心思想：寻找图像中二阶导数为0的点（零交叉点）。
- 常用卷积核：
  - 4邻域
  $$
    \begin{bmatrix}
    0 & 1 & 0 \\
    1 & -4 & 1 \\
    0 & 1 & 0
    \end{bmatrix}
  $$
  - 8邻域
  $$
    G_x=\begin{bmatrix}
    1 & 1 & 1 \\
    1 & -8 & 1 \\
    1 & 1 & 1
    \end{bmatrix}
  $$

## 先进算法：Canny边缘检测器

### 步骤

1. 高斯滤波（去噪）
   - 边缘检测对噪声很敏感。首先使用一个高斯滤波器对图像进行平滑处理。高斯核的大小和标准差（$\delta$）是可控参数，$\delta$越大，图像越模糊，能抑制更多噪声，但边缘定位也会变差。

2. 计算梯度强度和方向
   - 使用Sobel等算子（通常是Sobel）计算每个像素在X和Y方向的梯度（$I_x$，$I_y$）。
   - 计算梯度幅值：$G=\sqrt{(I_x^2 + I_y^2)}$
   - 计算梯度方向：$\theta=\arctan2(I_y, I_x)$，并将其归整到0、45、90、135四个方向之一。

3. 非极大值抑制
   - 在梯度方向上，检查当前像素的梯度幅值是否是局部最大值。
     - 如果一个像素的梯度方向是$\angle90$（垂直边缘），那么就比较上方和下方像素的梯度幅值。
     - 如果当前像素的幅值是从这三个点中最大的，则保留；否则将其抑制（置为0）。
   - 边缘带会从多个像素宽度“细化”为单像素宽度。

4. 双阈值检测与边缘连接
    - 使用两个阈值（高阈值和低阈值）来分类边缘像素。
    - 强边缘：梯度幅值>高阈值。这些是确定的边缘点。
    - 弱边缘：低阈值<梯度幅值<高阈值。可能是边缘，也可能是噪声，需要进一步判断。
    - 非边缘：梯度幅值<低阈值。直接丢弃。
    - 边缘连接：对于弱边缘像素，只有当连接到某个强边缘像素时（即在它的8邻域内存在强边缘像素），才被认定为真正的边缘并保留下来，否则将被抑制。

## 代码示例

```python
import cv2
import numpy as np
from matplotlib import pyplot as plt


image = cv2.imread('image.jpg')
gray = cv2.cvtColor(image, cv2.COLOR_GBR2GRAY)

# 1. sobel 边缘检测
sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3) # 计算x方向梯度
sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3) # 计算y方向梯度
sobel_combined = cv2.magnitude(sobelx, sobely) # 计算梯度幅值
sobel_combined = np.uint8(sobel_combined)

# 2. Laplacian 边缘检测
laplacian = cv2.Laplacian(gray, cv2.CV_64F, ksize=3)
laplacian = np.unit8(np.absolute(laplacian))

# 3. Canny 边缘检测（最常用）
canny_edges = cv2.Canny(gray, 50, 150)

# 显示结果
images = [gray, sobel_combined, laplacian, canny_edges]
titles = ['Original', 'Sobel', 'Laplacian', 'Canny']

plt.figure(figsize=(12, 8))
for i in range(4):
    plt.subplot(2, 2, i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.axis('off')
plt.tight_layout()
plt.show()
```
