# ByteTrack跟踪算法

ByteTrack是一种基于“跟踪-检测（tracking-by-detection）”范式的多目标跟踪算法，其核心思想是在高置信度检测框（High Score Detections）和低置信度检测框（Low Score Detections）之间做两阶段关联，从而既能抑制误检，又能在部分遮挡或漏检情况下丢失目标。

## 处理流程

### 目标检测

- 使用单阶段或两阶段检测器对每一帧图像进行检测，得到一组检测框及其置信度分数。
- 将检测结果按置信度分为：
  - 高置信度集 $D_H$：分数 >= 高阈值(如0.5)。
  - 低置信度集 $D_L$：低阈值 <= 分数 < 高阈值（如0.1 <= score < 0.5）。

### 卡尔曼滤波预测（Kalman Prediction）

- 对每个在跟踪列表中的已有轨迹（Track）使用卡尔曼滤波预测其在当前帧的位置和尺度（state=x,y,s,r,...）。
- 得到一组预测状态集合 $T_p$。

### 第一阶段关联：高分检测框与轨迹

- 计算预测轨迹 $T_p$ 与高置性度检测框DH之间的代价矩阵，通常用IOU距离，1-IoU或中心点距离加权形式。
- 使用匈牙利算法或基于阈值的两端排序进行匹配，得到匹配对（ $T^H_p$， D^M_H）。
- 对于匹配上的轨迹：
  - 用对应高分检测框更新卡尔曼滤波器（Measurement Update）
  - 刷新轨迹的生命周期（age，hits，time_since_update等）
- 对未匹配的预测轨迹保留到下一步，未匹配的高分检测框则视为新的候选轨迹（New Track，初始化一个新的卡尔曼滤波器实例）。

### 第二阶段关联：低分检测框补偿

- 对第一阶段未匹配上的轨迹，再次与低置信度检测框 $D_L$ 进行关联，方法同上（IoU + 匈牙利）。
- 此步骤主要用于恢复因遮挡、漏检等导致暂时丢失但实际仍在场景中的目标。
- 对匹配上的轨迹，同样用低分框更新滤波器并刷新生命周期；匹配后的低分框不再用于新轨迹初始化。

### 轨迹管理

- 激活（Activate）：对于新初始化的轨迹，只有在连续多帧（例如n=3）被高分检测匹配到，才能正式加入输出列表，减少假正例。
- 删除（Terminate）：如果轨迹在连续若干帧（如max_age=30）都没有任何匹配（high/low都未匹配），则认为该目标已经离开场景，从跟踪列表中删除。
- 丢失（Lost）：对于短暂漏检的轨迹，允许在一定帧数内通过低分关联或后续高分重新拾回。

### 输出结果

- 对所有“激活”且未被删除的轨迹，输出它们在本帧的边界框及TrackID。

## ByteTrack相较于传统方法的优势

- 充分利用低置性度检测框：在第一阶段只用高分框保证精准度，通过第二阶段补偿降低漏检。
- 简单高效：仅基于标准的卡尔曼滤波+匈牙利匹配，无需复杂的外观特征或重识别网络。
- 鲁棒性强：对于人群遮挡、运动模糊等情况的漏检恢复能力更好。

## 匈牙利匹配算法在ByteTrack中的计算过程

### 准备两个对象集合

A：当前Track列表（预测框）
B：当前帧的Detection列表（检测框）

### 计算代价矩阵（距离矩阵）

ByteTrack使用的距离是 1-IoU：

- IoU越大表示两个框越重合，越可能是同一个目标
- 所以我们定义代价为1-IoU，使得IoU大就变成代价小。

最终构建一个MxN的代价矩阵cost_matrix，其中：

- 行：M个Track。
- 列：N个Detection。
- 每个元素是该对候选的IOU距离（1-IOU）。

### 调用匈牙利算法求最优匹配

ByteTrack通过如下方法调用匈牙利算法（实际上是Scipy实现）：
  matched_indices = linear_sum_assignment(cost_matrix)

它返回两个数组（等长）：

- matched_row_indices：选中的Track索引。
- matched_col_indices：匹配的Detection索引。

意味着Track[i] -> Detection[j]，其中 $(i,j)$ 的组合，总是在代价最小（整体匹配最优）前提下的最佳选择。

### 筛选合法匹配（过滤IOU过小的）

ByteTrack还会设置一个阈值match_thresh：

- 只有IOU >= match_thresh的匹配才保留；
- 否则认为“不是同一个目标”，这个Track会进入Lost状态。

### 更新状态

- 匹配上的轨迹 -> 使用检测结果更新其状态和位置（卡尔曼融合）
- 没匹配上的轨迹 -> 被认为丢失，转入 lost_stracks
- 没匹配上的检测框 —> 保留用于后续补充（或新轨迹初始化）

## IOU算法在ByteTrack中的作用场景

### 计算距离矩阵用于匈牙利算法匹配

- 在每一帧中，ByteTrack会将预测的轨迹框（Track）与检测框（Detection）进行一一比较，计算IOU。
- 然后用1-IOU作为“代价矩阵”传入匈牙利算法，进行全局匹配。

### 过滤匹配结果

- 如果IOU太小（比如<0.6），即使匈牙利算法匹配上了，ByteTrack也会丢弃这对匹配。
- 原因是；重合度太小，可能不是同一个目标，避免误匹配。
