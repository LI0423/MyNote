# MySQL事务

## 事务特性

- 原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性（Consistency）：执行事务前后，数据保持一致。
- 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
- 持久性（Durability）：一个事务被提交后，它对数据库中数据的修改是持久的，即使数据库发生故障，也不应该对其有任何影响。

只有保证了事务的原子性、隔离性、持久性，才能保证一致性。A、I、D是手段，C是目的。

## 并发事务产生的问题

### 修改丢失（Lost to modify）

在一个事务读取数据并对这个数据进行了修改，但是另一个事务也读取了该数据并且进行了修改，导致第一个事务对该数据的修改丢失。因此称为丢失修改。

### 脏读（Dirty read）

一个事务读取数据并且对数据进行了修改，这个修改对其他事务是可见的，即使这个事务没有提交。这时另外一个事务读取了这个还未提交的数据，但是第一个事务突然回滚，导致数据修改没有被提交到数据库，那么第二个事务读取到的数据就是脏数据。

### 不可重复读（Unrepeatable read）

指在一个事务中多次读取数据。在一个事务访问数据时，另一个事务也读取了该数据，并且对数据进行了修改，当第一个事务再次读取数据时，两次读取的数据可能不一致。因此称为不可重复读。

### 幻读（Phantom read）

幻读与不可重复读类似。发生在一个事务读取了几行数据，接着另一个事务并发插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的数据，好像发生了幻觉一样。因此称为幻读。

## 事务隔离级别

SQL标准定义了四种隔离级别，用来平衡事务的隔离性和并发性能。事务隔离级别越高，数据一致性越好，但并发性能可能越低。

1. READ-UNCOMMITED（读未提交）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读、不可重复读。
2. READ-COMMITED（读提交）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读、不可重复读无法避免。
3. REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据被事务本身所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。MySQL的InnoBD存储引擎的事务隔离级别就是可重复读。InnoDB存储引擎使用MVCC+Next-key-Lock在很大程度上解决了幻读。
4. SERIALIZABLE（串行化）：最高的隔离级别，完全服从ACID隔离级别。所有的事务依次逐个执行，这样事务之间就不能产生干扰。该级别可以防止脏读、幻读、不可重复读。
