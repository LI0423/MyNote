# Redis主从架构

一主多从，主负责写，并且将数据复制到其他的slave节点，从节点负责读。所有的读请求走从节点。

## 核心原理

当启动一个slave node的时候，它会发送一个PSYNC命令给master node。

如果是slave node初次连接到master node，那么会触发一次full resynchronized全量复制。此时master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端client新收到的所有写命令缓存在内存中。RDB文件生产完毕后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中的写命令发送到slave，slave也会同步这些数据。slave node如果跟master node有网络故障，断开了连接，会自动重连，连接后master node仅会复制给slave部分缺少的数据。

### 主从复制断点续传

Redis支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从口开始复制一份。

master node会在内存中维护一个backlog，master和slave都会保存一个replica offset还有一个master run id，offset就是保存在backlog中的。如果master 和 slave 网络断开重连了，slave会让master从上次 replica offset 开始继续复制，如果没有找到对应的offset，那么就会执行一次resynchronization。

### 无磁盘化复制

master在内存中直接创建RDB，然后发送给slave，不会在自己本地落盘了。只需要在配置文件中开启repl-diskless-sync yse即可。

### 过期key处理

slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。

## 复制的完整流程

1. slave node启动时，会在自己本地保存master node的信息，包括master node的host和ip，但是复制流程还没开始。
2. slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现就跟master node建立socket网络连接。
3. slave node发送ping命令给master node。如果master设置了requirepass，那么slave node必须发送masterauth的口令过去进行认证。
4. master node第一次执行全量复制，将所有数据发送给slave node。
5. 而在后续，master node持续将写命令，异步复制给slave node。

### 全量复制

- master执行bgsave，在本地生成一份rdb快照文件。
- master node将rdb快照文件发送给slave node，如果rdb复制时间超过60秒（repl-timeout），那么slave node会认为复制失败。
- master node在生成rdb时，会将所有新的写命令缓存在内存中，在slave node保存了rdb之后，再将新的写命令复制给slave node。
- 如果在复制期间，内存缓冲区持续消耗超过64MB，或者一次性超过256MB，那么停止复制，复制失败。
- slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中。在清空旧数据之前，slave node依然会基于旧的数据版本对外提供服务。
- 如果slave node开启了AOF，那么会立即执行BGREWRITEAOF，重写AOF。

### 增量复制

- 如果全量复制过程中，master-slave网络连接断掉，那么slave重新连接master时，会触发增量复制。
- master直接从自己的backlog中获取部分丢失的数据，发送给slave node，默认backlog就是1MB。
- master就是根据slave发送的psync中的offset来从backlog中获取数据的。

### heartbeat

主从节点互相都会发送heartbeat信息。master默认每隔10秒发送一次heartbeat，slave node每隔1秒发送一个heartbeat。

### 异步复制

master每次接收到写命令后，先在内部写入数据，然后异步发送给slave node。
