# Redis常见阻塞原因

## O(n)命令

Redis中的大部分命令都是O(1)时间复杂度，但也有少部分O(n)时间复杂度的命令。例如：

- keys *：会返回所有符合规则的key。
- HGETALL：会返回一个Hash中所有的键值对。
- LRANGE：会返回List中指定范围内的元素。
- SMEMBERS：返回Set中的所有元素。
- ……

## SAVE创建快照

- save：同步保存操作，会阻塞Redis主线程。
- bgsave：fork出一个子进程，子进程执行，不会阻塞Redis主线程，默认选项。

默认情况下，Redis默认配置会使用bgsave命令。如果手动使用save命令生成RDB快照文件的话，就会阻塞主线程。

## AOF

AOF记录日志是在Redis主线程中进行的。

## AOF刷盘阻塞

当吼他线程（aof_fsync线程）调用fsync函数同步AOF文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致fsync操作发生阻塞，主线程调用write函数时也会被阻塞。fsync完成后，主线程执行write才能成功返回。

## AOF重写阻塞

## 大Key

如果一个key对应的value所占用的内存较大，那么这个key就可以看作是bigkey。String类型的value超过1MB；复合类型（列表、哈希、集合、有序集合等）的value包含的元素超过5000个（对于复合类型的value来说，不一定包含的元素越多，占用的内存就越多）。

- 客户端超时阻塞：由于Redis执行命令是单线程处理，然后在操作大key时会比较耗时，那么就会阻塞Redis，在客户端看来就是很久没有响应。
- 引发网络阻塞：每次获取大key产生的网络流量较大，如果一个key的大小是1MB，每秒访问量为1000，那么每秒会产生1000MB的流量。
- 阻塞工作线程：如果使用del删除大key时，会阻塞工作线程，就没办法处理后续的命令。

## 删除大Key

删除操作的本质是要释放键值对占用的内存空间。

释放内存只是第一步，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块链表，以便后续进行管理和再分配。这个过程需要时间而且会阻塞当前释放内存的应用程序。如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成Redis主线程的阻塞，如果主线程发生阻塞，其他所有请求可能都会超时，超时越多，会造成Redis连接耗尽。

## 清空数据库

和删除大Key一样，flushdb、flushall也涉及到删除和释放所有的键值对。

## 集群扩容

## Swap（内存交换）

## CPU竞争

Redis是CPU密集型应用，不建议和其他多核CPU密集型服务部署在一起。当其他进程过度消耗CPU时，将严重影响Redis的吞吐量。
