# Redis哨兵

## 主要功能

- 集群监控：负责监控Redis master和slave进程是否正常工作。
- 消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
- 故障转移：如果master node挂掉了，会自动转移到slave node上。
- 配置中心：如果故障转移发生了，通知client客户端新的master地址。

故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到分布式选举问题。

## 核心

- 哨兵至少需要3个实例，来保证自己的健壮性。
- 哨兵+Redis主从的部署架构，是不保证数据零丢失的，只能保证Redis集群的高可用性。

## 哨兵主备切换的数据丢失问题

### 异步复制导致的数据丢失

master -> slave的复制是异步的，可能有部分数据还没复制到slave，master就宕机了，此时这部分数据就丢失了。

### 脑裂导致的数据丢失

某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接， 但是实际上master还运行着。此时哨兵就会认为master宕机了，然后开启选举，其他slave切换成了master。这时候集群里就会有两个master，也就是所谓的脑裂。

此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续向旧master写数据。因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据。而新的master并没有后来client写入的数据，因此这部分数据也就丢失了。

### 数据丢失问题的解决方案

配置文件中配置：

min-slaves-to-write 1
min-slaves-max-lag 10

要求至少有1个slave，数据复制和同步的延迟不能超过10秒。如果所有的slave，数据复制和同步的延迟都超过了10秒，那么master就不会再接收任何请求了。

确保一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低到可控范围内。

如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保，如果不能继续给指定数量的slave发送数据，而且slave超过十秒没有给自己ack消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下最多丢失10秒的数据。

## sdown和odown转换机制

- sdown是主观宕机，就一个哨兵自己觉得master宕机了，那么就是主观宕机。
- odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机。

sdown达成的条件很简单，如果一个哨兵ping一个master，超过了 is-master-down-after-milliseconds指定的毫秒数后，就主观认为master宕机了；如果一个哨兵在指定时间内，收到了quorum数量的其他哨兵也认为那个master是sdown的，那么就认为是odown了。

## 哨兵集群的自动发现机制

哨兵互相之间的发现是通过Redis的pub/sub机制来实现的，每个哨兵都会往__sentinel__:hello这个channel里发送一个消息，所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵存在。

每隔两秒，每个哨兵都会往自己监控的某个master+slaves对应的__sentinel__:hello这个channel里发送一个消息，内容是自己的host、ip和runid还有对这个master的监控配置。

每个哨兵也会去监听自己监控的每个master+slaves对应的__sentinel__:hello这个channel，然后去感知同样在监听这个master+slaves的其他哨兵的存在。

每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。

## slave配置的自动纠正

哨兵会负责自动纠正slave的一些配置，比如slave如果要成为潜在的master候选人，哨兵会确保slave复制现有master的数据；如果slave连接到了一个错误的master上，比如故障转移之后，那么哨兵会确保它们连接到正确的master上。

## slave->master选举算法

如果一个master被认为odown了，而且majority数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来，会考虑slave的一些信息：

- 跟master断开连接的时长
- slave优先级
- 复制offset
- run id

如果一个slave跟master断开连接的时间已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master。

然后对slave进行排序：

- 按照slave优先级进行排序，slave priority越低，优先级就越高。
- 如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。
- 如果上面两个条件都相同，那么选择一个run id比较小的那个slave。

## quorum和majority

每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到majority哨兵的授权，才能正式执行切换。

如果quorum < majority，比如5个哨兵，majority就是3，quorum设置为2，那么3个哨兵授权就可以执行切换。

如果quorum >= majority，那么必须quorum数量的哨兵都授权，比如5个哨兵，quorum是5，那么必须5个哨兵都同意授权，才能执行切换。

## configuration epoch

哨兵会对一套Redis master+slaves进行监控，有相应的监控的配置。

执行切换的那个哨兵，会从要切换到的新master（slave->master）那里得到一个configuration epoch，这就是一个version号，每次切换version号都必须是唯一的。

如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch，作为新的version号。
