yum -y install ipvsadm*



nat模式：
1、首先规划服务器：
nat外网使用桥接模式，nat内网使用hostonly
以下是hostonly下的地址：
客户机为windows本身，假设地址为172.20.10.3
natds 192.168.137.44 主机名：lvs-nat（该机器还有一块桥接网卡，地址假设为172.20.10.3）
natr1 192.168.137.53 主机名：r1-nat
natr2 192.168.137.54 主机名：r2-nat
2、配置netds：
echo 1 > /proc/sys/net/ipv4/ip_forward #开启路由管道 也就是说机器变成了路由器 各网卡之间可以通信
ipvsadm -C
#rr轮循
#m为nat模式
ipvsadm -A -t 172.20.10.3:80 -s rr
ipvsadm -a -t 172.20.10.3:80 -r 192.168.137.53:8080 -m
ipvsadm -a -t 172.20.10.3:80 -r 192.168.137.54:8080 -m
3、配置natr1、natr2：
route del default
route add default gw 192.168.137.44 #配置lvs为网关
route -n #查看网关

tun模式：
1、首先规划服务器：
tunds 192.168.137.60 主机名：lvs-tun
tunr1 192.168.137.61 主机名：r1-tun
tunr2 192.168.137.62 主机名：r2-tun
vip 192.168.137.65
2、配置tunds：
echo "1" > /proc/sys/net/ipv4/ip_forward
ifconfig tunl0 192.168.137.65 broadcast 192.168.137.65 netmask 255.255.255.255 up #tunl0是隧道协议
#配置为255.255.255.255的原因是使其和eth0网卡的第一个ip不在一个网段，也就是说192.168.137.0和192.168.137.65不是一个网段
route add -host 192.168.137.65 dev tunl0  #路由器如果不加入这句话强制加入ip，路由可能会误认为其是192.168.137.0网段，这样路由看到目标ip是192.168.137.65后就不会走eth0网卡
ipvsadm -C
#-A是转换 -t是tcp协议 -s是算法 -r是实体机 -g是dr模式，也是隧道模式(本来应该-i是隧道模式，但是不work)
ipvsadm -A -t 192.168.137.65:80 -s rr
ipvsadm -a -t 192.168.137.65:80 -r 192.168.137.61 -g
ipvsadm -a -t 192.168.137.65:80 -r 192.168.137.62 -g
ipvsadm -L -n  #打印lvs列表
3、配置tunr1、tunr2：
route del default #删除网关
ifconfig tunl0 192.168.137.65 broadcast 192.168.137.65 netmask 255.255.255.255 up
route add -host 192.168.137.65 dev tunl0
#1表示apr忽略vip、2表示apr宣告真实ip
echo "1" > /proc/sys/net/ipv4/conf/tunl0/arp_ignore
echo "2" > /proc/sys/net/ipv4/conf/tunl0/arp_announce
echo "1" > /proc/sys/net/ipv4/conf/all/arp_ignore
echo "2" > /proc/sys/net/ipv4/conf/all/arp_announce

dr模式：
1、首先规划服务器：
drds 192.168.137.59 主机名：lvs-dr
drr1 192.168.137.63 主机名：r1-dr
drr2 192.168.137.64 主机名：r2-dr
vip 192.168.137.66
2、配置drds：
echo "1" > /proc/sys/net/ipv4/ip_forward
ifconfig eth0:0 192.168.137.66 netmask 255.255.255.255 up
route add -host 192.168.137.66 dev eth0:0
ipvsadm -C
ipvsadm -A -t 192.168.137.66:80 -s rr
ipvsadm -a -t 192.168.137.66:80 -r 192.168.137.63 -g #g为dr模式
ipvsadm -a -t 192.168.137.66:80 -r 192.168.137.64 -g
3、配置drr1、drr2：
ifconfig lo:0 192.168.137.66 netmask 255.255.255.255 up #注意不能配置成eth0:0，否则配置apr忽略和宣告会对eth0生效，那就乱套了
route add -host 192.168.137.66 dev lo:0
#arp_ignore arp忽略 arp_announce arp宣告
echo "1" > /proc/sys/net/ipv4/conf/lo/arp_ignore  
echo "2" > /proc/sys/net/ipv4/conf/lo/arp_announce 
echo "1" > /proc/sys/net/ipv4/conf/all/arp_ignore
echo "2" > /proc/sys/net/ipv4/conf/all/arp_announce



LVS的10个调度算法
1. 大锅饭调度(Round-Robin Scheduling RR)
rr - 纯轮询方式，比较垃圾。把每项请求按顺序在真正服务器中分派。
2. 带权重的大锅饭调度(Weighted Round-Robin Scheduling WRR)
wrr -带权重轮询方式。把每项请求按顺序在真正服务器中循环分派，但是给能力较大的服务器分派较多的作业。
3. 谁不干活就给谁分配(Least-Connection LC)
lc - 根据最小连接数分派
4. 带权重的谁不干活就给谁分配（Weighted Least-Connections WLC 默认）
wlc - 带权重的。机器配置好的权重高。
5. 基于地区的最少连接调度(Locality-Based Least-Connection Scheduling LBLC)
lblc - 缓存服务器集群。基于本地的最小连接。把请求传递到负载小的服务器上。
6. 带有复制调度的基于地区的最少连接调度(Locality-Based Least-Connection Scheduling with Replication Scheduling LBLCR)
lblcr - 带复制调度的缓存服务器集群。某页面缓存在服务器A上，被访问次数极高，而其他缓存服务器负载较低，监视是否访问同一页面，如果是访问同一页面则把请求分到其他服务器。
7. 目标散列调度(Destination Hash Scheduling DH)
realserver中绑定两个ip。ld判断来者的ISP商，将其转到相应的IP。
8. 源散列调度(Source Hash Scheduling SH)
源地址散列。基于client地址的来源区分。（用的很少）
9. 最短的期望的延迟（Shortest Expected Delay Scheduling SED）
基于wlc算法。这个必须举例来说了
ABC三台机器分别权重123 ，连接数也分别是123。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用sed算法后会进行这样一个运算
A:（1+1)/1
B:（1+2)/2
C:（1+3)/3
根据运算结果，把连接交给C 。
个人理解的算法是(1+当前连接数)/权重。
10.最少队列调度（Never Queue Scheduling NQ）
无需队列。如果有台realserver的连接数＝0就直接分配过去，不需要在进行sed运算。



arp_ignore和arp_announce内核参数:

arp_announce : INTEGER
默认为0
对网络接口上本地IP地址发出的ARP回应作出相应级别的限制:
确定不同程度的限制,宣布对来自本地源IP地址发出Arp请求的接口
0 - (默认) 在任意网络接口上的任何本地地址
1 -尽量避免不在该网络接口子网段的本地地址. 当发起ARP请求的源IP地址是被设置应该经由路由达到此网络接口的时候很有用.此时会检查来访IP是否为所有接口上的子网段内ip之一.如果改来访IP不属于各个网络接口上的子网段内,那么将采用级别2的方式来进行处理.
2 - 对查询目标使用最适当的本地地址.在此模式下将忽略这个IP数据包的源地址并尝试选择与能与该地址通信的本地地址.首要是选择所有的网络接口的子网中外出访问子网中包含该目标IP地址的本地地址. 如果没有合适的地址被发现,将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送
all/ 和{interface}/ 下两者同时比较，取较大一个值生效.
提高约束级别有益于从指定的目标接受应答,而降低级别可以给予更多的arp查询者以反馈信息(关于arp代理这一段我普遍翻译地不好，去啃一下tcp/ip bible的卷一，然后再翻译吧)

arp_ignore : INTEGER
默认为0
定义对目标地址为本地IP的ARP询问不同的应答模式
0 - (默认值): 回应任何网络接口上对任何本地IP地址的arp查询请求（比如eth0=192.168.0.1/24,eth1=10.1.1.1/24,那么即使eth0收到来自10.1.1.2这样地址发起的对10.1.1.1 的arp查询也会回应--而原本这个请求该是出现在eth1上，也该有eth1回应的）
1 - 只回答目标IP地址是来访网络接口本地地址的ARP查询请求（比如eth0=192.168.0.1/24,eth1=10.1.1.1/24,那么即使eth0收到来自10.1.1.2这样地址发起的对192.168.0.1的查询会回答，而对10.1.1.1 的arp查询不会回应）
2 -只回答目标IP地址是来访网络接口本地地址的ARP查询请求,且来访IP必须在该网络接口的子网段内（比如eth0=192.168.0.1/24,eth1=10.1.1.1/24,eth1收到来自10.1.1.2这样地址发起的对192.168.0.1的查询不会回答，而对192.168.0.2发起的对192.168.0.1的arp查询会回应）
3 - 不回应该网络界面的arp请求，而只对设置的唯一和连接地址做出回应(do not reply for local addresses configured with scope host,only resolutions for global and link addresses are replied 翻译地似乎不好，这个我的去问问人)
4-7 - 保留未使用
8 -不回应所有（本地地址）的arp查询
all/ 和{interface}/ 下两者同时比较，取较大一个值生效.


tcpdump使用
tcpdump -i eth0 -vv

route del -net 192.168.137.0 netmask 255.255.255.0 dev eth0
