1.分布式事务定义
    分布式事务就是指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点上。
2.CAP   
    C：数据一致性
    A：可用性
    P：分区容忍性
    在分布式系统中，P是必然的，如果不选P，一旦发生分区错误，整个分布式系统就完全无法使用了，只能当分布式系统发生错误时，如何选择一致性和可用性。
    当一套系统在发生分区故障后，客户端的任何请求都被卡死或者超时，但是系统的每个节点总是会返回一致的数据，这套系统就是CP系统，比如zookeeper。
    当一套系统在发生分区故障后，客户端依然可以访问系统，但是获取的数据有的是新的数据，有的是老数据，这套系统就是AP系统，比如eureka。
3.CP+HA
    分布式事务是CP+HA，其中A是没有完全符合，但是能够达到Highly-Available，即高可用。CP+HA意味着不是BASE，只要写入成功，接下来的读能够读取到
    最行的结果，不用担心读取到的不是最新数据，在多副本读写上与单机是一致的。
4.分布式事务解决方案
（1）两阶段提交/XA
    XA规范主要定义了（全局）事务管理器（TM）和（局部）资源管理器（RM）之间的接口，本地的数据库如MySQL扮演的是RM角色。
    第一阶段（prepare）：所有的参与者RM准备执行事务并锁住需要的资源，参与者ready时，向TM报告已准备就绪。
    第二阶段（commit/rollback）：当事务管理者（TM）确认所有参与者（RM）都ready后，向所有参与者发送commit命令。
    成功完成的XA事务例子：
        经典的转账问题，A需要转100给B，那么需要A的余额减去100，B的余额加上100，整个转账要保证成功。
        1.AP/应用程序开启全局事务
        2.AP/应用程序调用TransOut。
        3.微服务1在TM/事务管理器上注册子事务。
        4.微服务1进行本地prepare。
        5.AP/应用程序调用TransIn。
        6.微服务2在事务管理器上注册子事务。
        7.微服务2进行本地prepare。
        8.AP/应用程序上报全部prepare成功。
        9.TM/事务管理器通知TransOut提交。
        10.微服务1进行本地提交。
        11.TM/事务管理器通知TransIn提交。
        12.微服务2进行本地提交。
    如果有任何一个参与者prepare失败，TM会通知所有完成prepare的参与者进行回滚。
    特点：
        简单易理解，开发较容易。
        对资源进行了长时间的锁定，并发度低。

（2）SAGA
    将长事务拆分成多个本地短事务，由SAGA事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。
    成功完成的SAGA事务时序图：
        1.AP/应用程序提交SAGA事务含微服务1的TransOut和微服务2的TransIn 到TM/事务管理器
        2.TM/事务管理器调用微服务1TransOut，如果返回成功
        3.TM/事务管理器调用微服务2TransIn，如果返回成功
        4.TM/事务管理器全局事务成功
    Saga一旦到了Cancel阶段，那么Cancel在业务逻辑上是不允许失败了。如果因为网络或者其他临时故障，导致没有返回成功，那么TM会不断重试，直到Cancel返回成功。
    特点：
        并发度高，不用像XA事务那样长期锁定资源。
        需要定义正常操作以及补偿操作，开发量比XA大。
        一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况。
（3）TCC（Try-Confirm-Cancel）
    Try阶段：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性）
    Confirm阶段：确认执行真正执行业务，不做任何作业检查，只使用Try阶段预留的业务资源，Confirm操作要求具备幂等设计，Confirm失败后需要进行重试。
    Cancel阶段：取消执行，释放Try阶段预留的业务资源。Cancel阶段的异常和Confirm阶段异常处理方案基本上一致，要求幂等设计。

    以转账作为例子，通常会在Try里面冻结金额，但不扣款，Confirm里扣款，Cancel里解冻资金。
    成功完成的TCC事务例子：
        1.AP/应用程序在TM/事务管理器上注册全局事务
        2.AP/应用程序在TM/事务管理器上注册分支TransOut
        3.AP/应用程序调用微服务1TransOut Try
        4.AP/应用程序在TM/事务管理器注册分支TransIn
        5.AP/应用程序调用微服务2TransIn Try
        6.AP/应用程序向TM/事务管理器提交全局事务
        7.TM/事务管理器调用微服务1TransOut Confirm
        8.TM/事务管理器调用微服务2TransIn Confirm
        9.TM/事务管理器全局事务成功
    TCC的Confirm/Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM会不断的重试，直到Confirm/Cancel返回成功。
    特点：
        并发度较高，无长期资源锁定。
        开发量较大，需要提供Try/Confirm/Cancel接口。
        一致性较好，不会发生已扣款最后又转账失败的情况。
        TCC适用于订单类业务，对中间状态有约束的业务。

（4）本地消息表
    设计核心是将需要分布式处理的任务通过消息的方式来异步确保执行。写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么全部成功，要么全部失败。
    适用于可异步执行的业务，且后续操作无须回滚的业务。

    大致流程：
        扣减余额事务：
        （1）扣减A的余额；
        （2）写本地消息表；
        （3）提交事务；
        （4）轮询生产消息，发送给消息队列。
        （5）消费消息；
        增加余额事务：
        （6）增加B的余额；
        （7）提交事务；
        （8）删除消息。
    容错机制：
        扣减余额事务失败时，事务直接回滚，无后续步骤。
        轮询产生消息失败，增加余额事务失败都会进行重试。
    特点：
        不支持回滚。
        轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难。

（5）事务消息
    事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题。适用于可异步执行的业务，且后续操作无需回滚的业务。
    事务消息发送及提交：
        发送消息（half消息）
        服务端存储消息，并响应消息的写入结果
        根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）
        根据本地事务状态执行Commit或者RollBack（Commit操作发布消息，消息对消费者不可见）
    正常发送流程：
        扣减余额事务：
        （1）发送半消息
        （2）扣减A的余额
        （3）提交事务
        （4）发送commit消息
        （5）消费消息
        增加余额事务：
        （6）增加B余额
        （7）提交事务
        （8）删除消息
    补偿流程：
        对没有Commit/RollBack的事务消息（pending状态的消息），从服务端发起一次“回查”Producer收到回查消息，返回消息对应的本地事务状态，为Commit或者RollBack
        事务消息方案与本地消息表机制非常类似，区别主要对应于在原先相关的本地表操作替换成一个反查接口。
    特点：
        长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单。
        事务消息的回查没有好的方案，极端情况可能出现数据错误。
（6）二阶段消息

