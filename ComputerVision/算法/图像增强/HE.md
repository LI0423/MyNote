# 直方图均衡化（Histogram Equalization，HE）

直方图均衡化是一种全局对比度增强技术，通过对整幅图像的灰度分布进行线性拉伸，使输出图像的灰度直方图尽可能趋于均匀分布，从而提升亮部和暗部的整体对比度。适合对比度低、亮度分布集中的图像，如夜景、暗光拍摄照片。

## 核心原理

通过一个变换函数，将原始图像中的灰度级r映射到一个新的灰度级s。这个变换函数基于原始图像的累积分布函数。

## 数学原理与步骤

1. 计算原始直方图
   - 统计每个灰度级k出现的像素个数nk。
   - 计算每个灰度级出现的概率：$p_r(k) = \frac{nk}{N}$。$p_r(k)$ 表示灰度级k出现的概率。
2. 计算累积分布函数
   - 计算灰度级k的累积分布函数：$CDF(k) = \sum_{j=0}^{k} p_r(j) = \sum_{j=0}^{k} (\frac{nj}{N})$
   - $CDF(k)$ 表示灰度值小于等于 $k$ 的所有像素出现的概率之和。是一个单调递增的函数，范围在[0,1]之间。
3. 应用变换函数（映射）：
   - 使用累积分布函数 $CDF(k)$ 作为变换函数的基础，计算新的灰度级$s_k$：$s_k = T(k) = round((L-1) * CDF(k))$
   - 解释：
     - $(L - 1)$：目标灰度范围的最大值（例如255）。
     - $CDF(k)$：原始图像中灰度级小于等于 $k$ 的像素所占的比例（累积概率）。
     - $(L - 1) * CDF(k)$：将累积概率映射到 $[0, L-1]$ 的范围内。例如，如果 $CDF(k)=0.25$，$L=256$，则 0.25 * 255 ≈ 63.75。
     - $round(...)$：对计算结果进行四舍五入取整，得到新的离散灰度级 $s_k$（在 $[0, L-1]$ 内）。
4. 生成新图像：
   - 遍历原始图像的每一个像素。
   - 对于原始像素灰度值k，使用步骤三中计算好的映射关系$s_k = T(k)$，将其替换为新的灰度值$s_k$。
   - 所有像素处理完毕后，即得到直方图均衡化后的图像。

## 优点

- 简单有效：算法原理清晰，实现简单，计算效率高。
- 自动增强对比度：无需手动调整参数，即可显著提高图像的全局对比度。
- 揭示隐藏细节：对于过暗或过亮的图像，能有效显示出原本难以看清的细节。

## 缺点与局限性

- 噪声放大：如果原始图像包含噪声，均衡化过程可能会同时放大这些噪声的对比度，使噪声变得更明显。
- 过度增强：可能导致某些区域的对比度增强过度，看起来不自然或损失细节（特别是在原本较亮的区域可能变得过饱和）。
- 全局性：标准的直方图均衡化是全局操作，它对图像的所有区域应用相同的变换。不考虑像素的空间位置信息，因此可能对局部区域的对比度改善效果不佳，甚至降低局部对比度。
- 彩色图像：直接对RGB图像的每个通道分别进行均衡化会破坏色彩平衡（因为三个通道的变换不同），导致不自然的颜色偏移（色偏）。处理彩色图像通常有两种方法：
  - 转换为HSV/HSI/Lab颜色空间：仅对亮度（V/I/L）通道进行均衡化，保持色度（H/S/ab）通道不变，再转回RGB空间。
  - 对RGB通道独立均衡：效果通常较差，会产生严重色偏。
- 无法恢复丢失的信息：如果原始图像中某个亮度范围完全没有信息（例如严重曝光不足导致一片死黑），均衡化无法凭空创造出这些细节，只能拉伸现有的信息。

## 代码示例

```Python
def histogram_equalization(img):
    channels_res = [cv2.equalizeHist(channel) for channel in cv2.split(img)]
    return cv2.merge(channels_res)
```
