一、单例模式
    1.定义
        指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
    2.特点
        单例类只有一个实例对象；该单例对象必须由单例类自行创建；单例类对外提供一个访问该单例的全局访问点。
    3.优缺点
    （1）优点：
        单例模式可以保证内存里只有一个实例，减少内存开销。
        可以避免对资源的多重占用。
        设置全局访问点，可以优化和共享访问资源。
    （2）缺点：
        单例模式一般没有接口，扩展困难。如果要扩展，除了修改原来的代码没有第二种途径。
    3.实现
    （1）懒汉式单例
        类加载时没有生成单例，只有当第一次调用getInstance方法时才去创建这个单例。

        public class LazySingleton{
            private static volatile LazySingleton instance = null;
            private LazySingleton(){
                //private 避免类在外部被实例化
            }

            public static synchronized LazySingleton getInstance(){
                if (instance == null){
                    instance = new LazySingleton();
                }
                return instance;
            }
        }
    
    （2）饿汉式单例
        类一旦加载就创建一个单例，在调用getInstance之前单例就存在。

        public class HungrySingleton{
            private static volatile HungrySingleton instance = new HungrySingleton ();
            private HungrySingleton{

            }

            public static HungrySingleton getInstance(){
                return instance
            }
        }
二、原型模式
    1.定义
        用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的对象。原型实例指定了要创建的对象的种类。
    2.优缺点
    （1）优点：
        Java自带的原型模式基于内存的二进制流的复制，在性能上比直接new一个对象更加优良。
        可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。
    （2）缺点：
        需要为每一个类都配置一个clone方法。
        当对象之间存在多重嵌套引用，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来比较麻烦。
    3.结构
    （1）抽象原型类：规定了具体原型对象必须实现的接口。
    （2）具体原型类：实现抽象原型类的clone()方法，是可被复制的对象。
    （3）访问类：使用具体原型类中的clone()方法来创建新的对象。
    4.实现
    浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
    深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

    class RealizeType implements Cloneable{
        RealizeType(){
            System.out.println("具体原型创建成功");
        }

        public Object clone() throws CloneNotSupportedException{
            System.out.println("具体原型复制成功");
            return (RealizeType) super.clone();
        }
    }

    5.应用场景
    （1）对象之间相同或相似，即只是个别的几个属性不同的时候。
    （2）创建对象成本较大，例如初始化时间长，占用CPU太多等。
    （3）系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。
三、简单工厂模式
    1.定义
        定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。
    2.优缺点
    （1）优点：
        工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。
        客户端无需知道所创建具体产品的类名，只需知道参数即可。
        可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。
    （2）缺点：
        工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。
        使用简单工厂模式会增加系统中类的个数，增加系统的复杂度和理解难度。
        系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时可能造成逻辑过于复杂。
    3.结构
    （1）简单工厂：负责创建所有实例的内部逻辑，工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
    （2）抽象产品：简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
    （3）具体产品：简单工厂模式的创建目标。
    4.实现
    public class client{
        public static void main(String[] args){

        }
        //抽象产品
        public interface Product{
            void show();
        }
        //具体产品
        static class ConcreteProduct1 implements Product{
            public void show(){
                System.out.println("具体产品1");
            }
        }
        static class ConcreteProduct2 implements Product{
            public void show(){
                System.out.println("具体产品2");
            }
        }
        final class Const{
            static final int PRODUCT_A = 0;
            static final int PRODUCT_B = 1;
        }
        static class SimpleFactory{
            public static Product makeProduct(int kind){
                switch(kind){
                    case Const.PRODUCT_A:
                        return new ConcreteProduct1();
                    case Const.PRODUCT_B:
                        return new ConcreteProduct2();
                }
            }
        }
    }
四、工厂方法模式
    1.定义
        对简单工厂模式的进一步抽象化，可以使系统在不修改原来代码的情况下引进新的产品。
    2.优缺点
    （1）优点：
        用户只需要知道具体工厂的名称就可得到所要的产品，无需知道产品的具体创建过程。
        灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
        典型的解耦框架。
    （2）缺点：
        类的个数容易增多，增加复杂度。
        增加了系统的抽象性和理解难度。
        抽象产品只能生产一种产品。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间一一对应。
    4.实现
    public class AbstractFactory{
        public static void main(String[] args){
            try{
                Product a;
                AbstractFactory af;
                af = (AbstractFactory) ReadXML1.getObject();
                a = af.newProduct();
                a.show();
            }catch(Exception e){
                System.out.println(e.getMessage());
            }
        }

        //抽象产品
        interface Product{
            public void show();
        }

        //具体产品1:实现抽象产品中的抽象方法
        class ConcreteProduct1 implements Product{
            public void show(){
                System.out.println("具体产品1");
            }
        }

        //具体产品2:实现抽象产品中的抽象方法
        class ConcreteProduct2 implements Product{
            public void show(){
                System.out.println("具体产品2");
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory1 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品1");
                return new ConcreteProduct1;
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory2 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品2");       
                return new ConcreteProduct2;

            }
        }
    }
五、抽象工厂模式
    1.定义
        为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。工厂方法模式只生产一个等级的产品，
        而抽象工厂模式可以生产多个等级的产品。
    2.优缺点
    （1）优点：
        可以在类内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
        当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品族。
        抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码。
    （2）缺点：
        当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，包含了多个创建产品的方法，可以创建多个不同等级的产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间是多对一的关系。
    4.实现
        抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。
    interface AbstractFactory {
        public Product1 newProduct1();
        public Product2 newProduct2();
    }
六、建造者模式
    1.定义
        将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。
    2.优缺点
    （1）优点：
        封装性好，构建和表示分离。
        扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
        客户端不知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响。
    （2）缺点：
        产品的组成部分必须相同。
        如果产品内部发生变化，则建造者也要同步修改。
    3.结构
    （1）产品角色：包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。
    （2）抽象建造者：包含创建产品各个部件的抽象方法的接口，通常还包含一个返回复杂产品的方法getResult()。
    （3）具体建造者：实现Builder接口，完成复杂产品的各个部件的具体创建方法。
    （4）指挥者：调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不包含具体产品的信息。
    4.实现
    //产品角色
    class Product{
        private String partA;
        private String partB;

        public void setPartA(String partA){
            this.partA = partA;
        }

        public void setPartB(String partB){
            this.partB = partB;
        }

        public void show(){
            //显示产品特性
        }
    }

    //抽象建造者
    abstract class Builder{
        //创建产品对象
        protected Product product = new Product();

        public abstract void buildPartA();

        public abstract void buildPartB():

        //返回产品对象
        public Product getResult(){
            return product;
        }
    }

    //具体建造者
    public class ConcreteBuilder extends Builder{
        public void buildPartA(){
            product.setPartA("建造PartA");
        }

        public void buildPartB(){
            product.setPartB("建造PartB");
        }
    }

    //指挥者
    class Director{
        private Builder builder;

        public Director(Builder builder){
            this.builder = builder;
        }

        //产品构建与组装方法
        public Product construct(){
            builder.buildPartA();
            builder.buildPartB();
            return builder.getResult();
        }
    }

    //客户类
    public class client{
        public static void main(String[] args){
            Builder builder = new ConcreteBuilder();
            Director director = new Director(builder);
            Product product = director.construct();
            product.show();
        }
    }
七、代理模式
    1.定义
        由于某些原因需要给对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象
    之间的中介。
    2.优缺点
    （1）优点：
        代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。
        代理对象可以扩展目标对象的功能。
        代理模式能将客户端与目标对象分离，在一定成都上降低了系统的耦合度。
    （2）缺点：
        会造成系统设计中类的数量增加。
        在客户端和目标对象之间增加一个代理对象会造成请求处理速度变慢。
        增加系统的复杂度。
    3.结构
    （1）抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    （2）真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
    （3）代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能。
    4.实现
        静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的.class文件就已经存在了。
        动态代理：在程序运行时运用反射机制动态创建而成。
    public class ProxyTest{
        public static void main(String[] args){
            Proxy proxy = new Proxy();
            proxy.Request();
        }
    }

    //抽象主题
    interface Subject{
        void Request();
    }

    //真实主题
    class RealSubject implements Subject{
        public void Request(){
            System.out.println("访问真实主题方法");
        }
    }

    //代理
    class Proxy implements Subject {
        private RealSubject realSubject;

        public void Request(){
            if(realSubject == null){
                realSubject = new RealSubject();
            }

            preRequest();
            realSubject.Request();
            postRequest();
        }

        public void preRequest(){
            System.out.println("访问真实主题之前的预处理")
        }

        public void postRequest(){
            System.out.println("访问真实主题之后的处理")
        }
    }
八、适配器模式
    1.定义
        将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类能一起工作。
    2.优缺点
    （1）优点：
        客户端通过适配器可以透明地调用目标接口。
        复用了现存的类，不需要修改原有代码而重用现有的适配者类。
        将目标类和适配者类解耦，解决目标类和适配者类接口不一致的问题。
    （2）缺点：
        适配器编写过程需要结合业务场景全面考虑，增加系统的复杂性。
    3.结构
    （1）目标接口：当前业务系统所期待的接口，可以是抽象类或接口。
    （2）适配者类：是被访问和适配的现存组件库中的组件接口。
    （3）适配器类：是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标的格式访问适配者。
    4.实现
    （1）类适配器模式
    //目标接口
    interface Target{
        public void request();
    }

    //适配者接口
    class Adaptee{
        public void specificRequest(){
            System.out.println("适配者中的业务代码被调用");
        }
    }

    //类适配器
    class ClassAdapter extends Adaptee implements Target{
        public void request(){
            specificRequest();
        }
    }

    //客户端代码
    public class ClassAdapterTest{
        public static void main(String[] args){
            System.out.println("类适配器测试");
            Target Target = new ClassAdapter();
            Target.request();
        }
    }
    （2）对象适配器
    class ObjectAdapter implements Target{
        private Adaptee Adaptee;
        public ObjectAdapter(Adaptee abstract){
            this.adaptee = adaptee;
        }
        public void request(){
            adaptee.specificRequest();
        }
    }

    public class ObjectAdapterTest{
        public static void main(String[] args){
            System.out.println("对象适配器测试");
            Adaptee adaptee = new Adaptee();
            Target target = new ObjectAdapter();
            target.request();
        }
    }
九、桥接模式
    1.定义
        将抽象与显示分离，可以独立变化，用组合关系代替继承关系来实现，降低抽象和实现这两个可变维度的耦合。
    2.优缺点
    （1）优点：
        扩展能力强，实现细节对客户透明。
    （2）缺点：
        聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确识别出系统中两个独立变化的维度。
    3.结构
    （1）抽象化角色：定义抽象类，并包含一个对实现化对象的引用。
    （2）扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，通过组合关系调用实现化角色中的业务方法。
    （3）实现化角色：定义实现化角色的接口，供扩展抽象化角色调用。
    （4）具体实现化角色：给出实现化角色接口的具体实现。
    4.实现
    public class BridgeTest{
        public static void main(String[] args){
            Implementor imple = new ConcreteImplementorA();
            Abseraction abs = new RefinedAbstraction(imple);
            abs.Operation();
        }
    }

    //实现化角色
    interface Implementor {
        public void OperationImpl();
    }

    //具体实现化角色
    class ConcreteImplementorA implements Implementor{
        public void OperationImpl(){
            System.out.println("具体实现化角色被访问")
        }
    }

    //抽象化角色
    abstract class Abstraction{
        protected Implementor imple;

        protected Abstraction(Implementor imple){
            this.imple = imple;
        }

        public abstract void Operation();
    }
    
    //扩展抽象化角色
    class RefinedAbstraction extends Abstraction{
        protected RefinedAbstraction(Implementor imple){
            super(imple);
        }

        public void Operation(){
            System.out.println("扩展抽象化角色被访问")
        }
    }

十、装饰器模式
    1.定义
        指在不改变现有对象结构的情况下，动态地给该对象增加一些职责。
    2.优缺点
    （1）优点：
        是继承的有力补充，在不改变原有对象的情况下动态的给一个对象扩展功能，即插即用。
        通过使用不用装饰类及这些装饰类的排列组合可以实现不同效果。
    （2）缺点：
        会增加许多子类，增加程序复杂性。
    3.结构
    （1）抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。
    （2）具体构建角色：实现抽象构件通过装饰角色为其添加一些职责。
    （3）抽象装饰角色：继承抽象构件并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
    （4）具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
    4.实现
    public class DecoratorPattern{
        public class static void main(String[] args){
            Component p = new ConcreteComponent();
            p.operation();
            System.out.println("--------");
            Component d = new ConcreteDecorator(p);
            d.operation();
        }
    }

    //抽象构件角色
    interface Component{
        public void operation();
    }

    //具体构件角色
    class ConcreteComponent implements Component{
        public ConcreteComponent(){
            System.out.println("创建具体构建角色");
        }

        public void operation(){
            System.out.println("调用具体构件角色的方法");
        }
    }

    //抽象装饰角色
    class Decorator implements Component {
        private Component component;

        public Decorator (Component component){
            this.component = component;
        }

        public void operation(){
            component.operation();
        }
    }

    //具体装饰角色
    class ConcreteDecorator extends Decorator {
        public ConcreteDecorator(Component component){
            super(component);
        }

        public void operation(){
            super.operation();
            addedFunction();
        }

        public void addedFunction(){
            System.out.println("为具体构件角色增加额外功能")
        }
    }
十一、外观模式
    1.定义
        通过为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节。
    2.优缺点
    （1）优点：
        降低子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
        对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
    （2）缺点：
        不能很好的限制客户使用子系统类，容易带来未知风险。
    3.结构
    （1）外观角色：为多个子系统提供一个共同的接口。
    （2）子系统角色：实习系统的部分功能，客户可以通过外观角色访问它。
    （2）客户角色：通过一个外观角色访问各个子系统的功能。
    4.实现
    public class FacadePattern{
        public static void main(String[] args){
            Facade f = new Facade();
            f.method();
        }
    }

    //外观角色
    class Facade {
        private SubSystem01 obj1 = new SubSystem01();
        private SubSystem02 obj2 = new SubSystem02();

        public void method(){
            obj1.method1();
            obj2.method2();
        }
    }

    //子系统角色
    class SubSystem01 {
        public void method1(){
            System.out.println("子系统01的method1被调用");
        }
    }

    //子系统角色
    class SubSystem01 {
        public void method1(){
            System.out.println("子系统01的method1被调用");
        }
    }

    //子系统角色
    class SubSystem02 {
        public void method2(){
            System.out.println("子系统02的method1被调用");
        }
    }

    //子系统角色
    class SubSystem02 {
        public void method2(){
            System.out.println("子系统02的method1被调用");
        }
    }
十二、享元模式
    1.定义
        运用共享技术来有效地支持大量细粒度对象的复用。
    2.优缺点
    （1）优点：
        相同对象只要保存一份，降低了系统中对象的数量。
    （2）缺点：
        为了使对象可以共享，需要将一些不能共享的状态外部化，增加系统复杂性。
        读取享元模式的外部状态会使运行时间变长。
    3.结构
    （1）抽象享元角色：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
    （2）具体享元角色：实现抽象享元角色中所规定的接口。
    （3）非享元角色：不可以共享的外部状态，以参数的形式注入具体享元的相关方法中。
    （4）享元工厂角色：负责创建和管理享元角色，当客户对象请求创建一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户；
    如果不存在则创建一个新的享元对象。
    4.实现
    //非享元角色
    class UnsharedConcreteFlyweight{
        private String info;

        UnsharedConcreteFlyweight(String info){
            this.info = info;
        }

        public String getInfo(){
            return info;
        }

        public void setInfo(String info){
            this.info = info;
        }
    }

    //抽象享元角色
    interface Flyweight {
        public void operation(UnsharedConcreteFlyweight state);
    }

    //具体享元角色
    class ConcreteFlyweight implements Flyweight {
        private String key;

        ConcreteFlyweight(String key){
            this.key = key;
            System.out.println("具体享元"+key+"被创建");
        }

        public void operation(UnsharedConcreteFlyweight outState){
            System.out.println("具体享元"+key+"被调用");
            System.out.println("非享元信息是："+outState.getInfo());
        }
    }

    //享元工厂角色
    class FlyweightFactory{
        private HashMap<String,Flyweight> flyweights = new HashMap<String,Flyweight>();

        public Flyweight getFlyweight(String key){
            Flyweight flyweight = (Flyweight) flyweights.get(key);
            if (flyweight != null){
                System.out.println("具体享元"+key+"已经存在，被成功获取");
            }else{
                flyweight = new ConcreteFlyweight(key);
                flyweights.put(key,flyweight);
            }
            return flyweight;
        }
    }
十三、组合模式
    1.定义
        将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性。
    2.优缺点
    （1）优点：
        组合模式使得客户端代码可以一直地处理单个对象和组合对象，无须关心自己处理的是单个对象还是组合对象。
        更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码。
    （2）缺点：
        设计复杂
        不容易限制容器中的构件
        不容易用继承的方法来增加构件的新功能
    3.结构
    （1）抽象构件角色：主要作用是为树叶构件和树枝构件声明公共接口，并实现他们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；
        在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。
    （2）树叶构件角色：组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。
    （3）树枝构件角色：组合中的分支节点对象，有子节点，用于继承和实现抽象构件，主要作用是存储和管理子部件。
    4.实现
    （1）透明方式：由于抽象构件声明了所有子类中的全部方法，客户端无须区别树叶对线和树枝对象，对客户端来说是透明的。
    （2）安全方式：将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有子对象的管理方法，由于叶子和分支有不同的接口，客户端在调用时要知道
    树叶对象和树枝对象的存在，所以失去了透明性。
    interface Component{
        public void add(Component c);

        public void remove(Component c);

        public Component getChild(int i);

        public void operation();
    }

    class Leaf implements Component{
        private String name;

        public Leaf(String name){
            this.name = name;
        }

        public void add(Component c){
        }

        public void remove(Component c){
        }

        public Component getChild(int i){
            return null;
        }

        public void operation(){
            System.out.println("树叶"+name+"：被访问");
        }
    }

    class Composite implements Component{
        private ArrayList<Component> children = new ArrayList<Component>();

        public void add(Component c){
            children.add(c);
        }

        public void remove(Component c){
            children.remove(c);
        }

        public Component getChild(int i){
            return children.get(i);
        }

        public void operation(){
            for(Object obj:children){
                ((Component) obj).operation();
            }
        }
    }
十四、模版方法
    1.定义
        定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重新定义该算法的某些特定步骤。
    2.优缺点
    （1）优点：
        把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类扩展。
        在父类中提取了公共的部分代码便于代码复用。
        部分方法是由子类实现的，子类可以通过扩展的方式增加相应的功能。
    （2）缺点：
        对每个不同的实现都需要定义一个子类，导致类的个数增加，系统更加庞大，设计更抽象，间接增加了系统实现的复杂度。
        父类中的抽象方法由子类实现，子类执行的结果会影响父类。
        由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有的子类都要更改。
    3.结构
    （1）抽象模版类：负责给出一个算法的轮廓和骨架。
        模版方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
        基本方法：
            抽象方法：在抽象类中声明，由具体子类实现。
            具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
            钩子方法：在抽象类中已经实现，包括由于判断的逻辑方法和需要子类重写的空方法两种。
    （2）具体子类：实现抽象类中所定义的抽象方法和钩子方法。
    4.实现
    //抽象类
    abstract class AbstractClass{
        //模版方法
        public void TemplateMethod(){
            SpecificMethod();
            abstractMethod1();
            abstractMethod2();
        }

        //具体方法
        public void SpecificMethod(){
            System,out.println("抽象类中的具体方法被调用");
        }

        //抽象方法1
        public abstract void abstractMethod1();

        //抽象方法2
        public abstract void abstractMethod2();
    }

    class ConcreteClass extends AbstractClass{
        public void abstractMethod1(){
            System.out.println("抽象方法1的实现被调用");
        }

        public void abstractMethod2(){
            System.out.println("抽象方法2的实现被调用");
        }
    }
十五、策略模式
    1.定义
        该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。
    2.优缺点
    （1）优点：
        多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
        提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，避免重复的代码。
        提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
    （2）缺点：
        客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
        策略模式造成很多的策略类，增加维护难度。
    3.结构
    （1）抽象策略类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
    （2）具体策略类：实现了抽象策略定义的接口，提供具体的算法实现。
    （3）环境类：持有一个策略类的引用，最终给客户端调用。
    4.实现
    //抽象策略类
    interface Strategy{
        public void strategyMethod();   //策略方法
    }

    //具体策略类A
    class ConcreteStrategyA implements Strategy {
        public void strategyMethod(){
            System.out.println("具体策略A的策略方法被访问");
        }
    }

    //具体策略类B
    class ConcreteStrategyB implements Strategy {
        public void strategyMethod(){
            System.out.println("具体策略B的策略方法被访问");
        }
    }

    class Context {
        private Strategy strategy;

        public Strategy getStrategy(){
            return strategy;
        }

        public void setStrategy(Strategy strategy){
            this.strategy = strategy;
        }

        public void strategyMethod(){
            strategy.strategyMethod();
        }
    }
十六、命令模式
    1.定义
        将一个请求封装成一个对象，使发出的请求和执行请求的责任分隔开。
    2.优缺点
    （1）优点：
        通过引入中间件（抽象接口）降低系统的耦合度。
        扩展性良好，增加或删除命令非常方便。
        可以实现宏命令，命令模式与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
        方便实现Undo和Redo命令。
        可以在现有命令的基础上增加额外功能。
    （2）缺点：
        可能产生大量具体的命令类。
    3.结构
    （1）抽象命令类角色：声明执行命令的接口，拥有执行命令的抽象方法。
    （2）具体命令类角色：是抽象命令类的具体实现类，拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
    （3）实现者/接收者：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
    （4）调用者/请求者：是请求的发送者，通常拥有很多的命令对象，并通过访问命令对象来执行相关的请求，不直接访问接收者。
    4.实现
    //调用者
    class Invoker {
        private Command Command;

        public Invoker(Command command){
            this.command = command;
        }

        public void setCommand(Command command){
            this.command = command;
        }

        public void call(){
            System.out.println("调用者执行命令command");
            command.execute();
        }
    }

    //抽象命令
    interface Command{
        public abstract void execute();
    }

    //具体命令
    class ConcreteCommand implements Command {
        private Receiver receiver;

        ConcreteCommand(){
            receiver = new Receiver();
        }

        public void execute(){
            receiver.action();
        }
    }

    //接收者
    class Receiver{
        public void action(){
            System.out.println("接收者的action()方法被调用");
        }
    }
十七、责任链模式
    1.定义
        为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象