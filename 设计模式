一、单例模式
    1.定义
        指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
    2.特点
        单例类只有一个实例对象；该单例对象必须由单例类自行创建；单例类对外提供一个访问该单例的全局访问点。
    3.优缺点
    （1）优点：
        单例模式可以保证内存里只有一个实例，减少内存开销。
        可以避免对资源的多重占用。
        设置全局访问点，可以优化和共享访问资源。
    （2）缺点：
        单例模式一般没有接口，扩展困难。如果要扩展，除了修改原来的代码没有第二种途径。
    3.实现
    （1）懒汉式单例
        类加载时没有生成单例，只有当第一次调用getInstance方法时才去创建这个单例。

        public class LazySingleton{
            private static volatile LazySingleton instance = null;
            private LazySingleton(){
                //private 避免类在外部被实例化
            }

            public static synchronized LazySingleton getInstance(){
                if (instance == null){
                    instance = new LazySingleton();
                }
                return instance;
            }
        }
    
    （2）饿汉式单例
        类一旦加载就创建一个单例，在调用getInstance之前单例就存在。

        public class HungrySingleton{
            private static volatile HungrySingleton instance = new HungrySingleton ();
            private HungrySingleton{

            }

            public static HungrySingleton getInstance(){
                return instance
            }
        }
二、原型模式
    1.定义
        用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的对象。原型实例指定了要创建的对象的种类。
    2.优缺点
    （1）优点：
        Java自带的原型模式基于内存的二进制流的复制，在性能上比直接new一个对象更加优良。
        可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。
    （2）缺点：
        需要为每一个类都配置一个clone方法。
        当对象之间存在多重嵌套引用，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来比较麻烦。
    3.结构
    （1）抽象原型类：规定了具体原型对象必须实现的接口。
    （2）具体原型类：实现抽象原型类的clone()方法，是可被复制的对象。
    （3）访问类：使用具体原型类中的clone()方法来创建新的对象。
    4.实现
    浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
    深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

    class RealizeType implements Cloneable{
        RealizeType(){
            System.out.println("具体原型创建成功");
        }

        public Object clone() throws CloneNotSupportedException{
            System.out.println("具体原型复制成功");
            return (RealizeType) super.clone();
        }
    }

    5.应用场景
    （1）对象之间相同或相似，即只是个别的几个属性不同的时候。
    （2）创建对象成本较大，例如初始化时间长，占用CPU太多等。
    （3）系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。
三、简单工厂模式
    1.定义
        定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。
    2.优缺点
    （1）优点：
        工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。
        客户端无需知道所创建具体产品的类名，只需知道参数即可。
        可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。
    （2）缺点：
        工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。
        使用简单工厂模式会增加系统中类的个数，增加系统的复杂度和理解难度。
        系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时可能造成逻辑过于复杂。
    3.结构
    （1）简单工厂：负责创建所有实例的内部逻辑，工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
    （2）抽象产品：简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
    （3）具体产品：简单工厂模式的创建目标。
    4.实现
    public class client{
        public static void main(String[] args){

        }
        //抽象产品
        public interface Product{
            void show();
        }
        //具体产品
        static class ConcreteProduct1 implements Product{
            public void show(){
                System.out.println("具体产品1");
            }
        }
        static class ConcreteProduct2 implements Product{
            public void show(){
                System.out.println("具体产品2");
            }
        }
        final class Const{
            static final int PRODUCT_A = 0;
            static final int PRODUCT_B = 1;
        }
        static class SimpleFactory{
            public static Product makeProduct(int kind){
                switch(kind){
                    case Const.PRODUCT_A:
                        return new ConcreteProduct1();
                    case Const.PRODUCT_B:
                        return new ConcreteProduct2();
                }
            }
        }
    }
四、工厂方法模式
    1.定义
        对简单工厂模式的进一步抽象化，可以使系统在不修改原来代码的情况下引进新的产品。
    2.优缺点
    （1）优点：
        用户只需要知道具体工厂的名称就可得到所要的产品，无需知道产品的具体创建过程。
        灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
        典型的解耦框架。
    （2）缺点：
        类的个数容易增多，增加复杂度。
        增加了系统的抽象性和理解难度。
        抽象产品只能生产一种产品。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间一一对应。
    4.实现
    public class AbstractFactory{
        public static void main(String[] args){
            try{
                Product a;
                AbstractFactory af;
                af = (AbstractFactory) ReadXML1.getObject();
                a = af.newProduct();
                a.show();
            }catch(Exception e){
                System.out.println(e.getMessage());
            }
        }

        //抽象产品
        interface Product{
            public void show();
        }

        //具体产品1:实现抽象产品中的抽象方法
        class ConcreteProduct1 implements Product{
            public void show(){
                System.out.println("具体产品1");
            }
        }

        //具体产品2:实现抽象产品中的抽象方法
        class ConcreteProduct2 implements Product{
            public void show(){
                System.out.println("具体产品2");
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory1 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品1");
                return new ConcreteProduct1;
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory2 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品2");       
                return new ConcreteProduct2;

            }
        }
    }
五、抽象工厂模式
    1.定义
        为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。工厂方法模式只生产一个等级的产品，
        而抽象工厂模式可以生产多个等级的产品。
    2.优缺点
    （1）优点：
        可以在类内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
        当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品族。
        抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码。
    （2）缺点：
        当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，包含了多个创建产品的方法，可以创建多个不同等级的产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间是多对一的关系。
    4.实现
        抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。
    interface AbstractFactory {
        public Product1 newProduct1();
        public Product2 newProduct2();
    }
六、建造者模式
    1.定义
        将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。
    2.优缺点
    （1）优点：
        封装性好，构建和表示分离。
        扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
        客户端不知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响。
    （2）缺点：
        产品的组成部分必须相同。
        如果产品内部发生变化，则建造者也要同步修改。
    3.结构
    （1）产品角色：包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。
    （2）抽象建造者：包含创建产品各个部件的抽象方法的接口，通常还包含一个返回复杂产品的方法getResult()。
    （3）具体建造者：实现Builder接口，完成复杂产品的各个部件的具体创建方法。
    （4）指挥者：调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不包含具体产品的信息。
    4.实现
    //产品角色
    class Product{
        private String partA;
        private String partB;

        public void setPartA(String partA){
            this.partA = partA;
        }

        public void setPartB(String partB){
            this.partB = partB;
        }

        public void show(){
            //显示产品特性
        }
    }

    //抽象建造者
    abstract class Builder{
        //创建产品对象
        protected Product product = new Product();

        public abstract void buildPartA();

        public abstract void buildPartB():

        //返回产品对象
        public Product getResult(){
            return product;
        }
    }

    //具体建造者
    public class ConcreteBuilder extends Builder{
        public void buildPartA(){
            product.setPartA("建造PartA");
        }

        public void buildPartB(){
            product.setPartB("建造PartB");
        }
    }

    //指挥者
    class Director{
        private Builder builder;

        public Director(Builder builder){
            this.builder = builder;
        }

        //产品构建与组装方法
        public Product construct(){
            builder.buildPartA();
            builder.buildPartB();
            return builder.getResult();
        }
    }

    //客户类
    public class client{
        public static void main(String[] args){
            Builder builder = new ConcreteBuilder();
            Director director = new Director(builder);
            Product product = director.construct();
            product.show();
        }
    }
七、代理模式
    1.定义
        由于某些原因需要给对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象
    之间的中介。
    2.优缺点
    （1）优点：
        代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。
        代理对象可以扩展目标对象的功能。
        代理模式能将客户端与目标对象分离，在一定成都上降低了系统的耦合度。
    （2）缺点：
        会造成系统设计中类的数量增加。
        在客户端和目标对象之间增加一个代理对象会造成请求处理速度变慢。
        增加系统的复杂度。
    3.结构
    （1）抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    （2）真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
    （3）代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能。
    4.实现
        静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的.class文件就已经存在了。
        动态代理：在程序运行时运用反射机制动态创建而成。
    public class ProxyTest{
        public static void main(String[] args){
            Proxy proxy = new Proxy();
            proxy.Request();
        }
    }

    //抽象主题
    interface Subject{
        void Request();
    }

    //真实主题
    class RealSubject implements Subject{
        public void Request(){
            System.out.println("访问真实主题方法");
        }
    }

    //代理
    class Proxy implements Subject {
        private RealSubject realSubject;

        public void Request(){
            if(realSubject == null){
                realSubject = new RealSubject();
            }

            preRequest();
            realSubject.Request();
            postRequest();
        }

        public void preRequest(){
            System.out.println("访问真实主题之前的预处理")
        }

        public void postRequest(){
            System.out.println("访问真实主题之后的处理")
        }
    }
八、适配器模式
    1.定义
        将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类能一起工作。
    2.优缺点
    （1）优点：
        客户端通过适配器可以透明地调用目标接口。
        复用了现存的类，不需要修改原有代码而重用现有的适配者类。
        将目标类和适配者类解耦，解决目标类和适配者类接口不一致的问题。
    （2）缺点：
        适配器编写过程需要结合业务场景全面考虑，增加系统的复杂性。
    3.结构
    （1）目标接口：当前业务系统所期待的接口，可以是抽象类或接口。
    （2）适配者类：是被访问和适配的现存组件库中的组件接口。
    （3）适配器类：是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标的格式访问适配者。
    4.实现
    （1）类适配器模式
    //目标接口
    interface Target{
        public void request();
    }

    //适配者接口
    class Adaptee{
        public void specificRequest(){
            System.out.println("适配者中的业务代码被调用");
        }
    }

    //类适配器
    class ClassAdapter extends Adaptee implements Target{
        public void request(){
            specificRequest();
        }
    }

    //客户端代码
    public class ClassAdapterTest{
        public static void main(String[] args){
            System.out.println("类适配器测试");
            Target Target = new ClassAdapter();
            Target.request();
        }
    }
    （2）对象适配器
    class ObjectAdapter implements Target{
        private Adaptee Adaptee;
        public ObjectAdapter(Adaptee abstract){
            this.adaptee = adaptee;
        }
        public void request(){
            adaptee.specificRequest();
        }
    }

    public class ObjectAdapterTest{
        public static void main(String[] args){
            System.out.println("对象适配器测试");
            Adaptee adaptee = new Adaptee();
            Target target = new ObjectAdapter();
            target.request();
        }
    }
九、桥接模式
    1.定义
        将抽象与显示分离，可以独立变化，用组合关系代替继承关系来实现，降低抽象和实现这两个可变维度的耦合。
    2.优缺点
    （1）优点：
        扩展能力强，实现细节对客户透明。
    （2）缺点：
        聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确识别出系统中两个独立变化的维度。
    3.结构
    （1）抽象化角色：定义抽象类，并包含一个对实现化对象的引用。
    （2）扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，通过组合关系调用实现化角色中的业务方法。
    （3）实现化角色：定义实现化角色的接口，供扩展抽象化角色调用。
    （4）具体实现化角色：给出实现化角色接口的具体实现。
    4.实现
    public class BridgeTest{
        public static void main(String[] args){
            Implementor imple = new ConcreteImplementorA();
            Abseraction abs = new RefinedAbstraction(imple);
            abs.Operation();
        }
    }

    //实现化角色
    interface Implementor {
        public void OperationImpl();
    }

    //具体实现化角色
    class ConcreteImplementorA implements Implementor{
        public void OperationImpl(){
            System.out.println("具体实现化角色被访问")
        }
    }

    //抽象化角色
    abstract class Abstraction{
        protected Implementor imple;

        protected Abstraction(Implementor imple){
            this.imple = imple;
        }

        public abstract void Operation();
    }
    
    //扩展抽象化角色
    class RefinedAbstraction extends Abstraction{
        protected RefinedAbstraction(Implementor imple){
            super(imple);
        }

        public void Operation(){
            System.out.println("扩展抽象化角色被访问")
        }
    }

十、装饰器模式
    1.定义
        指在不改变现有对象结构的情况下，动态地给该对象增加一些职责。
    2.优缺点
    （1）优点：
        是继承的有力补充，在不改变原有对象的情况下动态的给一个对象扩展功能，即插即用。
        通过使用不用装饰类及这些装饰类的排列组合可以实现不同效果。
    （2）缺点：
        会增加许多子类，增加程序复杂性。
    3.结构
    （1）抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。
    （2）具体构建角色：实现抽象构件通过装饰角色为其添加一些职责。
    （3）抽象装饰角色：继承抽象构件并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
    （4）具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
    4.实现
    public class DecoratorPattern{
        public class static void main(String[] args){
            Component p = new ConcreteComponent();
            p.operation();
            System.out.println("--------");
            Component d = new ConcreteDecorator(p);
            d.operation();
        }
    }

    //抽象构件角色
    interface Component{
        public void operation();
    }

    //具体构件角色
    class ConcreteComponent implements Component{
        public ConcreteComponent(){
            System.out.println("创建具体构建角色");
        }

        public void operation(){
            System.out.println("调用具体构件角色的方法");
        }
    }

    //抽象装饰角色
    class Decorator implements Component {
        private Component component;

        public Decorator (Component component){
            this.component = component;
        }

        public void operation(){
            component.operation();
        }
    }

    //具体装饰角色
    class ConcreteDecorator extends Decorator {
        public ConcreteDecorator(Component component){
            super(component);
        }

        public void operation(){
            super.operation();
            addedFunction();
        }

        public void addedFunction(){
            System.out.println("为具体构件角色增加额外功能")
        }
    }
十一、外观模式
    1.定义
        通过为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节。
    2.优缺点
    （1）优点：
        降低子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
        对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
    （2）缺点：
        不能很好的限制客户使用子系统类，容易带来未知风险。
    3.结构
    （1）外观角色：为多个子系统提供一个共同的接口。
    （2）子系统角色：实习系统的部分功能，客户可以通过外观角色访问它。
    （2）客户角色：通过一个外观角色访问各个子系统的功能。
    4.实现
    public class FacadePattern{
        public static void main(String[] args){
            Facade f = new Facade();
            f.method();
        }
    }

    //外观角色
    class Facade {
        private SubSystem01 obj1 = new SubSystem01();
        private SubSystem02 obj2 = new SubSystem02();

        public void method(){
            obj1.method1();
            obj2.method2();
        }
    }

    //子系统角色
    class SubSystem01 {
        public void method1(){
            System.out.println("子系统01的method1被调用");
        }
    }

    //子系统角色
    class SubSystem01 {
        public void method1(){
            System.out.println("子系统01的method1被调用");
        }
    }
