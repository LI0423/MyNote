学习链接：  http://c.biancheng.net/view/1317.html

一、单例模式
    1.定义
        指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
    2.特点
        单例类只有一个实例对象；该单例对象必须由单例类自行创建；单例类对外提供一个访问该单例的全局访问点。
    3.优缺点
    （1）优点：
        单例模式可以保证内存里只有一个实例，减少内存开销。
        可以避免对资源的多重占用。
        设置全局访问点，可以优化和共享访问资源。
    （2）缺点：
        单例模式一般没有接口，扩展困难。如果要扩展，除了修改原来的代码没有第二种途径。
    3.实现
    （1）懒汉式单例
        类加载时没有生成单例，只有当第一次调用getInstance方法时才去创建这个单例。

        public class LazySingleton{
            private static volatile LazySingleton instance = null;
            private LazySingleton(){
                //private 避免类在外部被实例化
            }

            public static synchronized LazySingleton getInstance(){
                if (instance == null){
                    instance = new LazySingleton();
                }
                return instance;
            }
        }
    
    （2）饿汉式单例
        类一旦加载就创建一个单例，在调用getInstance之前单例就存在。

        public class HungrySingleton{
            private static volatile HungrySingleton instance = new HungrySingleton ();
            private HungrySingleton{

            }

            public static HungrySingleton getInstance(){
                return instance
            }
        }
二、原型模式
    1.定义
        用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的对象。原型实例指定了要创建的对象的种类。
    2.优缺点
    （1）优点：
        Java自带的原型模式基于内存的二进制流的复制，在性能上比直接new一个对象更加优良。
        可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。
    （2）缺点：
        需要为每一个类都配置一个clone方法。
        当对象之间存在多重嵌套引用，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来比较麻烦。
    3.结构
    （1）抽象原型类：规定了具体原型对象必须实现的接口。
    （2）具体原型类：实现抽象原型类的clone()方法，是可被复制的对象。
    （3）访问类：使用具体原型类中的clone()方法来创建新的对象。
    4.实现
    浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
    深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

    class RealizeType implements Cloneable{
        RealizeType(){
            System.out.println("具体原型创建成功");
        }

        public Object clone() throws CloneNotSupportedException{
            System.out.println("具体原型复制成功");
            return (RealizeType) super.clone();
        }
    }

    5.应用场景
    （1）对象之间相同或相似，即只是个别的几个属性不同的时候。
    （2）创建对象成本较大，例如初始化时间长，占用CPU太多等。
    （3）系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。
三、简单工厂模式
    1.定义
        定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。
    2.优缺点
    （1）优点：
        工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。
        客户端无需知道所创建具体产品的类名，只需知道参数即可。
        可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。
    （2）缺点：
        工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。
        使用简单工厂模式会增加系统中类的个数，增加系统的复杂度和理解难度。
        系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时可能造成逻辑过于复杂。
    3.结构
    （1）简单工厂：负责创建所有实例的内部逻辑，工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
    （2）抽象产品：简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
    （3）具体产品：简单工厂模式的创建目标。
    4.实现
    public class client{
        public static void main(String[] args){

        }
        //抽象产品
        public interface Product{
            void show();
        }
        //具体产品
        static class ConcreteProduct1 implements Product{
            public void show(){
                System.out.println("具体产品1");
            }
        }
        static class ConcreteProduct2 implements Product{
            public void show(){
                System.out.println("具体产品2");
            }
        }
        final class Const{
            static final int PRODUCT_A = 0;
            static final int PRODUCT_B = 1;
        }
        static class SimpleFactory{
            public static Product makeProduct(int kind){
                switch(kind){
                    case Const.PRODUCT_A:
                        return new ConcreteProduct1();
                    case Const.PRODUCT_B:
                        return new ConcreteProduct2();
                }
            }
        }
    }
四、工厂方法模式
    1.定义
        对简单工厂模式的进一步抽象化，可以使系统在不修改原来代码的情况下引进新的产品。
    2.优缺点
    （1）优点：
        用户只需要知道具体工厂的名称就可得到所要的产品，无需知道产品的具体创建过程。
        灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
        典型的解耦框架。
    （2）缺点：
        类的个数容易增多，增加复杂度。
        增加了系统的抽象性和理解难度。
        抽象产品只能生产一种产品。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间一一对应。
    4.实现
    public class AbstractFactory{
        public static void main(String[] args){
            try{
                Product a;
                AbstractFactory af;
                af = (AbstractFactory) ReadXML1.getObject();
                a = af.newProduct();
                a.show();
            }catch(Exception e){
                System.out.println(e.getMessage());
            }
        }

        //抽象产品
        interface Product{
            public void show();
        }

        //具体产品1:实现抽象产品中的抽象方法
        class ConcreteProduct1 implements Product{
            public void show(){
                System.out.println("具体产品1");
            }
        }

        //具体产品2:实现抽象产品中的抽象方法
        class ConcreteProduct2 implements Product{
            public void show(){
                System.out.println("具体产品2");
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory1 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品1");
                return new ConcreteProduct1;
            }
        }

        //抽象工厂：提供了产品的生成方法
        class ConcreteFactory2 implements AbstractFactory {
            public Product newProduct(){
                System.out.println("具体工厂生产--》具体产品2");       
                return new ConcreteProduct2;

            }
        }
    }
五、抽象工厂模式
    1.定义
        为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。工厂方法模式只生产一个等级的产品，
        而抽象工厂模式可以生产多个等级的产品。
    2.优缺点
    （1）优点：
        可以在类内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
        当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品族。
        抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码。
    （2）缺点：
        当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。
    3.结构
    （1）抽象工厂：提供了创建产品的接口，包含了多个创建产品的方法，可以创建多个不同等级的产品。
    （2）具体工厂：实现抽象工厂中的抽象方法，完成具体产品的创建。
    （3）抽象产品：定义产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
    （4）具体产品：实现抽象产品所定义的接口，由具体工厂来创建，同具体工厂之间是多对一的关系。
    4.实现
        抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。
    interface AbstractFactory {
        public Product1 newProduct1();
        public Product2 newProduct2();
    }
六、建造者模式
    1.定义
        将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。
    2.优缺点
    （1）优点：
        封装性好，构建和表示分离。
        扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
        客户端不知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响。
    （2）缺点：
        产品的组成部分必须相同。
        如果产品内部发生变化，则建造者也要同步修改。
    3.结构
    （1）产品角色：包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。
    （2）抽象建造者：包含创建产品各个部件的抽象方法的接口，通常还包含一个返回复杂产品的方法getResult()。
    （3）具体建造者：实现Builder接口，完成复杂产品的各个部件的具体创建方法。
    （4）指挥者：调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不包含具体产品的信息。
    4.实现
    //产品角色
    class Product{
        private String partA;
        private String partB;

        public void setPartA(String partA){
            this.partA = partA;
        }

        public void setPartB(String partB){
            this.partB = partB;
        }

        public void show(){
            //显示产品特性
        }
    }

    //抽象建造者
    abstract class Builder{
        //创建产品对象
        protected Product product = new Product();

        public abstract void buildPartA();

        public abstract void buildPartB():

        //返回产品对象
        public Product getResult(){
            return product;
        }
    }

    //具体建造者
    public class ConcreteBuilder extends Builder{
        public void buildPartA(){
            product.setPartA("建造PartA");
        }

        public void buildPartB(){
            product.setPartB("建造PartB");
        }
    }

    //指挥者
    class Director{
        private Builder builder;

        public Director(Builder builder){
            this.builder = builder;
        }

        //产品构建与组装方法
        public Product construct(){
            builder.buildPartA();
            builder.buildPartB();
            return builder.getResult();
        }
    }

    //客户类
    public class client{
        public static void main(String[] args){
            Builder builder = new ConcreteBuilder();
            Director director = new Director(builder);
            Product product = director.construct();
            product.show();
        }
    }
七、代理模式
    1.定义
        由于某些原因需要给对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象
    之间的中介。
    2.优缺点
    （1）优点：
        代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。
        代理对象可以扩展目标对象的功能。
        代理模式能将客户端与目标对象分离，在一定成都上降低了系统的耦合度。
    （2）缺点：
        会造成系统设计中类的数量增加。
        在客户端和目标对象之间增加一个代理对象会造成请求处理速度变慢。
        增加系统的复杂度。
    3.结构
    （1）抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    （2）真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
    （3）代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能。
    4.实现
        静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的.class文件就已经存在了。
        动态代理：在程序运行时运用反射机制动态创建而成。
    public class ProxyTest{
        public static void main(String[] args){
            Proxy proxy = new Proxy();
            proxy.Request();
        }
    }

    //抽象主题
    interface Subject{
        void Request();
    }

    //真实主题
    class RealSubject implements Subject{
        public void Request(){
            System.out.println("访问真实主题方法");
        }
    }

    //代理
    class Proxy implements Subject {
        private RealSubject realSubject;

        public void Request(){
            if(realSubject == null){
                realSubject = new RealSubject();
            }

            preRequest();
            realSubject.Request();
            postRequest();
        }

        public void preRequest(){
            System.out.println("访问真实主题之前的预处理")
        }

        public void postRequest(){
            System.out.println("访问真实主题之后的处理")
        }
    }
八、适配器模式
    1.定义
        将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类能一起工作。
    2.优缺点
    （1）优点：
        客户端通过适配器可以透明地调用目标接口。
        复用了现存的类，不需要修改原有代码而重用现有的适配者类。
        将目标类和适配者类解耦，解决目标类和适配者类接口不一致的问题。
    （2）缺点：
        适配器编写过程需要结合业务场景全面考虑，增加系统的复杂性。
    3.结构
    （1）目标接口：当前业务系统所期待的接口，可以是抽象类或接口。
    （2）适配者类：是被访问和适配的现存组件库中的组件接口。
    （3）适配器类：是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标的格式访问适配者。
    4.实现
    （1）类适配器模式
    //目标接口
    interface Target{
        public void request();
    }

    //适配者接口
    class Adaptee{
        public void specificRequest(){
            System.out.println("适配者中的业务代码被调用");
        }
    }

    //类适配器
    class ClassAdapter extends Adaptee implements Target{
        public void request(){
            specificRequest();
        }
    }

    //客户端代码
    public class ClassAdapterTest{
        public static void main(String[] args){
            System.out.println("类适配器测试");
            Target Target = new ClassAdapter();
            Target.request();
        }
    }
    （2）对象适配器
    class ObjectAdapter implements Target{
        private Adaptee Adaptee;
        public ObjectAdapter(Adaptee abstract){
            this.adaptee = adaptee;
        }
        public void request(){
            adaptee.specificRequest();
        }
    }

    public class ObjectAdapterTest{
        public static void main(String[] args){
            System.out.println("对象适配器测试");
            Adaptee adaptee = new Adaptee();
            Target target = new ObjectAdapter();
            target.request();
        }
    }
九、桥接模式
    1.定义
        将抽象与显示分离，可以独立变化，用组合关系代替继承关系来实现，降低抽象和实现这两个可变维度的耦合。
    2.优缺点
    （1）优点：
        扩展能力强，实现细节对客户透明。
    （2）缺点：
        聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确识别出系统中两个独立变化的维度。
    3.结构
    （1）抽象化角色：定义抽象类，并包含一个对实现化对象的引用。
    （2）扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，通过组合关系调用实现化角色中的业务方法。
    （3）实现化角色：定义实现化角色的接口，供扩展抽象化角色调用。
    （4）具体实现化角色：给出实现化角色接口的具体实现。
    4.实现
    public class BridgeTest{
        public static void main(String[] args){
            Implementor imple = new ConcreteImplementorA();
            Abseraction abs = new RefinedAbstraction(imple);
            abs.Operation();
        }
    }

    //实现化角色
    interface Implementor {
        public void OperationImpl();
    }

    //具体实现化角色
    class ConcreteImplementorA implements Implementor{
        public void OperationImpl(){
            System.out.println("具体实现化角色被访问")
        }
    }

    //抽象化角色
    abstract class Abstraction{
        protected Implementor imple;

        protected Abstraction(Implementor imple){
            this.imple = imple;
        }

        public abstract void Operation();
    }
    
    //扩展抽象化角色
    class RefinedAbstraction extends Abstraction{
        protected RefinedAbstraction(Implementor imple){
            super(imple);
        }

        public void Operation(){
            System.out.println("扩展抽象化角色被访问")
        }
    }

十、装饰器模式
    1.定义
        指在不改变现有对象结构的情况下，动态地给该对象增加一些职责。
    2.优缺点
    （1）优点：
        是继承的有力补充，在不改变原有对象的情况下动态的给一个对象扩展功能，即插即用。
        通过使用不用装饰类及这些装饰类的排列组合可以实现不同效果。
    （2）缺点：
        会增加许多子类，增加程序复杂性。
    3.结构
    （1）抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。
    （2）具体构建角色：实现抽象构件通过装饰角色为其添加一些职责。
    （3）抽象装饰角色：继承抽象构件并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
    （4）具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
    4.实现
    public class DecoratorPattern{
        public class static void main(String[] args){
            Component p = new ConcreteComponent();
            p.operation();
            System.out.println("--------");
            Component d = new ConcreteDecorator(p);
            d.operation();
        }
    }

    //抽象构件角色
    interface Component{
        public void operation();
    }

    //具体构件角色
    class ConcreteComponent implements Component{
        public ConcreteComponent(){
            System.out.println("创建具体构建角色");
        }

        public void operation(){
            System.out.println("调用具体构件角色的方法");
        }
    }

    //抽象装饰角色
    class Decorator implements Component {
        private Component component;

        public Decorator (Component component){
            this.component = component;
        }

        public void operation(){
            component.operation();
        }
    }

    //具体装饰角色
    class ConcreteDecorator extends Decorator {
        public ConcreteDecorator(Component component){
            super(component);
        }

        public void operation(){
            super.operation();
            addedFunction();
        }

        public void addedFunction(){
            System.out.println("为具体构件角色增加额外功能")
        }
    }
十一、外观模式
    1.定义
        通过为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节。
    2.优缺点
    （1）优点：
        降低子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
        对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
    （2）缺点：
        不能很好的限制客户使用子系统类，容易带来未知风险。
    3.结构
    （1）外观角色：为多个子系统提供一个共同的接口。
    （2）子系统角色：实习系统的部分功能，客户可以通过外观角色访问它。
    （2）客户角色：通过一个外观角色访问各个子系统的功能。
    4.实现
    public class FacadePattern{
        public static void main(String[] args){
            Facade f = new Facade();
            f.method();
        }
    }

    //外观角色
    class Facade {
        private SubSystem01 obj1 = new SubSystem01();
        private SubSystem02 obj2 = new SubSystem02();

        public void method(){
            obj1.method1();
            obj2.method2();
        }
    }

    //子系统角色
    class SubSystem01 {
        public void method1(){
            System.out.println("子系统01的method1被调用");
        }
    }

    //子系统角色
    class SubSystem01 {
        public void method1(){
            System.out.println("子系统01的method1被调用");
        }
    }

    //子系统角色
    class SubSystem02 {
        public void method2(){
            System.out.println("子系统02的method1被调用");
        }
    }

    //子系统角色
    class SubSystem02 {
        public void method2(){
            System.out.println("子系统02的method1被调用");
        }
    }
十二、享元模式
    1.定义
        运用共享技术来有效地支持大量细粒度对象的复用。
    2.优缺点
    （1）优点：
        相同对象只要保存一份，降低了系统中对象的数量。
    （2）缺点：
        为了使对象可以共享，需要将一些不能共享的状态外部化，增加系统复杂性。
        读取享元模式的外部状态会使运行时间变长。
    3.结构
    （1）抽象享元角色：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
    （2）具体享元角色：实现抽象享元角色中所规定的接口。
    （3）非享元角色：不可以共享的外部状态，以参数的形式注入具体享元的相关方法中。
    （4）享元工厂角色：负责创建和管理享元角色，当客户对象请求创建一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户；
    如果不存在则创建一个新的享元对象。
    4.实现
    //非享元角色
    class UnsharedConcreteFlyweight{
        private String info;

        UnsharedConcreteFlyweight(String info){
            this.info = info;
        }

        public String getInfo(){
            return info;
        }

        public void setInfo(String info){
            this.info = info;
        }
    }

    //抽象享元角色
    interface Flyweight {
        public void operation(UnsharedConcreteFlyweight state);
    }

    //具体享元角色
    class ConcreteFlyweight implements Flyweight {
        private String key;

        ConcreteFlyweight(String key){
            this.key = key;
            System.out.println("具体享元"+key+"被创建");
        }

        public void operation(UnsharedConcreteFlyweight outState){
            System.out.println("具体享元"+key+"被调用");
            System.out.println("非享元信息是："+outState.getInfo());
        }
    }

    //享元工厂角色
    class FlyweightFactory{
        private HashMap<String,Flyweight> flyweights = new HashMap<String,Flyweight>();

        public Flyweight getFlyweight(String key){
            Flyweight flyweight = (Flyweight) flyweights.get(key);
            if (flyweight != null){
                System.out.println("具体享元"+key+"已经存在，被成功获取");
            }else{
                flyweight = new ConcreteFlyweight(key);
                flyweights.put(key,flyweight);
            }
            return flyweight;
        }
    }
十三、组合模式
    1.定义
        将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性。
    2.优缺点
    （1）优点：
        组合模式使得客户端代码可以一直地处理单个对象和组合对象，无须关心自己处理的是单个对象还是组合对象。
        更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码。
    （2）缺点：
        设计复杂
        不容易限制容器中的构件
        不容易用继承的方法来增加构件的新功能
    3.结构
    （1）抽象构件角色：主要作用是为树叶构件和树枝构件声明公共接口，并实现他们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；
        在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。
    （2）树叶构件角色：组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。
    （3）树枝构件角色：组合中的分支节点对象，有子节点，用于继承和实现抽象构件，主要作用是存储和管理子部件。
    4.实现
    （1）透明方式：由于抽象构件声明了所有子类中的全部方法，客户端无须区别树叶对线和树枝对象，对客户端来说是透明的。
    （2）安全方式：将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有子对象的管理方法，由于叶子和分支有不同的接口，客户端在调用时要知道
    树叶对象和树枝对象的存在，所以失去了透明性。
    interface Component{
        public void add(Component c);

        public void remove(Component c);

        public Component getChild(int i);

        public void operation();
    }

    class Leaf implements Component{
        private String name;

        public Leaf(String name){
            this.name = name;
        }

        public void add(Component c){
        }

        public void remove(Component c){
        }

        public Component getChild(int i){
            return null;
        }

        public void operation(){
            System.out.println("树叶"+name+"：被访问");
        }
    }

    class Composite implements Component{
        private ArrayList<Component> children = new ArrayList<Component>();

        public void add(Component c){
            children.add(c);
        }

        public void remove(Component c){
            children.remove(c);
        }

        public Component getChild(int i){
            return children.get(i);
        }

        public void operation(){
            for(Object obj:children){
                ((Component) obj).operation();
            }
        }
    }
十四、模版方法
    1.定义
        定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重新定义该算法的某些特定步骤。
    2.优缺点
    （1）优点：
        把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类扩展。
        在父类中提取了公共的部分代码便于代码复用。
        部分方法是由子类实现的，子类可以通过扩展的方式增加相应的功能。
    （2）缺点：
        对每个不同的实现都需要定义一个子类，导致类的个数增加，系统更加庞大，设计更抽象，间接增加了系统实现的复杂度。
        父类中的抽象方法由子类实现，子类执行的结果会影响父类。
        由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有的子类都要更改。
    3.结构
    （1）抽象模版类：负责给出一个算法的轮廓和骨架。
        模版方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
        基本方法：
            抽象方法：在抽象类中声明，由具体子类实现。
            具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
            钩子方法：在抽象类中已经实现，包括由于判断的逻辑方法和需要子类重写的空方法两种。
    （2）具体子类：实现抽象类中所定义的抽象方法和钩子方法。
    4.实现
    //抽象类
    abstract class AbstractClass{
        //模版方法
        public void TemplateMethod(){
            SpecificMethod();
            abstractMethod1();
            abstractMethod2();
        }

        //具体方法
        public void SpecificMethod(){
            System,out.println("抽象类中的具体方法被调用");
        }

        //抽象方法1
        public abstract void abstractMethod1();

        //抽象方法2
        public abstract void abstractMethod2();
    }

    class ConcreteClass extends AbstractClass{
        public void abstractMethod1(){
            System.out.println("抽象方法1的实现被调用");
        }

        public void abstractMethod2(){
            System.out.println("抽象方法2的实现被调用");
        }
    }
十五、策略模式
    1.定义
        该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。
    2.优缺点
    （1）优点：
        多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。
        提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，避免重复的代码。
        提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。
    （2）缺点：
        客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。
        策略模式造成很多的策略类，增加维护难度。
    3.结构
    （1）抽象策略类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
    （2）具体策略类：实现了抽象策略定义的接口，提供具体的算法实现。
    （3）环境类：持有一个策略类的引用，最终给客户端调用。
    4.实现
    //抽象策略类
    interface Strategy{
        public void strategyMethod();   //策略方法
    }

    //具体策略类A
    class ConcreteStrategyA implements Strategy {
        public void strategyMethod(){
            System.out.println("具体策略A的策略方法被访问");
        }
    }

    //具体策略类B
    class ConcreteStrategyB implements Strategy {
        public void strategyMethod(){
            System.out.println("具体策略B的策略方法被访问");
        }
    }

    class Context {
        private Strategy strategy;

        public Strategy getStrategy(){
            return strategy;
        }

        public void setStrategy(Strategy strategy){
            this.strategy = strategy;
        }

        public void strategyMethod(){
            strategy.strategyMethod();
        }
    }
十六、命令模式
    1.定义
        将一个请求封装成一个对象，使发出的请求和执行请求的责任分隔开。
    2.优缺点
    （1）优点：
        通过引入中间件（抽象接口）降低系统的耦合度。
        扩展性良好，增加或删除命令非常方便。
        可以实现宏命令，命令模式与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
        方便实现Undo和Redo命令。
        可以在现有命令的基础上增加额外功能。
    （2）缺点：
        可能产生大量具体的命令类。
    3.结构
    （1）抽象命令类角色：声明执行命令的接口，拥有执行命令的抽象方法。
    （2）具体命令类角色：是抽象命令类的具体实现类，拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
    （3）实现者/接收者：执行命令功能的相关操作，是具体命令对象业务的真正实现者。
    （4）调用者/请求者：是请求的发送者，通常拥有很多的命令对象，并通过访问命令对象来执行相关的请求，不直接访问接收者。
    4.实现
    //调用者
    class Invoker {
        private Command Command;

        public Invoker(Command command){
            this.command = command;
        }

        public void setCommand(Command command){
            this.command = command;
        }

        public void call(){
            System.out.println("调用者执行命令command");
            command.execute();
        }
    }

    //抽象命令
    interface Command{
        public abstract void execute();
    }

    //具体命令
    class ConcreteCommand implements Command {
        private Receiver receiver;

        ConcreteCommand(){
            receiver = new Receiver();
        }

        public void execute(){
            receiver.action();
        }
    }

    //接收者
    class Receiver{
        public void action(){
            System.out.println("接收者的action()方法被调用");
        }
    }
十七、责任链模式
    1.定义
        为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连城一条链，当有请求发生时，
        可将请求沿着这条链传递，直到有对象处理它为止。
    2.优缺点
    （1）优点：
        降低了对象之间的耦合度，使得一个对象无须直到到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。
        增加系统的可扩展性。
        增强了贵对象指派职责的灵活性，当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序。
        简化了对象之间的连接。
        每个类只需要处理自己该处理的工作。
    （2）缺点：
        不能保证每个请求一定被处理。
    3.结构
    （1）抽象处理者：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
    （2）具体处理者：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将请求转给它的后继者。
    （3）客户类：创建处理链，并向链头的具体处理者对象提交请求，不关心处理细节和请求的传递过程。
    4.实现
    //抽象处理者
    abstract class Handler{
        private Handler next;

        public void setNext(Handler next){
            this.next = next;
        }

        public Handler getNext(){
            return next;
        }

        //处理请求的方法
        public abstract void handleRequest(String request);
    }

    class ConcreteHandler1 extends Handler{
        public void handleRequest(String request){
            if(request.equals("one")){
                System.out.println("具体处理者1负责处理该请求");
            }else{
                if(getNext() != null){
                    getNext().handleRequest(request);
                }else{
                    System.out.println("没有人处理该请求");
                }
            }
        }
    }

    class ConcreteHandler2 extends Handler{
        public void handleRequest(String request){
            if(request.equals("two")){
                System.out.println("具体处理者2负责处理该请求");
            }else{
                if(getNext() != null){
                    getNext().handleRequest(request);
                }else{
                    System.out.println("没有人处理该请求");
                }
            }
        }
    }

    public class ChainOfResponsibilityPattern {
        public static void main(String[] args) {
            //组装责任链
            Handler handler1 = new ConcreteHandler1();
            Handler handler2 = new ConcreteHandler2();
            handler1.setNext(handler2);
            //提交请求
            handler1.handleRequest("two");
        }
    }
十八、状态模式
    1.定义
        对有状态的对象把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。
    2.优缺点
    （1）优点：
        结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来。
        将状态转换显示化，减少对象间的相互依赖。
        状态类职责明确，有利于程序的扩展。
    （2）缺点：
        状态模式的使用会增加系统的类与对象的个数。
        状态模式的结构与实现较为复杂，使用不当会导致代码混乱。
    3.结构
    （1）环境类：也称上下文，定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
    （2）抽象状态类：定义一个接口，用来封装环境对象中的的特定状态所对应的行为，可以有一个或多个行为。
    （3）具体状态类：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。
    4.实现
    //环境类
    class Context {
        private State state;

        public Context(){
            this.state = new ConcreteStateA();
        }

        public void setState(State state){
            this.state = state;
        }

        public State getState(){
            return (state);
        }

        public void Handler(){
            state.Handle(this);
        }
    }

    //抽象状态类
    abstract class State {
        public abstract void Handle(Context context);
    }

    //具体状态类A
    class ConcreteStateA extends State {
        public void Handle(Context context){
            System.out.println("当前状态是：A");
            context.setState(new ConcreteStateA());
        }
    }

    //具体状态类B
    class ConcreteStateB extends State {
        public void Handle(Context context){
            System.out.println("当前状态是：B");
            context.setState(new ConcreteStateB());
        }
    }
十九、观察者模式
    1.定义
        指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。有时又称作发布-订阅
        模式、模型-视图模式，是对象行为型模式。
    2.优缺点
    （1）优点： 
        降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
        目标与观察者之间建立了一套触发机制。
    （2）缺点：
        目标与观察者之间的依赖关系并没有完全接触，而且有可能出现循环引用。
        当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。
    3.结构
    （1）抽象主题角色：也叫抽象目标类，提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的方法。
    （2）具体主题角色：也叫具体目标类，实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
    （3）抽象观察者角色：是一个抽象类或接口，包含一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
    （4）具体观察者角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。
    4.实现
    //抽象目标
    abstract class Subject {
        protected List<Observer> observers = new ArrayList<Observer>();

        //增加观察者方法
        public void add(Observer observer){
            observers.add(observer);
        }

        //删除观察者方法
        public void remove(Observer observer){
            observers.remove(observer);
        }

        public abstract void notifyObserver();
    }

    //具体目标
    class ConcreteSubject extends Subject {
        public void notifyObserver(){
            System.out.println("具体目标发生改变");

            for(Object obs : observers){
                ((Observer) obs).response();
            }
        }
    }

    //抽象观察者
    interface Observer {
        void response();
    }

    //具体观察者1   
    class ConcreteObserver1 implements Observer {
        public void response(){
            System.out.println("具体观察者1作出反应");
        }
    }

    //具体观察者2
    class ConcreteObserver2 implements Observer {
        public void response(){
            System.out.println("具体观察者2作出反应");
        }
    }

    public class ObserverPattern {
        public static void main(String[] args){
            Subject subject = new ConcreteSubject();
            Observer obs1 = new ConcreteObserver1();
            Observer obs2 = new ConcreteObserver2();
            subject.add(obs1);
            subject.add(obs2);
            subject.notifyObserver();
        }
    }
二十、中介者模式
    1.定义：
        定义一个中介对象来封装一系列对象之间的交互，使原有对象之间耦合松散，且可以独立地改变它们之间的交互。
    2.优缺点
    （1）优点：
        降低了对象之间的耦合性，使得对象易于独立地被复用。
        将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。
    （2）缺点：
        将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，复杂且难以维护。
    3.结构
    （1）抽象中介者：是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
    （2）具体中介者：实现中介者接口，定义一个List来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
    （3）抽象同事类：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
    （4）具体同事类：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。
    4.实现
    //抽象中介者
    abstract class Mediator {
        public abstract void register(Colleague colleague);

        public abstract void relay(Colleague colleague);
    }

    //具体中介者
    class ConcreteMediator extends Mediator {
        private List<Colleague> colleagues = new ArrayList<Colleague>();

        public void register(Colleague colleague){
            if(!colleagues.contains(colleague)){
                colleagues.add(colleague);
                colleague.setMedium(this);
            }
        }

        public void relay(Colleague c1){
            for(Colleague ob : colleagues){
                if (!ob.equals(c1)){
                    ((Colleague) ob).receive();
                }
            }
        }
    }

    //抽象同事类
    abstract class Colleague {
        protected Mediator mediator;

        public void setMedium(Mediator mediator){
            this.mediator = mediator;
        }

        public abstract void receive();

        public abstract void send();
    }

    //具体同事类
    class ConcreteColleague1 extends Colleague {
        public void receive(){
            System.out.println("具体同事类1收到请求");
        }

        public void send(){
            System.out.println("具体同事类1发出请求");
            mediator.relay
        }
    }

    //具体同事类
    class ConcreteColleague2 extends Colleague {
        public void receive(){
            System.out.println("具体同事类2收到请求");
        }

        public void send(){
            System.out.println("具体同事类2发出请求");
            mediator.relay
        }
    }

    public class MediatorPattern {
        public static void main(String[] args) {
            Mediator md = new ConcreteMediator();
            Colleague c1, c2;
            c1 = new ConcreteColleague1();
            c2 = new ConcreteColleague2();
            md.register(c1);
            md.register(c2);
            c1.send();
            System.out.println("-----------");
            c2.send();
        }
    }
二十一、迭代器模式
    1.定义
        提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
    2.优缺点
    （1）优点：
        访问一个聚合对象的内容而无须暴露它的内部表示。
        遍历任务交由迭代器完成，简化了聚合类。
        支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。
        增加新的聚合类和迭代器类都很方便，无须修改原有代码。
        封装性良好，为遍历不同的聚合结构提供一个统一的接口。
    （2）缺点：
        增加了类的个数，在一定程度上增加了系统的复杂性。
    3.结构
    （1）抽象聚合角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
    （2）具体聚合角色：实现抽象聚合类，返回一个具体迭代器的实例。
    （3）抽象迭代器角色：定义访问和遍历聚合元素的接口，通常包含hasNext()、first()、next()等方法。
    （4）具体迭代器角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。
    4.实现
    //抽象聚合
    interface Aggregate {
        public void add(Object obj);

        public void remove(Object obj);

        public Iterator getIterator();
    }

    //具体聚合
    class ConcreteAggregate implements Aggregate {
        private List<Object> list = new ArrayList<Object>();

        public void add(Object obj){
            list.add(obj);
        }

        public void remove(Object obj){
            list.remove(obj);
        }

        public Iterator getIterator(){
            return (new ConcreteIterator(list));
        }
    }

    //抽象迭代器
    interface Iterator {
        Object first();

        Object next();

        boolean hasNext();
    }

    //具体迭代器
    class ConcreteIterator implements Iterator {
        private List<Object> list = null;

        private int index = -1;

        public ConcreteIterator(List<Object> list){
            this.list = list;
        }

        public boolean hasNext(){
            if(index < list.size() -1){
                return true;
            }else{
                return false;
            }
        }

        public Object first(){
            index = 0;
            Object obj = list.get(index);
            return obj;
        }

        public Object next(){
            Object obj = null;
            if(this.hasNext()){
                obj = list.get(++index);
            }
            return obj;
        }
    }

    public class IteratorPattern {
        public void main(String[] args){
            Aggregate ag = new ConcreteAggregate();
            ag.add("中山大学");
            ag.add("华南理工");
            System.out.println("聚合的内容有：");
            Iterator it = ag.getIterator();
            while(it.hasNext()){
                Object ob = it.next();
                System.out.println(ob.toString() + "\t");
            }
            Object ob = it.first();
            System.out.println("\nFirst:"+ob.toString());
        }
    }
二十二、访问者模式
    1.定义
        将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。
    2.优缺点
    （1）优点：
        扩展性好，能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
        复用性好，可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
        灵活性好，将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
        符合单一职责原则，访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。
    （2）缺点：
        增加新的元素类很困难，每增加一个新的元素类，都要在每一个具体访问类中增加相应的具体操作。
        具体元素对访问者公布细节，破坏了对象的封装性。
    3.结构
    （1）抽象访问者：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作，该操作中的参数类型标识破坏了被访问的具体元素。
    （2）具体访问者：实现抽象访问角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
    （3）抽象元素：声明一个包含接受操作accept()的接口，被接受的访问者对象作为accept()方法的参数。
    （4）具体元素：实现抽象元素角色提供的accept()操作，其方法体通常都是visitor.visit(this)，另外具体元素中可能还包含本身业务逻辑的相关操作。
    （5）对象结构：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由List、Set、Map等聚合类实现。
    4.实现
    //抽象访问者
    interface Visitor {
        void visit(ConcreteElementA element);

        void visit(ConcreteElementB element);
    }

    //具体访问者A
    class ConcreteVisitorA implements Visitor {
        public void visit (ConcreteElementA element){
            System.out.println("具体访问者A访问"+element.operationA());
        }

        public void visit (ConcreteElementB element){
            System.out.println("具体访问者B访问"+element.operationB());
        }
    }

     //具体访问者B
    class ConcreteVisitorB implements Visitor {
        public void visit (ConcreteElementA element){
            System.out.println("具体访问者A访问"+element.operationA());
        }

        public void visit (ConcreteElementB element){
            System.out.println("具体访问者B访问"+element.operationB());
        }
    }

    //抽象元素类
    interface Element {
        void accept(Visitor visitor);
    }

    //具体元素
    class ConcreteElementA implements Element {
        public void accept(Visitor visitor){
            visitor.visit(this);
        }

        public String operationA(){
            return "具体元素A的操作";
        }
    }

    //具体元素
    class ConcreteElementB implements Element {
        public void accept(Visitor visitor){
            visitor.visit(this);
        }

        public String operationB(){
            return "具体元素B的操作";
        }
    }

    //对象结构角色
    class ObjectStructure {
        private List<Element> list = new ArrayList<Element>();

        public void accept(Visitor visitor){
            Iterator<Element> i = list.iterator();
            while(i.hasNext()){
                ((Element)i.next()).accept(visitor);
            }
        }

        public void add(Element element){
            list.add(element);
        }

        public void remove(Element element){
            list.remove(element);
        }
    }

    public class VisitorPattern {
        public static void main(String[] args){
            ObjectStructure os = new ObjectStructure();
            os.add(new ConcreteElementA());
            os.add(new ConcreteElementB());
            Visitor visitor = new ConcreteVisitorA();
            os.accept(visitor);
            System.out.println("-----------");
            visitor = new ConcreteVisitorB();
            os.accept(visitor);
        }
    }
二十三、备忘录模式
    1.定义
        在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。
    2.优缺点
    （1）优点：
        提供了一种可以恢复状态的机制，当用户需要时能比较方便的将数据恢复到某个历史状态。
        实现了内部状态的封装，除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
        简化了发起人类，发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理。
    （2）缺点：
        资源消耗大，如果要保存的内部状态信息过多或者频繁，将会占用比较大的内存资源。
    3.结构
    （1）发起人：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务，可以访问备忘录里的所有信息。
    （2）备忘录：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
    （3）管理者：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。
    4.实现
    //备忘录
    class Memento {
        private String state;

        public Memento(String state){
            this.state = state;
        }

        public void setState(String state){
            this.state = state;
        }

        public String getState(){
            return state;
        }
    }

    //发起人
    class Originator {
        private String state;

        public void setState(String state){
            this.state = state;
        }

        public String getState(){
            return state;
        }

        public Memento createMemento(){
            return new Memento(state);
        }

        public void restoreMemento(Memento m){
            this.setState(m.getState());
        }
    }

    //管理者
    class Caretaker {
        private Memento memento;

        public void setMemento(){
            memento = m;
        }

        public Memento getMemento(){
            return memento;
        }
    }

    public class MementoPattern {
        public static void main(String[] args){
            Originator or = new Originator();
            Caretaker cr = new Caretaker();
            or.setState("S0");
            System.out.println("初始状态："+or.getState());
            or.setState("S1");
            System.out.println("新的状态："+ or.getState());
            or.restoreMemento(cr.getMemento());
            System.out.println("恢复状态："+ or.getState());
        }
    }
二十三、解释器模式
    1.定义
        给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言的句子。
    2.优缺点
    （1）优点：
        扩展性好，由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
        容易实现，在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。
    （2）缺点：
        执行效率低，解释器模式中通常使用大量的循环和递归调用，当要解释的句子较为复杂时，其运行速度很慢，且代码的吊饰过程也较为麻烦。
        会引起类膨胀，解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理和维护。
    3，结构
    （1）抽象表达式：定义解释器的接口，约定解释器的解释操作，主要包含解释方法interpret();
    （2）终结符表达式：是抽象表达式的子类，用来实现文法与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。
    （3）非终结符表达式：也是抽象表达式的子类，用来实现文法与非终结符相关的操作，文法中的每条规则都对应于一个非终结表达式。
    （4）环境角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。
    （5）客户端：主要任务是将需要分析的子句或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法。
    4.实现
    //抽象表达式类
    interface AbstractExpression {
        public void interpret(String info); //解释方法
    }

    //终结符表达式
    class TerminalExpress implements AbstractExpression {
        public void interpret(String info){
            //对终结符表达式的处理
        }
    }

    //非终结符表达式类
    class NonterminalExpression implements AbstractExpression {
        private AbstractExpress exp1;
        private AbstractExpress exp2;

        public void interpret(String info){
            //非对终结符表达式的处理
        }
    }

    //环境类
    class Context {
        private AbstractExpression exp;

        public Context(){
            //数据初始化
        }

        public void operation(String info){
            //调用相关表达式类的解释方法
        }
    }